SCRIPT  /home/farhaan/.local/share/nvim/lazy/telescope.nvim/ftplugin/TelescopePrompt.lua
Sourced 1 time
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
                            -- Don't wrap textwidth things
                            vim.opt_local.formatoptions:remove "t"
                            vim.opt_local.formatoptions:remove "c"
                            
                            -- Don't include `showbreak` when calculating strdisplaywidth
                            vim.opt_local.wrap = false
                            
                            -- There's also no reason to enable textwidth here anyway
                            vim.opt_local.textwidth = 0
                            vim.opt_local.scrollbind = false
                            
                            vim.opt_local.signcolumn = "no"

SCRIPT  /home/farhaan/.local/share/nvim/lazy/telescope.nvim/ftplugin/TelescopeResults.lua
Sourced 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
                            -- Don't have scrolloff, it makes things weird.
                            vim.opt_local.scrolloff = 0
                            vim.opt_local.scrollbind = false
                            
                            vim.opt_local.signcolumn = "no"

SCRIPT  /usr/local/share/nvim/runtime/ftplugin/tex.vim
Sourced 2 times
Total time:   0.000244
 Self time:   0.000091

count  total (s)   self (s)
                            " LaTeX filetype plugin
                            " Language:     LaTeX (ft=tex)
                            " Maintainer:   Benji Fisher, Ph.D. <benji@member.AMS.org>
                            " Version:	1.4
                            " Last Change:	Wed 19 Apr 2006
                            "  URL:		http://www.vim.org/script.php?script_id=411
                            
                            " Only do this when not done yet for this buffer.
    2              0.000008 if exists("b:did_ftplugin")
    1              0.000001   finish
    1              0.000001 endif
                            
                            " Start with plain TeX.  This will also define b:did_ftplugin .
    1   0.000171   0.000018 source $VIMRUNTIME/ftplugin/plaintex.vim
                            
                            " Avoid problems if running in 'compatible' mode.
    1              0.000004 let s:save_cpo = &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000002 let b:undo_ftplugin .= "| setl inex<"
                            
                            " Allow "[d" to be used to find a macro definition:
                            " Recognize plain TeX \def as well as LaTeX \newcommand and \renewcommand .
                            " I may as well add the AMS-LaTeX DeclareMathOperator as well.
    1              0.000008 let &l:define .= '\|\\\(re\)\=new\(boolean\|command\|counter\|environment\|font'
                            	\ . '\|if\|length\|savebox\|theorem\(style\)\=\)\s*\*\=\s*{\='
                            	\ . '\|DeclareMathOperator\s*{\=\s*'
                            
                            " Tell Vim how to recognize LaTeX \include{foo} and plain \input bar :
    1              0.000003 let &l:include .= '\|\\include{'
                            " On some file systems, "{" and "}" are included in 'isfname'.  In case the
                            " TeX file has \include{fname} (LaTeX only), strip everything except "fname".
    1              0.000004 let &l:includeexpr = "substitute(v:fname, '^.\\{-}{\\|}.*', '', 'g')"
                            
                            " The following lines enable the macros/matchit.vim plugin for
                            " extended matching with the % key.
                            " ftplugin/plaintex.vim already defines b:match_skip and b:match_ignorecase
                            " and matches \(, \), \[, \], \{, and \} .
    1              0.000002 if exists("loaded_matchit")
    1              0.000002   let b:match_words .= ',\\begin\s*\({\a\+\*\=}\):\\end\s*\1'
    1              0.000001 endif " exists("loaded_matchit")
                            
    1              0.000006 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:

SCRIPT  /usr/local/share/nvim/runtime/ftplugin/plaintex.vim
Sourced 1 time
Total time:   0.000146
 Self time:   0.000067

count  total (s)   self (s)
                            " plain TeX filetype plugin
                            " Language:     plain TeX (ft=plaintex)
                            " Maintainer:   Benji Fisher, Ph.D. <benji@member.AMS.org>
                            " Version:	1.1
                            " Last Change:	Wed 19 Apr 2006
                            
                            " Only do this when not done yet for this buffer.
    1              0.000002 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
                            
                            " Start with initex.  This will also define b:did_ftplugin and b:undo_ftplugin .
    1   0.000097   0.000018 source $VIMRUNTIME/ftplugin/initex.vim
                            
                            " Avoid problems if running in 'compatible' mode.
    1              0.000004 let s:save_cpo = &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000004 let b:undo_ftplugin .= "| unlet! b:match_ignorecase b:match_skip b:match_words"
                            
                            " Allow "[d" to be used to find a macro definition:
    1              0.000005 let &l:define .= '\|\\new\(count\|dimen\|skip\|muskip\|box\|toks\|read\|write'
                            	\ .	'\|fam\|insert\)'
                            
                            " The following lines enable the macros/matchit.vim plugin for
                            " extended matching with the % key.
                            " There is no default meaning for \(...\) etc., but many users define one.
    1              0.000003 if exists("loaded_matchit")
    1              0.000008   let b:match_ignorecase = 0
                                \ | let b:match_skip = 'r:\\\@<!\%(\\\\\)*%'
                                \ | let b:match_words = '(:),\[:],{:},\\(:\\),\\\[:\\],\\{:\\}'
    1              0.000001 endif " exists("loaded_matchit")
                            
    1              0.000006 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:

SCRIPT  /usr/local/share/nvim/runtime/ftplugin/initex.vim
Sourced 1 time
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
                            " filetype plugin for TeX and variants
                            " Language:     TeX (ft=initex)
                            " Maintainer:   Benji Fisher, Ph.D. <benji@member.AMS.org>
                            " Version:	1.0
                            " Last Change:	Wed 19 Apr 2006
                            
                            " Only do this when not done yet for this buffer.
    1              0.000002 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
                            
                            " Don't load another plugin for this buffer.
    1              0.000003 let b:did_ftplugin = 1
                            
                            " Avoid problems if running in 'compatible' mode.
    1              0.000005 let s:save_cpo = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000003 let b:undo_ftplugin = "setl com< cms< define< include< sua<"
                            
                            " Set 'comments' to format dashed lists in comments
    1              0.000006 setlocal com=sO:%\ -,mO:%\ \ ,eO:%%,:%
                            
                            " Set 'commentstring' to recognize the % comment character:
                            " (Thanks to Ajit Thakkar.)
    1              0.000004 setlocal cms=%%s
                            
                            " Allow "[d" to be used to find a macro definition:
    1              0.000007 let &l:define='\\\([egx]\|char\|mathchar\|count\|dimen\|muskip\|skip\|toks\)\='
                            	\ .	'def\|\\font\|\\\(future\)\=let'
                            
                            " Tell Vim to recognize \input bar :
    1              0.000003 let &l:include = '\\input'
    1              0.000002 setlocal suffixesadd=.tex
                            
    1              0.000007 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:

SCRIPT  /usr/local/share/nvim/runtime/indent/tex.vim
Sourced 2 times
Total time:   0.000316
 Self time:   0.000316

count  total (s)   self (s)
                            " Vim indent file
                            " Language:     LaTeX
                            " Maintainer:   Yichao Zhou <broken.zhou AT gmail.com>
                            " Created:      Sat, 16 Feb 2002 16:50:19 +0100
                            " Version: 1.0.0
                            "   Please email me if you found something I can do.  Comments, bug report and
                            "   feature request are welcome.
                            
                            " Last Update:  {{{
                            "               25th Sep 2002, by LH :
                            "               (*) better support for the option
                            "               (*) use some regex instead of several '||'.
                            "               Oct 9th, 2003, by JT:
                            "               (*) don't change indentation of lines starting with '%'
                            "               2005/06/15, Moshe Kaminsky <kaminsky AT math.huji.ac.il>
                            "               (*) New variables:
                            "                   g:tex_items, g:tex_itemize_env, g:tex_noindent_env
                            "               2011/3/6, by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Don't change indentation of lines starting with '%'
                            "                   I don't see any code with '%' and it doesn't work properly
                            "                   so I add some code.
                            "               (*) New features: Add smartindent-like indent for "{}" and  "[]".
                            "               (*) New variables: g:tex_indent_brace
                            "               2011/9/25, by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Bug fix: smartindent-like indent for "[]"
                            "               (*) New features: Align with "&".
                            "               (*) New variable: g:tex_indent_and.
                            "               2011/10/23 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Bug fix: improve the smartindent-like indent for "{}" and
                            "               "[]".
                            "               2012/02/27 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Bug fix: support default folding marker.
                            "               (*) Indent with "&" is not very handy.  Make it not enable by
                            "               default.
                            "               2012/03/06 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Modify "&" behavior and make it default again.  Now "&"
                            "               won't align when there are more then one "&" in the previous
                            "               line.
                            "               (*) Add indent "\left(" and "\right)"
                            "               (*) Trust user when in "verbatim" and "lstlisting"
                            "               2012/03/11 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Modify "&" so that only indent when current line start with
                            "                   "&".
                            "               2012/03/12 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Modify indentkeys.
                            "               2012/03/18 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Add &cpo
                            "               2013/05/02 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Fix problem about GetTeXIndent checker. Thank Albert Netymk
                            "                   for reporting this.
                            "               2014/06/23 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Remove the feature g:tex_indent_and because it is buggy.
                            "               (*) If there is not any obvious indentation hints, we do not
                            "                   alert our user's current indentation.
                            "               (*) g:tex_indent_brace now only works if the open brace is the
                            "                   last character of that line.
                            "               2014/08/03 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Indent current line if last line has larger indentation
                            "               2016/11/08 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Fix problems for \[ and \].  Thanks Bruno for reporting.
                            "               2017/04/30 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Fix a bug between g:tex_noindent_env and g:tex_indent_items
                            "                   Now g:tex_noindent_env='document\|verbatim\|itemize' (Emacs
                            "                   style) is supported.  Thanks Miles Wheeler for reporting.
                            "               2018/02/07 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Make indentation more smart in the normal mode
                            "               2020/04/26 by Yichao Zhou <broken.zhou AT gmail.com>
                            "               (*) Fix a bug related to \[ & \].  Thanks Manuel Boni for
                            "               reporting.
                            "
                            " }}}
                            
                            " Document: {{{
                            "
                            " For proper latex experience, please put
                            "         let g:tex_flavor = "latex"
                            " into your vimrc.
                            "
                            " * g:tex_indent_brace
                            "
                            "   If this variable is unset or non-zero, it will use smartindent-like style
                            "   for "{}" and "[]".  Now this only works if the open brace is the last
                            "   character of that line.
                            "
                            "         % Example 1
                            "         \usetikzlibrary{
                            "           external
                            "         }
                            "
                            "         % Example 2
                            "         \tikzexternalize[
                            "           prefix=tikz]
                            "
                            " * g:tex_indent_items
                            "
                            "   If this variable is set, item-environments are indented like Emacs does
                            "   it, i.e., continuation lines are indented with a shiftwidth.
                            "
                            "              set                      unset
                            "   ------------------------------------------------------
                            "       \begin{itemize}            \begin{itemize}
                            "         \item blablabla            \item blablabla
                            "           bla bla bla              bla bla bla
                            "         \item blablabla            \item blablabla
                            "           bla bla bla              bla bla bla
                            "       \end{itemize}              \end{itemize}
                            "
                            "
                            " * g:tex_items
                            "
                            "   A list of tokens to be considered as commands for the beginning of an item
                            "   command. The tokens should be separated with '\|'. The initial '\' should
                            "   be escaped. The default is '\\bibitem\|\\item'.
                            "
                            " * g:tex_itemize_env
                            "
                            "   A list of environment names, separated with '\|', where the items (item
                            "   commands matching g:tex_items) may appear. The default is
                            "   'itemize\|description\|enumerate\|thebibliography'.
                            "
                            " * g:tex_noindent_env
                            "
                            "   A list of environment names. separated with '\|', where no indentation is
                            "   required. The default is 'document\|verbatim'.
                            " }}}
                            
                            " Only define the function once
    2              0.000006 if exists("b:did_indent")
    1              0.000001     finish
    1              0.000001 endif
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000006 set cpo&vim
                            
                            " Define global variable {{{
                            
    1              0.000002 let b:did_indent = 1
                            
    1              0.000003 if !exists("g:tex_indent_items")
    1              0.000002     let g:tex_indent_items = 1
    1              0.000001 endif
    1              0.000002 if !exists("g:tex_indent_brace")
    1              0.000002     let g:tex_indent_brace = 1
    1              0.000001 endif
    1              0.000002 if !exists("g:tex_max_scan_line")
    1              0.000002     let g:tex_max_scan_line = 60
    1              0.000001 endif
    1              0.000001 if g:tex_indent_items
    1              0.000002     if !exists("g:tex_itemize_env")
    1              0.000003         let g:tex_itemize_env = 'itemize\|description\|enumerate\|thebibliography'
    1              0.000001     endif
    1              0.000002     if !exists('g:tex_items')
    1              0.000002         let g:tex_items = '\\bibitem\|\\item'
    1              0.000001     endif
                            else
                                let g:tex_items = ''
    1              0.000001 endif
                            
    1              0.000002 if !exists("g:tex_noindent_env")
    1              0.000002     let g:tex_noindent_env = 'document\|verbatim\|lstlisting'
    1              0.000001 endif "}}}
                            
                            " VIM Setting " {{{
    1              0.000004 setlocal autoindent
    1              0.000002 setlocal nosmartindent
    1              0.000003 setlocal indentexpr=GetTeXIndent()
    1              0.000002 setlocal indentkeys&
    1              0.000016 exec 'setlocal indentkeys+=[,(,{,),},],\&' . substitute(g:tex_items, '^\|\(\\|\)', ',=', 'g')
    1              0.000007 let g:tex_items = '^\s*' . substitute(g:tex_items, '^\(\^\\s\*\)*', '', '')
                            " }}}
                            
    1              0.000002 function! GetTeXIndent() " {{{
                                " Find a non-blank line above the current line.
                                let lnum = prevnonblank(v:lnum - 1)
                                let cnum = v:lnum
                            
                                " Comment line is not what we need.
                                while lnum != 0 && getline(lnum) =~ '^\s*%'
                                    let lnum = prevnonblank(lnum - 1)
                                endwhile
                            
                                " At the start of the file use zero indent.
                                if lnum == 0
                                    return 0
                                endif
                            
                                let line = substitute(getline(lnum), '\s*%.*', '','g')     " last line
                                let cline = substitute(getline(v:lnum), '\s*%.*', '', 'g') " current line
                            
                                let ccol = 1
                                while cline[ccol] =~ '\s'
                                    let ccol += 1
                                endwhile
                            
                                "  We are in verbatim, so do what our user what.
                                if synIDattr(synID(v:lnum, ccol, 1), "name") == "texZone"
                                    if empty(cline)
                                        return indent(lnum)
                                    else
                                        return indent(v:lnum)
                                    endif
                                endif
                            
                                if lnum == 0
                                    return 0
                                endif
                            
                                let ind = indent(lnum)
                                let stay = 1
                            
                                " New code for comment: retain the indent of current line
                                if cline =~ '^\s*%'
                                    return indent(v:lnum)
                                endif
                            
                                " Add a 'shiftwidth' after beginning of environments.
                                " Don't add it for \begin{document} and \begin{verbatim}
                                " if line =~ '^\s*\\begin{\(.*\)}'  && line !~ 'verbatim'
                                " LH modification : \begin does not always start a line
                                " ZYC modification : \end after \begin won't cause wrong indent anymore
                                if line =~ '\\begin{.*}' 
                                    if line !~ g:tex_noindent_env
                                        let ind = ind + shiftwidth()
                                        let stay = 0
                                    endif
                            
                                    if g:tex_indent_items
                                        " Add another sw for item-environments
                                        if line =~ g:tex_itemize_env
                                            let ind = ind + shiftwidth()
                                            let stay = 0
                                        endif
                                    endif
                                endif
                            
                                if cline =~ '\\end{.*}'
                                    let retn = s:GetEndIndentation(v:lnum)
                                    if retn != -1
                                        return retn
                                    endif
                                end
                                " Subtract a 'shiftwidth' when an environment ends
                                if cline =~ '\\end{.*}'
                                            \ && cline !~ g:tex_noindent_env
                                            \ && cline !~ '\\begin{.*}.*\\end{.*}'
                                    if g:tex_indent_items
                                        " Remove another sw for item-environments
                                        if cline =~ g:tex_itemize_env
                                            let ind = ind - shiftwidth()
                                            let stay = 0
                                        endif
                                    endif
                            
                                    let ind = ind - shiftwidth()
                                    let stay = 0
                                endif
                            
                                if g:tex_indent_brace
                                    if line =~ '[[{]$'
                                        let ind += shiftwidth()
                                        let stay = 0
                                    endif
                            
                                    if cline =~ '^\s*\\\?[\]}]' && s:CheckPairedIsLastCharacter(v:lnum, ccol)
                                        let ind -= shiftwidth()
                                        let stay = 0
                                    endif
                            
                                    if line !~ '^\s*\\\?[\]}]'
                                        for i in range(1, strlen(line)-1)
                                            let char = line[i]
                                            if char == ']' || char == '}'
                                                if s:CheckPairedIsLastCharacter(lnum, i)
                                                    let ind -= shiftwidth()
                                                    let stay = 0
                                                endif
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                " Special treatment for 'item'
                                " ----------------------------
                            
                                if g:tex_indent_items
                                    " '\item' or '\bibitem' itself:
                                    if cline =~ g:tex_items
                                        let ind = ind - shiftwidth()
                                        let stay = 0
                                    endif
                                    " lines following to '\item' are indented once again:
                                    if line =~ g:tex_items
                                        let ind = ind + shiftwidth()
                                        let stay = 0
                                    endif
                                endif
                            
                                if stay && mode() == 'i'
                                    " If there is no obvious indentation hint, and indentation is triggered
                                    " in insert mode, we trust our user.
                                    if empty(cline)
                                        return ind
                                    else
                                        return max([indent(v:lnum), s:GetLastBeginIndentation(v:lnum)])
                                    endif
                                else
                                    return ind
                                endif
                            endfunction "}}}
                            
    1              0.000003 function! s:GetLastBeginIndentation(lnum) " {{{
                                let matchend = 1
                                for lnum in range(a:lnum-1, max([a:lnum - g:tex_max_scan_line, 1]), -1)
                                    let line = getline(lnum)
                                    if line =~ '\\end{.*}'
                                        let matchend += 1
                                    endif
                                    if line =~ '\\begin{.*}'
                                        let matchend -= 1
                                    endif
                                    if matchend == 0
                                        if line =~ g:tex_noindent_env
                                            return indent(lnum)
                                        endif
                                        if line =~ g:tex_itemize_env
                                            return indent(lnum) + 2 * shiftwidth()
                                        endif
                                        return indent(lnum) + shiftwidth()
                                    endif
                                endfor
                                return -1
                            endfunction
                            
    1              0.000002 function! s:GetEndIndentation(lnum) " {{{
                                if getline(a:lnum) =~ '\\begin{.*}.*\\end{.*}'
                                    return -1
                                endif
                            
                                let min_indent = 100
                                let matchend = 1
                                for lnum in range(a:lnum-1, max([a:lnum-g:tex_max_scan_line, 1]), -1)
                                    let line = getline(lnum)
                                    if line =~ '\\end{.*}'
                                        let matchend += 1
                                    endif
                                    if line =~ '\\begin{.*}'
                                        let matchend -= 1
                                    endif
                                    if matchend == 0
                                        return indent(lnum)
                                    endif
                                    if !empty(line)
                                        let min_indent = min([min_indent, indent(lnum)])
                                    endif
                                endfor
                                return min_indent - shiftwidth()
                            endfunction
                            
                            " Most of the code is from matchparen.vim
    1              0.000002 function! s:CheckPairedIsLastCharacter(lnum, col) "{{{
                                let c_lnum = a:lnum
                                let c_col = a:col+1
                            
                                let line = getline(c_lnum)
                                if line[c_col-1] == '\'
                                    let c_col = c_col + 1
                                endif
                                let c = line[c_col-1]
                            
                                let plist = split(&matchpairs, '.\zs[:,]')
                                let i = index(plist, c)
                                if i < 0
                                    return 0
                                endif
                            
                                " Figure out the arguments for searchpairpos().
                                if i % 2 == 0
                                    let s_flags = 'nW'
                                    let c2 = plist[i + 1]
                                else
                                    let s_flags = 'nbW'
                                    let c2 = c
                                    let c = plist[i - 1]
                                endif
                                if c == '['
                                    let c = '\['
                                    let c2 = '\]'
                                endif
                            
                                " Find the match.  When it was just before the cursor move it there for a
                                " moment.
                                let save_cursor = winsaveview()
                                call cursor(c_lnum, c_col)
                            
                                " When not in a string or comment ignore matches inside them.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' .
                                            \ '=~?  "string\\|character\\|singlequote\\|escape\\|comment"'
                                execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                                let stopline = max([0, c_lnum - g:tex_max_scan_line])
                            
                                " Limit the search time to 300 msec to avoid a hang on very long lines.
                                " This fails when a timeout is not supported.
                                try
                                    let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, 100)
                                catch /E118/
                                endtry
                            
                                call winrestview(save_cursor)
                            
                                if m_lnum > 0
                                    let line = getline(m_lnum)
                                    return strlen(line) == m_col
                                endif
                            
                                return 0
                            endfunction "}}}
                            
    1              0.000008 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim: set sw=4 textwidth=80:

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/plugin/vimtex.vim
Sourced 1 time
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000008 if !get(g:, 'vimtex_enabled', 1) | finish | endif
    1              0.000004 if exists('g:loaded_vimtex') | finish | endif
    1              0.000002 let g:loaded_vimtex = 1
                            
                            
    1              0.000016 command! -nargs=* VimtexInverseSearch
                                  \ call call('vimtex#view#inverse_search_cmd', s:parse_args(<q-args>))
                            
                            
    1              0.000003 function! s:parse_args(args) abort
                              let l:line = matchstr(a:args, '^\s*\zs\d\+')
                              if empty(l:line) | return [-1, ''] | endif
                            
                              let l:file = matchstr(a:args, '^\s*\d\+\s*\zs.*')
                              let l:file = substitute(l:file, '\v^([''"])(.*)\1\s*', '\2', '')
                              if empty(l:file) | return [-1, ''] | endif
                            
                              return [str2nr(l:line), l:file]
                            endfunction

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/ftplugin/tex.vim
Sourced 1 time
Total time:   0.038748
 Self time:   0.000095

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000004 if !get(g:, 'vimtex_enabled', 1)
                              finish
    1              0.000001 endif
                            
    1              0.000002 if exists('b:did_ftplugin')
                              finish
    1              0.000001 endif
    1              0.000002 let b:did_ftplugin = 1
                            
    1              0.000009 if !(!get(g:, 'vimtex_version_check', 1)
                                  \ || has('nvim-0.4.3')
                                  \ || has('patch-8.0.1453'))
                              echoerr 'Error: VimTeX does not support your version of Vim'
                              echom 'Please update to Vim 8.0.1453 or neovim 0.4.3 or later!'
                              echom 'For more info, please see :h vimtex_version_check'
                              finish
    1              0.000001 endif
                            
    1   0.038700   0.000047 call vimtex#init()
                            
                            " Check if user has tree-sitter enabled and give a warning if that is the case.
                            " This is useful, since a lot of users are not aware of the clash between
                            " VimTeX's syntax highlighting and Tree-sitters syntax highlighting.
    1              0.000007 if has('nvim-0.5')
                                  \ && g:vimtex_syntax_enabled
                                  \ && !g:vimtex_syntax_conceal_disable
    1              0.000004   call timer_start(1000, 'vimtex#nvim#check_treesitter')
    1              0.000002 endif

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex.vim
Sourced 1 time
Total time:   0.000633
 Self time:   0.000567

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#init() abort " {{{1
                              if exists('#User#VimtexEventInitPre')
                                doautocmd <nomodeline> User VimtexEventInitPre
                              endif
                            
                              call vimtex#options#init()
                            
                              call s:init_state()
                              call s:init_buffer()
                              call s:init_default_mappings()
                            
                              if exists('#User#VimtexEventInitPost')
                                doautocmd <nomodeline> User VimtexEventInitPost
                              endif
                            
                              augroup vimtex_main
                                autocmd!
                                autocmd VimLeave * call s:quit()
                              augroup END
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:init_state() abort " {{{1
                              call vimtex#state#init()
                              call vimtex#state#init_local()
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! s:init_buffer() abort " {{{1
                              try
                                let l:disabled_modules = s:init_buffer_{&filetype}()
                              catch /E117/
                                let l:disabled_modules = []
                              endtry
                            
                              " Define autocommands
                              augroup vimtex_buffers
                                autocmd! * <buffer>
                                autocmd BufFilePre  <buffer> call s:filename_changed_pre()
                                autocmd BufFilePost <buffer> call s:filename_changed_post()
                                autocmd BufUnload   <buffer> call s:buffer_deleted('unload')
                                autocmd BufWipeout  <buffer> call s:buffer_deleted('wipe')
                              augroup END
                            
                              " Initialize buffer settings for sub modules
                              call extend(l:disabled_modules, get(b:vimtex, 'disabled_modules', []))
                              for l:mod in filter(copy(s:modules),
                                    \ 'index(l:disabled_modules, v:val) < 0')
                                try
                                  call vimtex#{l:mod}#init_buffer()
                                catch /E117.*#init_/
                                catch /E127.*vimtex#profile#/
                                endtry
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:init_buffer_tex() abort " {{{1
                              setlocal comments=sO:%\ -,mO:%\ \ ,eO:%%,:%
                              setlocal commentstring=\%\ %s
                            
                              for l:suf in [
                                    \ '.sty',
                                    \ '.cls',
                                    \ '.log',
                                    \ '.aux',
                                    \ '.bbl',
                                    \ '.out',
                                    \ '.blg',
                                    \ '.brf',
                                    \ '.cb',
                                    \ '.dvi',
                                    \ '.fdb_latexmk',
                                    \ '.fls',
                                    \ '.idx',
                                    \ '.ilg',
                                    \ '.ind',
                                    \ '.inx',
                                    \ '.pdf',
                                    \ '.synctex.gz',
                                    \ '.toc',
                                    \ ]
                                execute 'set suffixes+=' . l:suf
                              endfor
                              setlocal suffixesadd=.tex,.sty,.cls
                              setlocal iskeyword+=:
                              setlocal includeexpr=vimtex#include#expr()
                            
                              let &l:include = g:vimtex#re#tex_include
                              let &l:define  = '\v\\%('
                                    \ . '([egx]|mathchar|count|dimen|muskip|skip|toks)?def'
                                    \ . '|font'
                                    \ . '|(future)?let'
                                    \ . '|new(count|dimen|skip|muskip|box|toks|read|write|fam|insert)'
                                    \ . '|(re)?new(boolean|command|counter|environment'
                                    \ .   '|font|if|length|savebox|theorem(style)?)'
                                    \ . '|DeclareMathOperator'
                                    \ . '|bibitem%(\[[^]]*\])?'
                                    \ . ')'
                            
                              " Specify list of modules to disable
                              return []
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:init_buffer_bib() abort " {{{1
                              setlocal comments=sO:%\ -,mO:%\ \ ,eO:%%,:%
                              setlocal commentstring=\%\ %s
                            
                              for l:suf in [
                                    \ '.sty',
                                    \ '.cls',
                                    \ '.log',
                                    \ '.aux',
                                    \ '.bbl',
                                    \ '.out',
                                    \ '.blg',
                                    \ '.brf',
                                    \ '.cb',
                                    \ '.dvi',
                                    \ '.fdb_latexmk',
                                    \ '.fls',
                                    \ '.idx',
                                    \ '.ilg',
                                    \ '.ind',
                                    \ '.inx',
                                    \ '.pdf',
                                    \ '.synctex.gz',
                                    \ '.toc',
                                    \ ]
                                execute 'set suffixes+=' . l:suf
                              endfor
                              setlocal suffixesadd=.tex,.bib
                            
                              if g:vimtex_fold_bib_enabled
                                call vimtex#fold#bib#init()
                              endif
                            
                              " Specify list of modules to disable
                              return [
                                    \ 'fold', 'matchparen', 'format', 'doc', 'imaps', 'delim',
                                    \ 'env', 'motion', 'complete',
                                    \]
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:init_default_mappings() abort " {{{1
                              if !g:vimtex_mappings_enabled | return | endif
                            
                              call s:map_prefixed(0, 'n', 'i', '<plug>(vimtex-info)')
                              call s:map_prefixed(0, 'n', 'I', '<plug>(vimtex-info-full)')
                              call s:map_prefixed(0, 'n', 'x', '<plug>(vimtex-reload)')
                              call s:map_prefixed(0, 'n', 'X', '<plug>(vimtex-reload-state)')
                              call s:map_prefixed(1, 'n', 's', '<plug>(vimtex-toggle-main)')
                              call s:map_prefixed(0, 'n', 'q', '<plug>(vimtex-log)')
                              call s:map_prefixed(1, 'n', 'a', '<plug>(vimtex-context-menu)')
                            
                              call s:map(0, 'n', 'ds$', '<plug>(vimtex-env-delete-math)')
                              call s:map(0, 'n', 'cs$', '<plug>(vimtex-env-change-math)')
                              call s:map(0, 'n', 'dse', '<plug>(vimtex-env-delete)')
                              call s:map(0, 'n', 'cse', '<plug>(vimtex-env-change)')
                              call s:map(0, 'n', 'tse', '<plug>(vimtex-env-toggle-star)')
                              call s:map(0, 'n', 'ts$', '<plug>(vimtex-env-toggle-math)')
                              call s:map(0, 'n', '<F6>', '<plug>(vimtex-env-surround-line)')
                              call s:map(0, 'x', '<F6>', '<plug>(vimtex-env-surround-visual)')
                            
                              call s:map(0, 'n', 'dsc',  '<plug>(vimtex-cmd-delete)')
                              call s:map(0, 'n', 'csc',  '<plug>(vimtex-cmd-change)')
                              call s:map(0, 'n', 'tsc',  '<plug>(vimtex-cmd-toggle-star)')
                              call s:map(0, 'n', 'tsf',  '<plug>(vimtex-cmd-toggle-frac)')
                              call s:map(0, 'x', 'tsf',  '<plug>(vimtex-cmd-toggle-frac)')
                              call s:map(0, 'i', '<F7>', '<plug>(vimtex-cmd-create)')
                              call s:map(0, 'n', '<F7>', '<plug>(vimtex-cmd-create)')
                              call s:map(0, 'x', '<F7>', '<plug>(vimtex-cmd-create)')
                            
                              call s:map(0, 'n', 'dsd', '<plug>(vimtex-delim-delete)')
                              call s:map(0, 'n', 'csd', '<plug>(vimtex-delim-change-math)')
                              call s:map(0, 'n', 'tsd', '<plug>(vimtex-delim-toggle-modifier)')
                              call s:map(0, 'x', 'tsd', '<plug>(vimtex-delim-toggle-modifier)')
                              call s:map(0, 'n', 'tsD', '<plug>(vimtex-delim-toggle-modifier-reverse)')
                              call s:map(0, 'x', 'tsD', '<plug>(vimtex-delim-toggle-modifier-reverse)')
                              call s:map(0, 'i', ']]',  '<plug>(vimtex-delim-close)')
                              call s:map(0, 'n', '<F8>', '<plug>(vimtex-delim-add-modifiers)')
                            
                              if g:vimtex_compiler_enabled
                                call s:map_prefixed(0, 'n', 'l', '<plug>(vimtex-compile)')
                                call s:map_prefixed(0, 'n', 'o', '<plug>(vimtex-compile-output)')
                                call s:map_prefixed(1, 'n', 'L', '<plug>(vimtex-compile-selected)')
                                call s:map_prefixed(1, 'x', 'L', '<plug>(vimtex-compile-selected)')
                                call s:map_prefixed(0, 'n', 'k', '<plug>(vimtex-stop)')
                                call s:map_prefixed(0, 'n', 'K', '<plug>(vimtex-stop-all)')
                                call s:map_prefixed(0, 'n', 'e', '<plug>(vimtex-errors)')
                                call s:map_prefixed(0, 'n', 'c', '<plug>(vimtex-clean)')
                                call s:map_prefixed(0, 'n', 'C', '<plug>(vimtex-clean-full)')
                                call s:map_prefixed(0, 'n', 'g', '<plug>(vimtex-status)')
                                call s:map_prefixed(0, 'n', 'G', '<plug>(vimtex-status-all)')
                              endif
                            
                              if g:vimtex_motion_enabled
                                " These are forced in order to overwrite matchit mappings
                                call s:map(1, 'n', '%', '<plug>(vimtex-%)', 1)
                                call s:map(1, 'x', '%', '<plug>(vimtex-%)', 1)
                                call s:map(1, 'o', '%', '<plug>(vimtex-%)', 1)
                            
                                call s:map(1, 'n', ']]', '<plug>(vimtex-]])')
                                call s:map(1, 'n', '][', '<plug>(vimtex-][)')
                                call s:map(1, 'n', '[]', '<plug>(vimtex-[])')
                                call s:map(1, 'n', '[[', '<plug>(vimtex-[[)')
                                call s:map(1, 'x', ']]', '<plug>(vimtex-]])')
                                call s:map(1, 'x', '][', '<plug>(vimtex-][)')
                                call s:map(1, 'x', '[]', '<plug>(vimtex-[])')
                                call s:map(1, 'x', '[[', '<plug>(vimtex-[[)')
                                call s:map(1, 'o', ']]', '<plug>(vimtex-]])')
                                call s:map(1, 'o', '][', '<plug>(vimtex-][)')
                                call s:map(1, 'o', '[]', '<plug>(vimtex-[])')
                                call s:map(1, 'o', '[[', '<plug>(vimtex-[[)')
                            
                                call s:map(1, 'n', ']M', '<plug>(vimtex-]M)')
                                call s:map(1, 'n', ']m', '<plug>(vimtex-]m)')
                                call s:map(1, 'n', '[M', '<plug>(vimtex-[M)')
                                call s:map(1, 'n', '[m', '<plug>(vimtex-[m)')
                                call s:map(1, 'x', ']M', '<plug>(vimtex-]M)')
                                call s:map(1, 'x', ']m', '<plug>(vimtex-]m)')
                                call s:map(1, 'x', '[M', '<plug>(vimtex-[M)')
                                call s:map(1, 'x', '[m', '<plug>(vimtex-[m)')
                                call s:map(1, 'o', ']M', '<plug>(vimtex-]M)')
                                call s:map(1, 'o', ']m', '<plug>(vimtex-]m)')
                                call s:map(1, 'o', '[M', '<plug>(vimtex-[M)')
                                call s:map(1, 'o', '[m', '<plug>(vimtex-[m)')
                            
                                call s:map(1, 'n', ']N', '<plug>(vimtex-]N)')
                                call s:map(1, 'n', ']n', '<plug>(vimtex-]n)')
                                call s:map(1, 'n', '[N', '<plug>(vimtex-[N)')
                                call s:map(1, 'n', '[n', '<plug>(vimtex-[n)')
                                call s:map(1, 'x', ']N', '<plug>(vimtex-]N)')
                                call s:map(1, 'x', ']n', '<plug>(vimtex-]n)')
                                call s:map(1, 'x', '[N', '<plug>(vimtex-[N)')
                                call s:map(1, 'x', '[n', '<plug>(vimtex-[n)')
                                call s:map(1, 'o', ']N', '<plug>(vimtex-]N)')
                                call s:map(1, 'o', ']n', '<plug>(vimtex-]n)')
                                call s:map(1, 'o', '[N', '<plug>(vimtex-[N)')
                                call s:map(1, 'o', '[n', '<plug>(vimtex-[n)')
                            
                                call s:map(1, 'n', ']R', '<plug>(vimtex-]R)')
                                call s:map(1, 'n', ']r', '<plug>(vimtex-]r)')
                                call s:map(1, 'n', '[R', '<plug>(vimtex-[R)')
                                call s:map(1, 'n', '[r', '<plug>(vimtex-[r)')
                                call s:map(1, 'x', ']R', '<plug>(vimtex-]R)')
                                call s:map(1, 'x', ']r', '<plug>(vimtex-]r)')
                                call s:map(1, 'x', '[R', '<plug>(vimtex-[R)')
                                call s:map(1, 'x', '[r', '<plug>(vimtex-[r)')
                                call s:map(1, 'o', ']R', '<plug>(vimtex-]R)')
                                call s:map(1, 'o', ']r', '<plug>(vimtex-]r)')
                                call s:map(1, 'o', '[R', '<plug>(vimtex-[R)')
                                call s:map(1, 'o', '[r', '<plug>(vimtex-[r)')
                            
                                call s:map(1, 'n', ']/', '<plug>(vimtex-]/)')
                                call s:map(1, 'n', ']*', '<plug>(vimtex-]*)')
                                call s:map(1, 'n', '[/', '<plug>(vimtex-[/)')
                                call s:map(1, 'n', '[*', '<plug>(vimtex-[*)')
                                call s:map(1, 'x', ']/', '<plug>(vimtex-]/)')
                                call s:map(1, 'x', ']*', '<plug>(vimtex-]*)')
                                call s:map(1, 'x', '[/', '<plug>(vimtex-[/)')
                                call s:map(1, 'x', '[*', '<plug>(vimtex-[*)')
                                call s:map(1, 'o', ']/', '<plug>(vimtex-]/)')
                                call s:map(1, 'o', ']*', '<plug>(vimtex-]*)')
                                call s:map(1, 'o', '[/', '<plug>(vimtex-[/)')
                                call s:map(1, 'o', '[*', '<plug>(vimtex-[*)')
                              endif
                            
                              if g:vimtex_text_obj_enabled
                                call s:map(0, 'x', 'id', '<plug>(vimtex-id)')
                                call s:map(0, 'x', 'ad', '<plug>(vimtex-ad)')
                                call s:map(0, 'o', 'id', '<plug>(vimtex-id)')
                                call s:map(0, 'o', 'ad', '<plug>(vimtex-ad)')
                                call s:map(0, 'x', 'i$', '<plug>(vimtex-i$)')
                                call s:map(0, 'x', 'a$', '<plug>(vimtex-a$)')
                                call s:map(0, 'o', 'i$', '<plug>(vimtex-i$)')
                                call s:map(0, 'o', 'a$', '<plug>(vimtex-a$)')
                                call s:map(1, 'x', 'iP', '<plug>(vimtex-iP)')
                                call s:map(1, 'x', 'aP', '<plug>(vimtex-aP)')
                                call s:map(1, 'o', 'iP', '<plug>(vimtex-iP)')
                                call s:map(1, 'o', 'aP', '<plug>(vimtex-aP)')
                                call s:map(1, 'x', 'im', '<plug>(vimtex-im)')
                                call s:map(1, 'x', 'am', '<plug>(vimtex-am)')
                                call s:map(1, 'o', 'im', '<plug>(vimtex-im)')
                                call s:map(1, 'o', 'am', '<plug>(vimtex-am)')
                            
                                if vimtex#text_obj#targets#enabled()
                                  call vimtex#text_obj#targets#init()
                            
                                  " These are handled explicitly to avoid conflict with gitgutter
                                  call s:map(0, 'x', 'ic', '<plug>(vimtex-targets-i)c')
                                  call s:map(0, 'x', 'ac', '<plug>(vimtex-targets-a)c')
                                  call s:map(0, 'o', 'ic', '<plug>(vimtex-targets-i)c')
                                  call s:map(0, 'o', 'ac', '<plug>(vimtex-targets-a)c')
                                else
                                  if g:vimtex_text_obj_variant ==# 'targets'
                                    call vimtex#log#warning(
                                          \ "Ignoring g:vimtex_text_obj_variant = 'targets'"
                                          \ . " because 'g:loaded_targets' does not exist or is 0.")
                                  endif
                                  let g:vimtex_text_obj_variant = 'vimtex'
                            
                                  call s:map(0, 'x', 'ie', '<plug>(vimtex-ie)')
                                  call s:map(0, 'x', 'ae', '<plug>(vimtex-ae)')
                                  call s:map(0, 'o', 'ie', '<plug>(vimtex-ie)')
                                  call s:map(0, 'o', 'ae', '<plug>(vimtex-ae)')
                                  call s:map(0, 'x', 'ic', '<plug>(vimtex-ic)')
                                  call s:map(0, 'x', 'ac', '<plug>(vimtex-ac)')
                                  call s:map(0, 'o', 'ic', '<plug>(vimtex-ic)')
                                  call s:map(0, 'o', 'ac', '<plug>(vimtex-ac)')
                                endif
                              endif
                            
                              if g:vimtex_toc_enabled
                                call s:map_prefixed(0, 'n', 't', '<plug>(vimtex-toc-open)')
                                call s:map_prefixed(0, 'n', 'T', '<plug>(vimtex-toc-toggle)')
                              endif
                            
                              if has_key(b:vimtex, 'viewer')
                                call s:map_prefixed(0, 'n', 'v', '<plug>(vimtex-view)')
                                if !empty(maparg('<plug>(vimtex-reverse-search)', 'n'))
                                  call s:map_prefixed(1, 'n', 'r', '<plug>(vimtex-reverse-search)')
                                endif
                              endif
                            
                              if g:vimtex_imaps_enabled
                                call s:map_prefixed(0, 'n', 'm', '<plug>(vimtex-imaps-list)')
                              endif
                            
                              if g:vimtex_doc_enabled
                                call s:map(1, 'n', 'K', '<plug>(vimtex-doc-package)')
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:filename_changed_pre() abort " {{{1
                              let s:filename_changed = expand('%:p') ==# b:vimtex.tex
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:filename_changed_post() abort " {{{1
                              if s:filename_changed
                                let l:old = b:vimtex.tex
                                let b:vimtex.tex = expand('%:p')
                                let b:vimtex.root = fnamemodify(b:vimtex.tex, ':h')
                                let b:vimtex.base = fnamemodify(b:vimtex.tex, ':t')
                                let b:vimtex.name = fnamemodify(b:vimtex.tex, ':t:r')
                            
                                call vimtex#log#warning('Filename change detected')
                                call vimtex#log#info('Old: ' . l:old)
                                call vimtex#log#info('New: ' . b:vimtex.tex)
                            
                                if has_key(b:vimtex, 'compiler')
                                  if b:vimtex.compiler.is_running()
                                    call vimtex#log#warning('Compilation stopped!')
                                    call vimtex#compiler#stop()
                                  endif
                                endif
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:buffer_deleted(reason) abort " {{{1
                              "
                              " We need a simple cache of buffer ids because a buffer unload might clear
                              " buffer variables, so that a subsequent buffer wipe will not trigger a full
                              " cleanup. By caching the buffer id, we should avoid this issue.
                              "
                              let s:buffer_cache = get(s:, 'buffer_cache', {})
                              let l:file = expand('<afile>')
                            
                              if !has_key(s:buffer_cache, l:file)
                                let s:buffer_cache[l:file] = getbufvar(l:file, 'vimtex_id', -1)
                              endif
                            
                              if a:reason ==# 'wipe'
                                call vimtex#state#cleanup(s:buffer_cache[l:file])
                                call remove(s:buffer_cache, l:file)
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:quit() abort " {{{1
                              for l:state in vimtex#state#list_all()
                                call l:state.cleanup()
                              endfor
                            
                              call vimtex#cache#write_all()
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 function! s:map_prefixed(ftype, mode, lhs, rhs) abort " {{{1
                              let l:lhs = g:vimtex_mappings_prefix . a:lhs
                              call s:map(a:ftype, a:mode, l:lhs, a:rhs)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:map(ftype, mode, lhs, rhs, ...) abort " {{{1
                              if (a:ftype == 0
                                    \     || a:ftype == 1 && &filetype ==# 'tex'
                                    \     || a:ftype == 2 && &filetype ==# 'bib')
                                    \ && !hasmapto(a:rhs, a:mode)
                                    \ && index(get(g:vimtex_mappings_disable, a:mode, []), a:lhs) < 0
                                    \ && (a:0 > 0
                                    \     || g:vimtex_mappings_override_existing
                                    \     || empty(maparg(a:lhs, a:mode)))
                                silent execute a:mode . 'map <silent><buffer><nowait>' a:lhs a:rhs
                              endif
                            endfunction
                            
                            " }}}1
                            
                            " {{{1 Initialize module
                            
    1   0.000395   0.000329 let s:modules = map(
                                  \ glob(expand('<sfile>:r') . '/*.vim', 0, 1),
                                  \ { _, x -> fnamemodify(x, ':t:r') })
    1              0.000007 call remove(s:modules, index(s:modules, 'test'))
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/options.vim
Sourced 1 time
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#options#init() abort " {{{1
                              if s:initialized | return | endif
                            
                              call s:init_highlights()
                              call s:check_for_deprecated_options()
                            
                              call s:init_option('vimtex_bibliography_commands', [
                                    \ '%(no)?bibliography',
                                    \ 'add%(bibresource|globalbib|sectionbib)',
                                    \])
                            
                              call s:init_option('vimtex_compiler_enabled', 1)
                              call s:init_option('vimtex_compiler_silent', 0)
                              call s:init_option('vimtex_compiler_method', 'latexmk')
                              call s:init_option('vimtex_compiler_clean_paths', [])
                              call s:init_option('vimtex_compiler_latexmk_engines', {
                                    \  '_'                : '-pdf',
                                    \  'pdfdvi'           : '-pdfdvi',
                                    \  'pdfps'            : '-pdfps',
                                    \  'pdflatex'         : '-pdf',
                                    \  'luatex'           : '-lualatex',
                                    \  'lualatex'         : '-lualatex',
                                    \  'xelatex'          : '-xelatex',
                                    \  'context (pdftex)' : '-pdf -pdflatex=texexec',
                                    \  'context (luatex)' : '-pdf -pdflatex=context',
                                    \  'context (xetex)'  : '-pdf -pdflatex=''texexec --xtx''',
                                    \ })
                              call s:init_option('vimtex_compiler_latexrun_engines', {
                                    \ '_'        : 'pdflatex',
                                    \ 'pdflatex' : 'pdflatex',
                                    \ 'lualatex' : 'lualatex',
                                    \ 'xelatex'  : 'xelatex',
                                    \})
                            
                              call s:init_option('vimtex_complete_enabled', 1)
                              call s:init_option('vimtex_complete_close_braces', 0)
                              call s:init_option('vimtex_complete_ignore_case', &ignorecase)
                              call s:init_option('vimtex_complete_smart_case', &smartcase)
                              call s:init_option('vimtex_complete_bib', {
                                    \ 'simple': 0,
                                    \ 'match_str_fmt': '@key [@type] @author_all (@year), "@title"',
                                    \ 'menu_fmt': '[@type] @author_short (@year), "@title"',
                                    \ 'info_fmt': "TITLE: @title\nAUTHOR: @author_all\nYEAR: @year",
                                    \ 'abbr_fmt': '',
                                    \ 'auth_len': 20,
                                    \ 'custom_patterns': [],
                                    \})
                              call s:init_option('vimtex_complete_ref', {
                                    \ 'custom_patterns': [],
                                    \})
                            
                              let l:viewer = get(g:, 'vimtex_view_method', 'general')
                              if l:viewer ==# 'general'
                                let l:viewer = 'NONE'
                              endif
                              call s:init_option('vimtex_context_pdf_viewer', l:viewer)
                            
                              call s:init_option('vimtex_delim_timeout', 300)
                              call s:init_option('vimtex_delim_insert_timeout', 60)
                              call s:init_option('vimtex_delim_stopline', 500)
                            
                              call s:init_option('vimtex_include_search_enabled', 1)
                            
                              call s:init_option('vimtex_doc_enabled', 1)
                              call s:init_option('vimtex_doc_confirm_single', v:true)
                              call s:init_option('vimtex_doc_handlers', [])
                            
                              call s:init_option('vimtex_echo_verbose_input', 1)
                            
                              call s:init_option('vimtex_env_change_autofill', 0)
                              call s:init_option('vimtex_env_toggle_math_map', {
                                    \ '$': '\[',
                                    \ '\[': 'equation',
                                    \ '$$': '\[',
                                    \ '\(': '$',
                                    \})
                            
                              if &diff
                                let g:vimtex_fold_enabled = 0
                                let g:vimtex_fold_bib_enabled = 0
                              else
                                call s:init_option('vimtex_fold_enabled', 0)
                                call s:init_option('vimtex_fold_bib_enabled', g:vimtex_fold_enabled)
                              endif
                              call s:init_option('vimtex_fold_bib_max_key_width', 0)
                              call s:init_option('vimtex_fold_manual', 0)
                              call s:init_option('vimtex_fold_levelmarker', '*')
                              call s:init_option('vimtex_fold_types', {})
                              call s:init_option('vimtex_fold_types_defaults', {
                                    \ 'preamble' : {},
                                    \ 'items' : {},
                                    \ 'comments' : { 'enabled' : 0 },
                                    \ 'envs' : {
                                    \   'blacklist' : [],
                                    \   'whitelist' : [],
                                    \ },
                                    \ 'env_options' : {},
                                    \ 'markers' : {},
                                    \ 'sections' : {
                                    \   'parse_levels' : 0,
                                    \   'sections' : [
                                    \     '%(add)?part',
                                    \     '%(chapter|addchap)',
                                    \     '%(section|addsec)',
                                    \     'subsection',
                                    \     'subsubsection',
                                    \   ],
                                    \   'parts' : [
                                    \     'appendix',
                                    \     'frontmatter',
                                    \     'mainmatter',
                                    \     'backmatter',
                                    \   ],
                                    \ },
                                    \ 'cmd_single' : {
                                    \   'cmds' : [
                                    \     'hypersetup',
                                    \     'tikzset',
                                    \     'pgfplotstableread',
                                    \     'lstset',
                                    \   ],
                                    \ },
                                    \ 'cmd_single_opt' : {
                                    \   'cmds' : [
                                    \     'usepackage',
                                    \     'includepdf',
                                    \   ],
                                    \ },
                                    \ 'cmd_multi' : {
                                    \   'cmds' : [
                                    \     '%(re)?new%(command|environment)',
                                    \     'providecommand',
                                    \     'presetkeys',
                                    \     'Declare%(Multi|Auto)?CiteCommand',
                                    \     'Declare%(Index)?%(Field|List|Name)%(Format|Alias)',
                                    \   ],
                                    \ },
                                    \ 'cmd_addplot' : {
                                    \   'cmds' : [
                                    \     'addplot[+3]?',
                                    \   ],
                                    \ },
                                    \})
                            
                              call s:init_option('vimtex_format_enabled', 0)
                              call s:init_option('vimtex_format_border_begin', '\v^\s*%(' . join([
                                    \ '\\item',
                                    \ '\\begin',
                                    \ '\\end',
                                    \ '%(\\\[|\$\$)\s*$',
                                    \], '|') . ')')
                              call s:init_option('vimtex_format_border_end', '\v\\%(' . join([
                                    \ '\\\*?',
                                    \ 'clear%(double)?page',
                                    \ 'linebreak',
                                    \ 'new%(line|page)',
                                    \ 'pagebreak',
                                    \ '%(begin|end)\{[^}]*\}',
                                    \], '|') . ')\s*$' . '|^\s*%(\\\]|\$\$)\s*$')
                            
                              call s:init_option('vimtex_grammar_textidote', {
                                    \ 'jar': '',
                                    \ 'args': '',
                                    \})
                              call s:init_option('vimtex_grammar_vlty', {
                                    \ 'lt_directory': '~/lib/LanguageTool',
                                    \ 'lt_command': '',
                                    \ 'lt_disable': 'WHITESPACE_RULE',
                                    \ 'lt_enable': '',
                                    \ 'lt_disablecategories': '',
                                    \ 'lt_enablecategories': '',
                                    \ 'server': 'no',
                                    \ 'shell_options': '',
                                    \ 'show_suggestions': 0,
                                    \ 'encoding': 'auto',
                                    \})
                            
                              call s:init_option('vimtex_imaps_enabled', 1)
                              call s:init_option('vimtex_imaps_disabled', [])
                              call s:init_option('vimtex_imaps_leader', '`')
                              call s:init_option('vimtex_imaps_list', [
                                    \ { 'lhs' : '0',  'rhs' : '\emptyset' },
                                    \ { 'lhs' : '2',  'rhs' : '\sqrt' },
                                    \ { 'lhs' : '6',  'rhs' : '\partial' },
                                    \ { 'lhs' : '8',  'rhs' : '\infty' },
                                    \ { 'lhs' : '=',  'rhs' : '\equiv' },
                                    \ { 'lhs' : '\',  'rhs' : '\setminus' },
                                    \ { 'lhs' : '.',  'rhs' : '\cdot' },
                                    \ { 'lhs' : '*',  'rhs' : '\times' },
                                    \ { 'lhs' : '<',  'rhs' : '\langle' },
                                    \ { 'lhs' : '>',  'rhs' : '\rangle' },
                                    \ { 'lhs' : 'H',  'rhs' : '\hbar' },
                                    \ { 'lhs' : '+',  'rhs' : '\dagger' },
                                    \ { 'lhs' : '[',  'rhs' : '\subseteq' },
                                    \ { 'lhs' : ']',  'rhs' : '\supseteq' },
                                    \ { 'lhs' : '(',  'rhs' : '\subset' },
                                    \ { 'lhs' : ')',  'rhs' : '\supset' },
                                    \ { 'lhs' : 'A',  'rhs' : '\forall' },
                                    \ { 'lhs' : 'B',  'rhs' : '\boldsymbol' },
                                    \ { 'lhs' : 'E',  'rhs' : '\exists' },
                                    \ { 'lhs' : 'N',  'rhs' : '\nabla' },
                                    \ { 'lhs' : 'jj', 'rhs' : '\downarrow' },
                                    \ { 'lhs' : 'jJ', 'rhs' : '\Downarrow' },
                                    \ { 'lhs' : 'jk', 'rhs' : '\uparrow' },
                                    \ { 'lhs' : 'jK', 'rhs' : '\Uparrow' },
                                    \ { 'lhs' : 'jh', 'rhs' : '\leftarrow' },
                                    \ { 'lhs' : 'jH', 'rhs' : '\Leftarrow' },
                                    \ { 'lhs' : 'jl', 'rhs' : '\rightarrow' },
                                    \ { 'lhs' : 'jL', 'rhs' : '\Rightarrow' },
                                    \ { 'lhs' : 'a',  'rhs' : '\alpha' },
                                    \ { 'lhs' : 'b',  'rhs' : '\beta' },
                                    \ { 'lhs' : 'c',  'rhs' : '\chi' },
                                    \ { 'lhs' : 'd',  'rhs' : '\delta' },
                                    \ { 'lhs' : 'e',  'rhs' : '\epsilon' },
                                    \ { 'lhs' : 'f',  'rhs' : '\phi' },
                                    \ { 'lhs' : 'g',  'rhs' : '\gamma' },
                                    \ { 'lhs' : 'h',  'rhs' : '\eta' },
                                    \ { 'lhs' : 'i',  'rhs' : '\iota' },
                                    \ { 'lhs' : 'k',  'rhs' : '\kappa' },
                                    \ { 'lhs' : 'l',  'rhs' : '\lambda' },
                                    \ { 'lhs' : 'm',  'rhs' : '\mu' },
                                    \ { 'lhs' : 'n',  'rhs' : '\nu' },
                                    \ { 'lhs' : 'p',  'rhs' : '\pi' },
                                    \ { 'lhs' : 'q',  'rhs' : '\theta' },
                                    \ { 'lhs' : 'r',  'rhs' : '\rho' },
                                    \ { 'lhs' : 's',  'rhs' : '\sigma' },
                                    \ { 'lhs' : 't',  'rhs' : '\tau' },
                                    \ { 'lhs' : 'y',  'rhs' : '\psi' },
                                    \ { 'lhs' : 'u',  'rhs' : '\upsilon' },
                                    \ { 'lhs' : 'w',  'rhs' : '\omega' },
                                    \ { 'lhs' : 'z',  'rhs' : '\zeta' },
                                    \ { 'lhs' : 'x',  'rhs' : '\xi' },
                                    \ { 'lhs' : 'D',  'rhs' : '\Delta' },
                                    \ { 'lhs' : 'F',  'rhs' : '\Phi' },
                                    \ { 'lhs' : 'G',  'rhs' : '\Gamma' },
                                    \ { 'lhs' : 'L',  'rhs' : '\Lambda' },
                                    \ { 'lhs' : 'P',  'rhs' : '\Pi' },
                                    \ { 'lhs' : 'Q',  'rhs' : '\Theta' },
                                    \ { 'lhs' : 'S',  'rhs' : '\Sigma' },
                                    \ { 'lhs' : 'U',  'rhs' : '\Upsilon' },
                                    \ { 'lhs' : 'W',  'rhs' : '\Omega' },
                                    \ { 'lhs' : 'X',  'rhs' : '\Xi' },
                                    \ { 'lhs' : 'Y',  'rhs' : '\Psi' },
                                    \ { 'lhs' : 've', 'rhs' : '\varepsilon' },
                                    \ { 'lhs' : 'vf', 'rhs' : '\varphi' },
                                    \ { 'lhs' : 'vk', 'rhs' : '\varkappa' },
                                    \ { 'lhs' : 'vq', 'rhs' : '\vartheta' },
                                    \ { 'lhs' : 'vr', 'rhs' : '\varrho' },
                                    \ { 'lhs' : '/',  'rhs' : 'vimtex#imaps#style_math("slashed")', 'expr' : 1, 'leader' : '#'},
                                    \ { 'lhs' : 'b',  'rhs' : 'vimtex#imaps#style_math("mathbf")', 'expr' : 1, 'leader' : '#'},
                                    \ { 'lhs' : 'f',  'rhs' : 'vimtex#imaps#style_math("mathfrak")', 'expr' : 1, 'leader' : '#'},
                                    \ { 'lhs' : 'c',  'rhs' : 'vimtex#imaps#style_math("mathcal")', 'expr' : 1, 'leader' : '#'},
                                    \ { 'lhs' : '-',  'rhs' : 'vimtex#imaps#style_math("overline")', 'expr' : 1, 'leader' : '#'},
                                    \ { 'lhs' : 'B',  'rhs' : 'vimtex#imaps#style_math("mathbb")', 'expr' : 1, 'leader' : '#'},
                                    \ { 'lhs' : g:vimtex_imaps_leader,
                                    \   'rhs' : repeat(g:vimtex_imaps_leader, 2),
                                    \   'wrapper' : 'vimtex#imaps#wrap_trivial'},
                                    \])
                            
                              call s:init_option('vimtex_indent_enabled', 1)
                              call s:init_option('vimtex_indent_bib_enabled', 1)
                              call s:init_option('vimtex_indent_tikz_commands', 1)
                              call s:init_option('vimtex_indent_conditionals', {
                                    \ 'open': '\v%(\\newif)@<!\\if%(f>|field|name|numequal|thenelse|toggle)@!',
                                    \ 'else': '\\else\>',
                                    \ 'close': '\\fi\>',
                                    \})
                              call s:init_option('vimtex_indent_delims', {
                                    \ 'open' : ['{'],
                                    \ 'close' : ['}'],
                                    \ 'close_indented' : 0,
                                    \ 'include_modified_math' : 1,
                                    \})
                              call s:init_option('vimtex_indent_ignored_envs', ['document'])
                              call s:init_option('vimtex_indent_lists', [
                                    \ 'itemize',
                                    \ 'description',
                                    \ 'enumerate',
                                    \ 'thebibliography',
                                    \])
                              call s:init_option('vimtex_indent_on_ampersands', 1)
                            
                              call s:init_option('vimtex_mappings_enabled', 1)
                              call s:init_option('vimtex_mappings_disable', {})
                              call s:init_option('vimtex_mappings_override_existing', 0)
                            
                              call s:init_option('vimtex_mappings_prefix', '<localleader>l')
                            
                              call s:init_option('vimtex_matchparen_enabled', 1)
                              call s:init_option('vimtex_motion_enabled', 1)
                            
                              call s:init_option('vimtex_labels_enabled', 1)
                              call s:init_option('vimtex_labels_refresh_always', 1)
                            
                            
                              let s:chktexrc = (empty($XDG_CONFIG_HOME)
                                    \ ? $HOME . '/.config'
                                    \ : $XDG_CONFIG_HOME) . '/chktexrc'
                            
                              call s:init_option('vimtex_lint_chktex_parameters',
                                    \ filereadable(s:chktexrc)
                                    \   ? '--localrc ' . shellescape(s:chktexrc)
                                    \   : '')
                              call s:init_option('vimtex_lint_chktex_ignore_warnings',
                                    \ '-n1 -n3 -n8 -n25 -n36')
                            
                              call s:init_option('vimtex_parser_bib_backend', 'bibtex')
                              call s:init_option('vimtex_parser_cmd_separator_check',
                                    \ 'vimtex#cmd#parser_separator_check')
                            
                              call s:init_option('vimtex_quickfix_enabled', 1)
                              call s:init_option('vimtex_quickfix_method', 'latexlog')
                              call s:init_option('vimtex_quickfix_autojump', 0)
                              call s:init_option('vimtex_quickfix_ignore_filters', [])
                              call s:init_option('vimtex_quickfix_mode', 2)
                              call s:init_option('vimtex_quickfix_open_on_warning', 1)
                              call s:init_option('vimtex_quickfix_blgparser', {})
                              call s:init_option('vimtex_quickfix_autoclose_after_keystrokes', 0)
                            
                              call s:init_option('vimtex_subfile_start_local', 0)
                            
                              call s:init_option('vimtex_syntax_enabled', 1)
                              call s:init_option('vimtex_syntax_conceal', {
                                    \ 'accents': 1,
                                    \ 'ligatures': 1,
                                    \ 'cites': 1,
                                    \ 'fancy': 1,
                                    \ 'spacing': 1,
                                    \ 'greek': 1,
                                    \ 'math_bounds': 1,
                                    \ 'math_delimiters': 1,
                                    \ 'math_fracs': 1,
                                    \ 'math_super_sub': 1,
                                    \ 'math_symbols': 1,
                                    \ 'sections': 0,
                                    \ 'styles': 1,
                                    \})
                              call s:init_option('vimtex_syntax_conceal_cites', {
                                    \ 'type': 'brackets',
                                    \ 'icon': '📖',
                                    \ 'verbose': v:true,
                                    \})
                              call s:init_option('vimtex_syntax_conceal_disable', 0)
                              call s:init_option('vimtex_syntax_custom_cmds', [])
                              call s:init_option('vimtex_syntax_custom_cmds_with_concealed_delims', [])
                              call s:init_option('vimtex_syntax_custom_envs', [])
                              call s:init_option('vimtex_syntax_match_unicode', v:true)
                              call s:init_option('vimtex_syntax_nested', {
                                    \ 'aliases' : {
                                    \   'C' : 'c',
                                    \   'csharp' : 'cs',
                                    \ },
                                    \ 'ignored' : {
                                    \   'sh' : ['shSpecial'],
                                    \   'bash' : ['shSpecial'],
                                    \   'cs' : [
                                    \     'csBraces',
                                    \   ],
                                    \   'haskell' : [
                                    \     'hsVarSym',
                                    \   ],
                                    \   'java' : [
                                    \     'javaError',
                                    \   ],
                                    \   'lua' : [
                                    \     'luaParen',
                                    \     'luaParenError',
                                    \   ],
                                    \   'markdown' : [
                                    \     'mkdNonListItemBlock',
                                    \   ],
                                    \   'python' : [
                                    \     'pythonEscape',
                                    \     'pythonBEscape',
                                    \     'pythonBytesEscape',
                                    \   ],
                                    \ }
                                    \})
                              call s:init_option('vimtex_syntax_nospell_comments', 0)
                              call s:init_option('vimtex_syntax_packages', {
                                    \ 'amsmath': {'conceal': 1, 'load': 2},
                                    \ 'babel': {'conceal': 1},
                                    \ 'hyperref': {'conceal': 1},
                                    \ 'fontawesome5': {'conceal': 1},
                                    \})
                            
                              " Disable conceals if chosen
                              if g:vimtex_syntax_conceal_disable
                                call map(g:vimtex_syntax_conceal, {k, v -> 0})
                                let g:vimtex_syntax_packages.amsmath.conceal = 0
                                let g:vimtex_syntax_packages.babel.conceal = 0
                                let g:vimtex_syntax_packages.hyperref.conceal = 0
                                let g:vimtex_syntax_packages.fontawesome5.conceal = 0
                              endif
                            
                              call s:init_option('vimtex_texcount_custom_arg', '')
                            
                              call s:init_option('vimtex_text_obj_enabled', 1)
                              call s:init_option('vimtex_text_obj_variant', 'auto')
                              call s:init_option('vimtex_text_obj_linewise_operators', ['d', 'y'])
                            
                              call s:init_option('vimtex_toc_enabled', 1)
                              call s:init_option('vimtex_toc_config', {
                                    \ 'name' : 'Table of contents (VimTeX)',
                                    \ 'mode' : 1,
                                    \ 'fold_enable' : 0,
                                    \ 'fold_level_start' : -1,
                                    \ 'hide_line_numbers' : 1,
                                    \ 'hotkeys_enabled' : 0,
                                    \ 'hotkeys' : 'abcdeilmnopuvxyz',
                                    \ 'hotkeys_leader' : ';',
                                    \ 'indent_levels' : 0,
                                    \ 'layer_status' : {
                                    \   'content': 1,
                                    \   'label': 1,
                                    \   'todo': 1,
                                    \   'include': 1,
                                    \ },
                                    \ 'layer_keys' : {
                                    \   'content': 'C',
                                    \   'label': 'L',
                                    \   'todo': 'T',
                                    \   'include': 'I',
                                    \ },
                                    \ 'resize' : 0,
                                    \ 'refresh_always' : 1,
                                    \ 'show_help' : 1,
                                    \ 'show_numbers' : 1,
                                    \ 'split_pos' : 'vert leftabove',
                                    \ 'split_width' : 50,
                                    \ 'tocdepth' : 3,
                                    \ 'todo_sorted' : 1,
                                    \})
                              call s:init_option('vimtex_toc_config_matchers', {})
                              call s:init_option('vimtex_toc_custom_matchers', [])
                              call s:init_option('vimtex_toc_show_preamble', 1)
                              call s:init_option('vimtex_toc_todo_labels', {
                                    \ 'TODO': 'TODO: ',
                                    \ 'FIXME': 'FIXME: '
                                    \})
                            
                              call s:init_option('vimtex_toggle_fractions', {
                                    \ 'INLINE': 'frac',
                                    \ 'frac': 'INLINE',
                                    \ 'dfrac': 'INLINE',
                                    \})
                            
                              call s:init_option('vimtex_ui_method', {
                                    \ 'confirm': has('nvim') ? 'nvim' : 'legacy',
                                    \ 'input': has('nvim') ? 'nvim' : 'legacy',
                                    \ 'select': has('nvim') ? 'nvim' : 'legacy',
                                    \})
                            
                              call s:init_option('vimtex_view_enabled', 1)
                              call s:init_option('vimtex_view_automatic', 1)
                              call s:init_option('vimtex_view_method', 'general')
                              call s:init_option('vimtex_view_use_temp_files', 0)
                              call s:init_option('vimtex_view_forward_search_on_start', 1)
                              call s:init_option('vimtex_view_reverse_search_edit_cmd', 'edit')
                            
                              " OS dependent defaults
                              let l:os = vimtex#util#get_os()
                              if l:os ==# 'win'
                                if executable('SumatraPDF')
                                  call s:init_option('vimtex_view_general_viewer', 'SumatraPDF')
                                  call s:init_option('vimtex_view_general_options',
                                        \ '-reuse-instance -forward-search @tex @line @pdf')
                                elseif executable('mupdf')
                                  call s:init_option('vimtex_view_general_viewer', 'mupdf')
                                  call s:init_option('vimtex_view_general_options', '@pdf')
                                else
                                  call s:init_option('vimtex_view_general_viewer', 'start ""')
                                  call s:init_option('vimtex_view_general_options', '@pdf')
                                endif
                              else
                                call s:init_option('vimtex_view_general_viewer', get({
                                      \ 'linux' : 'xdg-open',
                                      \ 'mac'   : 'open',
                                      \}, l:os, ''))
                                call s:init_option('vimtex_view_general_options', '@pdf')
                              endif
                            
                              call s:init_option('vimtex_view_mupdf_options', '')
                              call s:init_option('vimtex_view_mupdf_send_keys', '')
                              call s:init_option('vimtex_view_sioyek_exe', 'sioyek')
                              call s:init_option('vimtex_view_sioyek_options', '')
                              call s:init_option('vimtex_view_skim_activate', 0)
                              call s:init_option('vimtex_view_skim_sync', 0)
                              call s:init_option('vimtex_view_skim_reading_bar', 0)
                              call s:init_option('vimtex_view_skim_no_select', 0)
                              call s:init_option('vimtex_view_texshop_activate', 0)
                              call s:init_option('vimtex_view_texshop_sync', 0)
                              call s:init_option('vimtex_view_zathura_options', '')
                              call s:init_option('vimtex_view_zathura_check_libsynctex', 1)
                            
                              " Fallback option
                              if g:vimtex_context_pdf_viewer ==# 'NONE'
                                let g:vimtex_context_pdf_viewer = g:vimtex_view_general_viewer
                              endif
                            
                              let s:initialized = v:true
                            endfunction
                            
    1              0.000003 let s:initialized = v:false
                            
                            " }}}1
                            
    1              0.000002 function! s:check_for_deprecated_options() abort " {{{1
                              let l:deprecated = filter([
                                    \ 'g:vimtex_change_complete_envs',
                                    \ 'g:vimtex_change_ignored_delims_pattern',
                                    \ 'g:vimtex_change_set_formatexpr',
                                    \ 'g:vimtex_change_toggled_delims',
                                    \ 'g:vimtex_compiler_callback_hooks',
                                    \ 'g:vimtex_disable_recursive_main_file_detection',
                                    \ 'g:vimtex_env_complete_list',
                                    \ 'g:vimtex_fold_commands',
                                    \ 'g:vimtex_fold_commands_default',
                                    \ 'g:vimtex_fold_comments',
                                    \ 'g:vimtex_fold_env_blacklist',
                                    \ 'g:vimtex_fold_env_whitelist',
                                    \ 'g:vimtex_fold_envs',
                                    \ 'g:vimtex_fold_markers',
                                    \ 'g:vimtex_fold_parts',
                                    \ 'g:vimtex_fold_preamble',
                                    \ 'g:vimtex_fold_sections',
                                    \ 'g:vimtex_index_hide_line_numbers',
                                    \ 'g:vimtex_index_mode',
                                    \ 'g:vimtex_index_resize',
                                    \ 'g:vimtex_index_show_help',
                                    \ 'g:vimtex_index_split_pos',
                                    \ 'g:vimtex_index_split_width',
                                    \ 'g:vimtex_latexmk_autojump',
                                    \ 'g:vimtex_latexmk_background',
                                    \ 'g:vimtex_latexmk_callback',
                                    \ 'g:vimtex_latexmk_callback_hooks',
                                    \ 'g:vimtex_latexmk_continuous',
                                    \ 'g:vimtex_latexmk_enabled',
                                    \ 'g:vimtex_latexmk_options',
                                    \ 'g:vimtex_latexmk_progname',
                                    \ 'g:vimtex_quickfix_ignore_all_warnings',
                                    \ 'g:vimtex_quickfix_ignored_warnings',
                                    \ 'g:vimtex_quickfix_latexlog',
                                    \ 'g:vimtex_quickfix_warnings',
                                    \ 'g:vimtex_syntax_autoload_packages',
                                    \ 'g:vimtex_syntax_conceal_default',
                                    \ 'g:vimtex_syntax_nospell_commands',
                                    \ 'g:vimtex_textidote_jar',
                                    \ 'g:vimtex_toc_fold',
                                    \ 'g:vimtex_toc_fold_level_start',
                                    \ 'g:vimtex_toc_fold_levels',
                                    \ 'g:vimtex_toc_hide_help',
                                    \ 'g:vimtex_toc_hide_line_numbers',
                                    \ 'g:vimtex_toc_hide_preamble',
                                    \ 'g:vimtex_toc_hotkeys',
                                    \ 'g:vimtex_toc_layers',
                                    \ 'g:vimtex_toc_number_width',
                                    \ 'g:vimtex_toc_numbers',
                                    \ 'g:vimtex_toc_numbers_width',
                                    \ 'g:vimtex_toc_refresh_always',
                                    \ 'g:vimtex_toc_resize',
                                    \ 'g:vimtex_toc_show_numbers',
                                    \ 'g:vimtex_toc_split_pos',
                                    \ 'g:vimtex_toc_tocdepth',
                                    \ 'g:vimtex_toc_width',
                                    \ 'g:vimtex_view_automatic_xwin',
                                    \ 'g:vimtex_view_general_callback',
                                    \ 'g:vimtex_view_general_hook_callback',
                                    \ 'g:vimtex_view_general_hook_view',
                                    \ 'g:vimtex_view_general_options_latexmk',
                                    \ 'g:vimtex_view_mupdf_hook_callback',
                                    \ 'g:vimtex_view_mupdf_hook_view',
                                    \ 'g:vimtex_view_skim_hook_callback',
                                    \ 'g:vimtex_view_skim_hook_view',
                                    \ 'g:vimtex_view_zathura_hook_callback',
                                    \ 'g:vimtex_view_zathura_hook_view',
                                    \], 'exists(v:val)')
                            
                              if !empty(l:deprecated)
                                redraw!
                                let l:message = ['Deprecated option(s) detected!']
                                      \ + map(l:deprecated, { _, val -> '- ' . val})
                                      \ + ['Please see `:help OPTION` for more info!']
                                call vimtex#log#warning(l:message)
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:init_highlights() abort " {{{1
                              for [l:name, l:target] in [
                                    \ ['VimtexImapsArrow', 'Comment'],
                                    \ ['VimtexImapsLhs', 'ModeMsg'],
                                    \ ['VimtexImapsRhs', 'ModeMsg'],
                                    \ ['VimtexImapsWrapper', 'Type'],
                                    \ ['VimtexInfo', 'Question'],
                                    \ ['VimtexInfoTitle', 'PreProc'],
                                    \ ['VimtexInfoKey', 'PreProc'],
                                    \ ['VimtexInfoValue', 'Statement'],
                                    \ ['VimtexInfoOther', ''],
                                    \ ['VimtexMsg', 'ModeMsg'],
                                    \ ['VimtexSuccess', 'Statement'],
                                    \ ['VimtexTodo', 'Todo'],
                                    \ ['VimtexWarning', 'WarningMsg'],
                                    \ ['VimtexError', 'Error'],
                                    \ ['VimtexFatal', 'ErrorMsg'],
                                    \ ['VimtexTocHelp', 'helpVim'],
                                    \ ['VimtexTocHelpKey', 'ModeMsg'],
                                    \ ['VimtexTocHelpLayerOn', 'Statement'],
                                    \ ['VimtexTocHelpLayerOff', 'Comment'],
                                    \ ['VimtexTocTodo', 'VimtexTodo'],
                                    \ ['VimtexTocWarning', 'VimtexWarning'],
                                    \ ['VimtexTocError', 'VimtexError'],
                                    \ ['VimtexTocFatal', 'VimtexFatal'],
                                    \ ['VimtexTocNum', 'Number'],
                                    \ ['VimtexTocSec0', 'Title'],
                                    \ ['VimtexTocSec1', ''],
                                    \ ['VimtexTocSec2', 'helpVim'],
                                    \ ['VimtexTocSec3', 'NonText'],
                                    \ ['VimtexTocSec4', 'Comment'],
                                    \ ['VimtexTocHotkey', 'Comment'],
                                    \ ['VimtexTocLabelsSecs', 'Statement'],
                                    \ ['VimtexTocLabelsEq', 'PreProc'],
                                    \ ['VimtexTocLabelsFig', 'Identifier'],
                                    \ ['VimtexTocLabelsTab', 'String'],
                                    \ ['VimtexTocIncl', 'Number'],
                                    \ ['VimtexTocInclPath', ''],
                                    \]
                                if !hlexists(l:name) && !empty(l:target)
                                  silent execute 'highlight default link' l:name l:target
                                endif
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:init_option(option, default) abort " {{{1
                              let l:option = 'g:' . a:option
                              if !exists(l:option)
                                let {l:option} = a:default
                              elseif type(a:default) == v:t_dict
                                call vimtex#util#extend_recursive({l:option}, a:default, 'keep')
                              endif
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/util.vim
Sourced 1 time
Total time:   0.004003
 Self time:   0.003695

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#util#command(cmd) abort " {{{1
                              return split(execute(a:cmd, 'silent!'), "\n")
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#util#count(line, pattern) abort " {{{1
                              if empty(a:pattern) | return 0 | endif
                            
                              let l:count = 1
                              while match(a:line, a:pattern, 0, l:count) >= 0
                                let l:count += 1
                              endwhile
                            
                              return l:count - 1
                            endfunction
                            
                            " }}}1
    1              0.000003 function! vimtex#util#count_open(line, re_open, re_close) abort " {{{1
                              " Counts the number of unclosed opening patterns in the given line.
                              let l:i = match(a:line, a:re_open)
                              if l:i < 0 | return 0 | endif
                            
                              let l:sum = 0
                              let l:imin_last = l:i
                              while l:i >= 0
                                let l:sum += 1
                                let l:i += len(matchstr(a:line, a:re_open, l:i))
                                let l:i = match(a:line, a:re_open, l:i)
                              endwhile
                            
                              let l:i = match(a:line, a:re_close, l:imin_last)
                              while l:i >= 0
                                let l:sum -= 1
                                let l:i += len(matchstr(a:line, a:re_close, l:i))
                                let l:i = match(a:line, a:re_close, l:i)
                              endwhile
                            
                              return max([l:sum, 0])
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#util#count_close(line, re_open, re_close) abort " {{{1
                              " Counts the number of unopened closing patterns in the given line.
                              let l:i = match(a:line, a:re_close)
                              if l:i < 0 | return 0 | endif
                            
                              let l:sum = 0
                              while l:i >= 0
                                let l:sum += 1
                                let l:imax_first = l:i
                                let l:i += len(matchstr(a:line, a:re_close, l:i))
                                let l:i = match(a:line, a:re_close, l:i)
                              endwhile
                            
                              let l:i = match(a:line, a:re_open)
                              while l:i >= 0 && l:i < l:imax_first
                                let l:sum -= 1
                                let l:i += len(matchstr(a:line, a:re_open, l:i))
                                let l:i = match(a:line, a:re_open, l:i)
                              endwhile
                            
                              return max([l:sum, 0])
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#util#flatten(list) abort " {{{1
                              let l:result = []
                            
                              for l:element in a:list
                                if type(l:element) == v:t_list
                                  call extend(l:result, vimtex#util#flatten(l:element))
                                else
                                  call add(l:result, l:element)
                                endif
                                unlet l:element
                              endfor
                            
                              return l:result
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#util#get_os() abort " {{{1
                              if vimtex#util#is_win()
                                return 'win'
                              elseif has('unix')
                                if has('mac') || has('ios') || vimtex#jobs#cached('uname')[0] =~# 'Darwin'
                                  return 'mac'
                                else
                                  return 'linux'
                                endif
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#util#is_win() abort " {{{1
                              return has('win32') || has('win32unix')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#util#extend_recursive(dict1, dict2, ...) abort " {{{1
                              let l:option = a:0 > 0 ? a:1 : 'force'
                              if index(['force', 'keep', 'error'], l:option) < 0
                                throw 'E475: Invalid argument: ' . l:option
                              endif
                            
                              for [l:key, l:value] in items(a:dict2)
                                if !has_key(a:dict1, l:key)
                                  let a:dict1[l:key] = l:value
                                elseif type(l:value) == v:t_dict
                                  call vimtex#util#extend_recursive(a:dict1[l:key], l:value, l:option)
                                elseif l:option ==# 'error'
                                  throw 'E737: Key already exists: ' . l:key
                                elseif l:option ==# 'force'
                                  let a:dict1[l:key] = l:value
                                endif
                                unlet l:value
                              endfor
                            
                              return a:dict1
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#util#materialize_property(dict, name) abort " {{{1
                              if type(get(a:dict, a:name)) != v:t_func | return | endif
                            
                              try
                                let a:dict[a:name] = a:dict[a:name]()
                              catch
                                call vimtex#log#error(
                                      \ 'Could not materialize property: ' . a:name,
                                      \ v:exception)
                                let a:dict[a:name] = ''
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#util#shellescape(cmd) abort " {{{1
                              "
                              " Path used in "cmd" only needs to be enclosed by double quotes.
                              " shellescape() on Windows with "shellslash" set will produce a path
                              " enclosed by single quotes, which "cmd" does not recognize and reports an
                              " error.
                              "
                              if has('win32')
                                let l:shellslash = &shellslash
                                set noshellslash
                                let l:cmd = escape(shellescape(a:cmd), '\')
                                let &shellslash = l:shellslash
                                return l:cmd
                              else
                                return escape(shellescape(a:cmd), '\')
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#util#tex2unicode(line) abort " {{{1
                              " Convert compositions to unicode
                              let l:line = a:line
                              for [l:pat, l:symbol] in s:tex2unicode_list
                                let l:line = substitute(l:line, l:pat, l:symbol, 'g')
                              endfor
                            
                              " Remove the \IeC macro
                              let l:line = substitute(l:line, '\C\\IeC\s*{\s*\([^}]\{-}\)\s*}', '\1', 'g')
                            
                              return l:line
                            endfunction
                            
                            "
                            " Define list for converting compositions like \"u to unicode ű
    1   0.003834   0.003526 let s:tex2unicode_list = map([
                                  \ ['\\"A',                'Ä'],
                                  \ ['\\"E',                'Ë'],
                                  \ ['\\"I',                'Ï'],
                                  \ ['\\"O',                'Ö'],
                                  \ ['\\"U',                'Ü'],
                                  \ ['\\"Y',                'Ÿ'],
                                  \ ['\\"\\i',              'ï'],
                                  \ ['\\"a',                'ä'],
                                  \ ['\\"e',                'ë'],
                                  \ ['\\"i',                'ï'],
                                  \ ['\\"o',                'ö'],
                                  \ ['\\"u',                'ü'],
                                  \ ['\\"y',                'ÿ'],
                                  \ ['\\''A',               'Á'],
                                  \ ['\\''C',               'Ć'],
                                  \ ['\\''E',               'É'],
                                  \ ['\\''G',               'Ǵ'],
                                  \ ['\\''I',               'Í'],
                                  \ ['\\''L',               'Ĺ'],
                                  \ ['\\''N',               'Ń'],
                                  \ ['\\''O',               'Ó'],
                                  \ ['\\''R',               'Ŕ'],
                                  \ ['\\''S',               'Ś'],
                                  \ ['\\''U',               'Ú'],
                                  \ ['\\''Y',               'Ý'],
                                  \ ['\\''Z',               'Ź'],
                                  \ ['\\''\\i',             'í'],
                                  \ ['\\''a',               'á'],
                                  \ ['\\''c',               'ć'],
                                  \ ['\\''e',               'é'],
                                  \ ['\\''g',               'ǵ'],
                                  \ ['\\''i',               'í'],
                                  \ ['\\''i',               'í'],
                                  \ ['\\''l',               'ĺ'],
                                  \ ['\\''n',               'ń'],
                                  \ ['\\''o',               'ó'],
                                  \ ['\\''r',               'ŕ'],
                                  \ ['\\''s',               'ś'],
                                  \ ['\\''u',               'ú'],
                                  \ ['\\''y',               'ý'],
                                  \ ['\\''z',               'ź'],
                                  \ ['\\=A',                'Ā'],
                                  \ ['\\=E',                'Ē'],
                                  \ ['\\=I',                'Ī'],
                                  \ ['\\=O',                'Ō'],
                                  \ ['\\=U',                'Ū'],
                                  \ ['\\=a',                'ā'],
                                  \ ['\\=e',                'ē'],
                                  \ ['\\=i',                'ī'],
                                  \ ['\\=o',                'ō'],
                                  \ ['\\=u',                'ū'],
                                  \ ['\\HO',                'Ő'],
                                  \ ['\\HU',                'Ű'],
                                  \ ['\\Ho',                'ő'],
                                  \ ['\\Hu',                'ű'],
                                  \ ['\\\%(\~\|tilde\)A',   'Ã'],
                                  \ ['\\\%(\~\|tilde\)E',   'Ẽ'],
                                  \ ['\\\%(\~\|tilde\)I',   'Ĩ'],
                                  \ ['\\\%(\~\|tilde\)N',   'Ñ'],
                                  \ ['\\\%(\~\|tilde\)O',   'Õ'],
                                  \ ['\\\%(\~\|tilde\)U',   'Ũ'],
                                  \ ['\\\%(\~\|tilde\)Y',   'Ỹ'],
                                  \ ['\\\%(\~\|tilde\)\\i', 'ĩ'],
                                  \ ['\\\%(\~\|tilde\)a',   'ã'],
                                  \ ['\\\%(\~\|tilde\)e',   'ẽ'],
                                  \ ['\\\%(\~\|tilde\)i',   'ĩ'],
                                  \ ['\\\%(\~\|tilde\)n',   'ñ'],
                                  \ ['\\\%(\~\|tilde\)o',   'õ'],
                                  \ ['\\\%(\~\|tilde\)u',   'ũ'],
                                  \ ['\\\%(\~\|tilde\)y',   'ỹ'],
                                  \ ['\\\.A',               'Ȧ'],
                                  \ ['\\\.C',               'Ċ'],
                                  \ ['\\\.E',               'Ė'],
                                  \ ['\\\.G',               'Ġ'],
                                  \ ['\\\.I',               'İ'],
                                  \ ['\\\.O',               'Ȯ'],
                                  \ ['\\\.Z',               'Ż'],
                                  \ ['\\\.\\i',             'į'],
                                  \ ['\\\.a',               'ȧ'],
                                  \ ['\\\.c',               'ċ'],
                                  \ ['\\\.e',               'ė'],
                                  \ ['\\\.g',               'ġ'],
                                  \ ['\\\.i',               'į'],
                                  \ ['\\\.o',               'ȯ'],
                                  \ ['\\\.z',               'ż'],
                                  \ ['\\^A',                'Â'],
                                  \ ['\\^C',                'Ĉ'],
                                  \ ['\\^E',                'Ê'],
                                  \ ['\\^G',                'Ĝ'],
                                  \ ['\\^I',                'Î'],
                                  \ ['\\^L',                'Ľ'],
                                  \ ['\\^O',                'Ô'],
                                  \ ['\\^S',                'Ŝ'],
                                  \ ['\\^U',                'Û'],
                                  \ ['\\^W',                'Ŵ'],
                                  \ ['\\^Y',                'Ŷ'],
                                  \ ['\\^\\i',              'î'],
                                  \ ['\\^a',                'â'],
                                  \ ['\\^c',                'ĉ'],
                                  \ ['\\^e',                'ê'],
                                  \ ['\\^g',                'ĝ'],
                                  \ ['\\^h',                'ĥ'],
                                  \ ['\\^i',                'î'],
                                  \ ['\\^l',                'ľ'],
                                  \ ['\\^o',                'ô'],
                                  \ ['\\^s',                'ŝ'],
                                  \ ['\\^u',                'û'],
                                  \ ['\\^w',                'ŵ'],
                                  \ ['\\^y',                'ŷ'],
                                  \ ['\\`A',                'À'],
                                  \ ['\\`E',                'È'],
                                  \ ['\\`I',                'Ì'],
                                  \ ['\\`N',                'Ǹ'],
                                  \ ['\\`O',                'Ò'],
                                  \ ['\\`U',                'Ù'],
                                  \ ['\\`Y',                'Ỳ'],
                                  \ ['\\`\\i',              'ì'],
                                  \ ['\\`a',                'à'],
                                  \ ['\\`e',                'è'],
                                  \ ['\\`i',                'ì'],
                                  \ ['\\`n',                'ǹ'],
                                  \ ['\\`o',                'ò'],
                                  \ ['\\`y',                'ỳ'],
                                  \ ['\\cC',                'Ç'],
                                  \ ['\\cE',                'Ȩ'],
                                  \ ['\\cG',                'Ģ'],
                                  \ ['\\cK',                'Ķ'],
                                  \ ['\\cL',                'Ļ'],
                                  \ ['\\cN',                'Ņ'],
                                  \ ['\\cR',                'Ŗ'],
                                  \ ['\\cS',                'Ş'],
                                  \ ['\\cT',                'Ţ'],
                                  \ ['\\cc',                'ç'],
                                  \ ['\\ce',                'ȩ'],
                                  \ ['\\cg',                'ģ'],
                                  \ ['\\ck',                'ķ'],
                                  \ ['\\cl',                'ļ'],
                                  \ ['\\cn',                'ņ'],
                                  \ ['\\cr',                'ŗ'],
                                  \ ['\\cs',                'ş'],
                                  \ ['\\ct',                'ţ'],
                                  \ ['\\kA',                'Ą'],
                                  \ ['\\kE',                'Ę'],
                                  \ ['\\kI',                'Į'],
                                  \ ['\\kO',                'Ǫ'],
                                  \ ['\\kU',                'Ų'],
                                  \ ['\\ka',                'ą'],
                                  \ ['\\ke',                'ę'],
                                  \ ['\\ki',                'į'],
                                  \ ['\\ko',                'ǫ'],
                                  \ ['\\ks',                'ȿ'],
                                  \ ['\\ku',                'ų'],
                                  \ ['\\o',                 'ø'],
                                  \ ['\\rA',                'Å'],
                                  \ ['\\rU',                'Ů'],
                                  \ ['\\ra',                'å'],
                                  \ ['\\ru',                'ů'],
                                  \ ['\\uA',                'Ă'],
                                  \ ['\\uE',                'Ĕ'],
                                  \ ['\\uG',                'Ğ'],
                                  \ ['\\uI',                'Ĭ'],
                                  \ ['\\uO',                'Ŏ'],
                                  \ ['\\uU',                'Ŭ'],
                                  \ ['\\u\\i',              'ĭ'],
                                  \ ['\\ua',                'ă'],
                                  \ ['\\ue',                'ĕ'],
                                  \ ['\\ug',                'ğ'],
                                  \ ['\\ui',                'ĭ'],
                                  \ ['\\uo',                'ŏ'],
                                  \ ['\\uu',                'ŭ'],
                                  \ ['\\vA',                'Ǎ'],
                                  \ ['\\vC',                'Č'],
                                  \ ['\\vD',                'Ď'],
                                  \ ['\\vE',                'Ě'],
                                  \ ['\\vG',                'Ǧ'],
                                  \ ['\\vH',                'Ȟ'],
                                  \ ['\\vI',                'Ǐ'],
                                  \ ['\\vJ',                'ǰ'],
                                  \ ['\\vK',                'Ǩ'],
                                  \ ['\\vL',                'Ľ'],
                                  \ ['\\vN',                'Ň'],
                                  \ ['\\vO',                'Ǒ'],
                                  \ ['\\vR',                'Ř'],
                                  \ ['\\vS',                'Š'],
                                  \ ['\\vT',                'Ť'],
                                  \ ['\\vU',                'Ǔ'],
                                  \ ['\\vZ',                'Ž'],
                                  \ ['\\va',                'ǎ'],
                                  \ ['\\vc',                'č'],
                                  \ ['\\vd',                'ď'],
                                  \ ['\\ve',                'ě'],
                                  \ ['\\vg',                'ǧ'],
                                  \ ['\\vh',                'ȟ'],
                                  \ ['\\vi',                'ǐ'],
                                  \ ['\\vk',                'ǩ'],
                                  \ ['\\vl',                'ľ'],
                                  \ ['\\vn',                'ň'],
                                  \ ['\\vo',                'ǒ'],
                                  \ ['\\vr',                'ř'],
                                  \ ['\\vs',                'š'],
                                  \ ['\\vt',                'ť'],
                                  \ ['\\vu',                'ǔ'],
                                  \ ['\\vz',                'ž'],
                                  \ ['\\¨A',                'Ä'],
                                  \ ['\\¨E',                'Ë'],
                                  \ ['\\¨I',                'Ï'],
                                  \ ['\\¨O',                'Ö'],
                                  \ ['\\¨U',                'Ü'],
                                  \ ['\\¨a',                'ä'],
                                  \ ['\\¨e',                'ë'],
                                  \ ['\\¨i',                'ï'],
                                  \ ['\\¨o',                'ö'],
                                  \ ['\\¨u',                'ü'],
                                  \], {_, x -> ['\C' . x[0], x[1]]})
                            
                            " }}}1
    1              0.000002 function! vimtex#util#tex2tree(str) abort " {{{1
                              let tree = []
                              let i1 = 0
                              let i2 = -1
                              let depth = 0
                              while i2 < len(a:str)
                                let i2 = match(a:str, '[{}]', i2 + 1)
                                if i2 < 0
                                  let i2 = len(a:str)
                                endif
                                if i2 >= len(a:str) || a:str[i2] ==# '{'
                                  if depth == 0
                                    let item = substitute(strpart(a:str, i1, i2 - i1),
                                          \ '^\s*\|\s*$', '', 'g')
                                    if !empty(item)
                                      call add(tree, item)
                                    endif
                                    let i1 = i2 + 1
                                  endif
                                  let depth += 1
                                else
                                  let depth -= 1
                                  if depth == 0
                                    call add(tree, vimtex#util#tex2tree(strpart(a:str, i1, i2 - i1)))
                                    let i1 = i2 + 1
                                  endif
                                endif
                              endwhile
                              return tree
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#util#texsplit(str) abort " {{{1
                              " Splits "str", but respect TeX groups ({...})
                              if empty(a:str) | return [] | endif
                            
                              let parts = []
                              let i1 = 0
                              let i2 = -1
                              let depth = 0
                            
                              while v:true
                                let i2 = match(a:str, '[,{}]', i2 + 1)
                            
                                if i2 < 0
                                  call add(parts, strpart(a:str, i1))
                                  break
                                endif
                            
                                if a:str[i2] ==# '{'
                                  let depth += 1
                                elseif a:str[i2] ==# '}'
                                  let depth -= 1
                                elseif depth == 0
                                  call add(parts, strpart(a:str, i1, i2 - i1))
                                  let i1 = i2 + 1
                                endif
                              endwhile
                            
                              return parts
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#util#trim(str) abort " {{{1
                              if exists('*trim') | return trim(a:str) | endif
                            
                              let l:str = substitute(a:str, '^\s*', '', '')
                              let l:str = substitute(l:str, '\s*$', '', '')
                            
                              return l:str
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#util#uniq_unsorted(list) abort " {{{1
                              if len(a:list) <= 1 | return deepcopy(a:list) | endif
                            
                              let l:visited = {}
                              let l:result = []
                              for l:x in a:list
                                let l:key = string(l:x)
                                if !has_key(l:visited, l:key)
                                  let l:visited[l:key] = 1
                                  call add(l:result, l:x)
                                endif
                              endfor
                            
                              return l:result
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#util#undostore() abort " {{{1
                              " This is a hack to make undo restore the correct position
                              if mode() !=# 'i'
                                normal! ix
                                normal! x
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#util#www(url) abort " {{{1
                              let l:os = vimtex#util#get_os()
                            
                              silent execute (l:os ==# 'linux'
                                    \         ? '!xdg-open'
                                    \         : (l:os ==# 'mac'
                                    \            ? '!open'
                                    \            : '!start'))
                                    \ . ' ' . a:url
                                    \ . (l:os ==# 'win' ? '' : ' &')
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/jobs.vim
Sourced 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
                            " These are wrapper functions for starting processes. They are created to give
                            " a unified interface that should work reliably on both Vim and neovim on all
                            " OSes.
                            
    1              0.000002 function! vimtex#jobs#start(cmd, ...) abort " {{{1
                              " Start a background process.
                              "
                              " The optional argument is a dictionary of options. Each option is parsed in
                              " the code below.
                              "
                              " Return: Job object.
                              let l:opts = a:0 > 0 ? a:1 : {}
                            
                              let l:job = vimtex#jobs#{s:backend}#new(a:cmd)
                              let l:job.cmd_raw = a:cmd
                              let l:job.cwd = get(l:opts, 'cwd',
                                    \ exists('b:vimtex.root') ? b:vimtex.root : '')
                              let l:job.wait_timeout = str2nr(get(l:opts, 'wait_timeout', 5000))
                              let l:job.capture_output = get(l:opts, 'capture_output', v:false)
                              let l:job.detached = get(l:opts, 'detached', v:false)
                            
                              return l:job.start()
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#jobs#run(cmd, ...) abort " {{{1
                              " Run an external process.
                              "
                              " The optional argument is a dictionary of options. Each option is parsed in
                              " the code below.
                              "
                              " Return: Nothing.
                              let l:opts = a:0 > 0 ? a:1 : {}
                            
                              call vimtex#paths#pushd(get(l:opts, 'cwd', ''))
                              call vimtex#jobs#{s:backend}#run(a:cmd)
                              call vimtex#paths#popd()
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#jobs#capture(cmd, ...) abort " {{{1
                              " Run an external process and capture the command output.
                              "
                              " The optional argument is a dictionary of options. Each option is parsed in
                              " the code below.
                              "
                              " Return: Command output as list of strings.
                              let l:opts = a:0 > 0 ? a:1 : {}
                            
                              call vimtex#paths#pushd(get(l:opts, 'cwd', ''))
                              let l:output = vimtex#jobs#{s:backend}#capture(a:cmd)
                              call vimtex#paths#popd()
                            
                              " On Windows there may be trailing CR characters
                              return has('win32')
                                    \ ? map(l:output, {_, x -> substitute(x, '\r$', '', '')})
                                    \ : l:output
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#jobs#cached(cmd) abort " {{{1
                              " Cached version of vimtex#jobs#capture(...)
                              let l:cache = vimtex#cache#open('capture')
                            
                              return l:cache.has(a:cmd)
                                    \ ? l:cache.get(a:cmd)
                                    \ : l:cache.set(a:cmd, vimtex#jobs#capture(a:cmd))
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000004 let s:backend = has('nvim') ? 'neovim' : 'vim'

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim
Sourced 1 time
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#cache#init_buffer() abort " {{{1
                              command! -buffer -nargs=1 VimtexClearCache call vimtex#cache#clear(<q-args>)
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#cache#path(name) abort " {{{1
                              let l:root = s:root()
                              if !isdirectory(l:root)
                                call mkdir(l:root, 'p')
                              endif
                            
                              return vimtex#paths#join(l:root, a:name)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#cache#wrap(Func, name, ...) abort " {{{1
                              if !has('lambda')
                                throw 'error: vimtex#cache#wrap requires +lambda'
                              endif
                            
                              let l:opts = a:0 > 0 ? a:1 : {}
                              let l:cache = vimtex#cache#open(a:name, l:opts)
                            
                              function! CachedFunc(key) closure
                                if l:cache.has(a:key)
                                  return l:cache.get(a:key)
                                else
                                  return l:cache.set(a:key, a:Func(a:key))
                                endif
                              endfunction
                            
                              return function('CachedFunc')
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#cache#open(name, ...) abort " {{{1
                              let l:opts = extend({
                                    \ 'local': v:false,
                                    \ 'default': 0,
                                    \ 'persistent': get(g:, 'vimtex_cache_persistent', v:true),
                                    \ 'validate': s:_version,
                                    \}, a:0 > 0 ? a:1 : {})
                            
                              let l:project_local = remove(l:opts, 'local')
                              return s:cache_open(a:name, l:project_local, l:opts)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#cache#close(name) abort " {{{1
                              " Note: This will close BOTH local and global cache!
                            
                              for [l:name, l:cache] in s:cache_get_both(a:name)
                                if !empty(l:cache) && has_key(s:caches, l:name)
                                  call l:cache.write()
                                  unlet s:caches[l:name]
                                endif
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#cache#clear(name) abort " {{{1
                              if empty(a:name) | return | endif
                            
                              if a:name ==# 'ALL'
                                return s:cache_clear_all()
                              endif
                            
                              let l:persistent = get(g:, 'vimtex_cache_persistent', 1)
                              for [l:name, l:cache] in s:cache_get_both(a:name)
                                if !empty(l:cache)
                                  call l:cache.clear()
                                  unlet s:caches[l:name]
                                elseif l:persistent
                                  let l:path = vimtex#cache#path(l:name . '.json')
                                  call delete(l:path)
                                endif
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#cache#write_all() abort " {{{1
                              for l:cache in values(get(s:, 'caches', {}))
                                call l:cache.write()
                              endfor
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 function! s:cache_open(name, project_local, opts) abort " {{{1
                              let l:name = a:project_local ? s:local_name(a:name) : a:name
                            
                              let s:caches = get(s:, 'caches', {})
                              if !has_key(s:caches, l:name)
                                let l:path = vimtex#cache#path(l:name . '.json')
                                let s:caches[l:name] = s:cache.init(l:path, a:opts)
                              endif
                            
                              return s:caches[l:name]
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:cache_get(name, ...) abort " {{{1
                              let l:project_local = a:0 > 0 ? a:1 : v:false
                              let l:name = l:project_local ? s:local_name(a:name) : a:name
                            
                              let s:caches = get(s:, 'caches', {})
                              return [l:name, get(s:caches, l:name, {})]
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:cache_get_both(name) abort " {{{1
                              return map(
                                    \ [v:false, v:true],
                                    \ { _, x -> s:cache_get(a:name, x) }
                                    \)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:cache_clear_all() abort " {{{1
                              " Delete cache state map
                              unlet! s:caches
                            
                              if !get(g:, 'vimtex_cache_persistent', 1) | return | endif
                            
                              " Delete cache files
                              for l:file in globpath(s:root(), '*.json', 0, 1)
                                call delete(l:file)
                              endfor
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 let s:cache = {}
                            
    1              0.000003 function! s:cache.init(path, opts) dict abort " {{{1
                              let new = deepcopy(self)
                              unlet new.init
                            
                              let new.data = {}
                              let new.path = a:path
                              let new.ftime = -1
                              let new.default = a:opts.default
                            
                              let new.__validated = 0
                              let new.__validation_value = deepcopy(a:opts.validate)
                              if type(new.__validation_value) == v:t_dict
                                let new.__validation_value._version = s:_version
                              endif
                              let new.data.__validate = deepcopy(new.__validation_value)
                            
                              if a:opts.persistent
                                return extend(new, s:cache_persistent)
                              endif
                            
                              return extend(new, s:cache_volatile)
                            endfunction
                            
                            " }}}1
                            
    1              0.000005 let s:cache_persistent = {
                                  \ 'type': 'persistent',
                                  \ 'modified': 0,
                                  \}
    1              0.000002 function! s:cache_persistent.validate() dict abort " {{{1
                              let self.__validated = 1
                            
                              if type(self.data.__validate) != type(self.__validation_value)
                                    \ || self.data.__validate != self.__validation_value
                                call self.clear()
                                let self.data.__validate = deepcopy(self.__validation_value)
                                call self.write()
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:cache_persistent.get(key) dict abort " {{{1
                              call self.read()
                            
                              if !has_key(self.data, a:key)
                                let self.data[a:key] = deepcopy(self.default)
                              endif
                            
                              return get(self.data, a:key)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:cache_persistent.has(key) dict abort " {{{1
                              call self.read()
                            
                              return has_key(self.data, a:key)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:cache_persistent.set(key, value) dict abort " {{{1
                              call self.read()
                            
                              let self.data[a:key] = a:value
                              call self.write(1)
                            
                              return a:value
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:cache_persistent.write(...) dict abort " {{{1
                              call self.read()
                            
                              let l:modified = self.modified || a:0 > 0
                              if !l:modified || empty(self.data) | return | endif
                            
                              call writefile([json_encode(self.data)], self.path)
                              let self.ftime = getftime(self.path)
                              let self.modified = 0
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:cache_persistent.read() dict abort " {{{1
                              if getftime(self.path) <= self.ftime | return | endif
                            
                              let self.ftime = getftime(self.path)
                              let l:contents = join(readfile(self.path))
                              if empty(l:contents) | return | endif
                            
                              let l:data = json_decode(l:contents)
                            
                              if type(l:data) != v:t_dict
                                call vimtex#log#warning(
                                      \ 'Inconsistent cache data while reading:',
                                      \ self.path,
                                      \ 'Decoded data type: ' . type(l:data)
                                      \)
                                return
                              endif
                            
                              call extend(self.data, l:data)
                            
                              if !self.__validated
                                call self.validate()
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:cache_persistent.clear() dict abort " {{{1
                              let self.data = { '__validate': deepcopy(self.__validation_value) }
                              let self.ftime = -1
                              let self.modified = 0
                              call delete(self.path)
                            endfunction
                            
                            " }}}1
                            
    1              0.000004 let s:cache_volatile = {
                                  \ 'type': 'volatile',
                                  \}
    1              0.000002 function! s:cache_volatile.get(key) dict abort " {{{1
                              if !has_key(self.data, a:key)
                                let self.data[a:key] = deepcopy(self.default)
                              endif
                            
                              return get(self.data, a:key)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:cache_volatile.has(key) dict abort " {{{1
                              return has_key(self.data, a:key)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:cache_volatile.set(key, value) dict abort " {{{1
                              let self.data[a:key] = a:value
                              let self.ftime = localtime()
                              return a:value
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:cache_volatile.write(...) dict abort " {{{1
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:cache_volatile.read() dict abort " {{{1
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:cache_volatile.clear() dict abort " {{{1
                              let self.data = {}
                              let self.ftime = -1
                            endfunction
                            
                            " }}}1
                            
                            " Utility functions
    1              0.000001 function! s:root() abort " {{{1
                              return get(g:, 'vimtex_cache_root',
                                    \ (empty($XDG_CACHE_HOME) ? $HOME . '/.cache' : $XDG_CACHE_HOME)
                                    \ . '/vimtex')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:local_name(name) abort " {{{1
                              let l:filename = exists('b:vimtex.tex')
                                    \ ? fnamemodify(b:vimtex.tex, ':r')
                                    \ : expand('%:p:r')
                              let l:filename = substitute(l:filename, '\s\+', '_', 'g')
                              let l:filename = substitute(l:filename, '\/', '%', 'g')
                              let l:filename = substitute(l:filename, '\\', '%', 'g')
                              let l:filename = substitute(l:filename, ':', '%', 'g')
                              return a:name . l:filename
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 let s:_version = 'cache_v2'

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/paths.vim
Sourced 1 time
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#paths#asset(name) abort " {{{1
                              return vimtex#paths#join(s:root, 'assets/' . a:name)
                            endfunction
                            
    1              0.000015 let s:root = resolve(expand('<sfile>:p:h:h:h'))
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#paths#pushd(path) abort " {{{1
                              if empty(a:path) || getcwd() ==# fnamemodify(a:path, ':p')
                                let s:qpath += ['']
                              else
                                let s:qpath += [getcwd()]
                                execute s:cd fnameescape(a:path)
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#paths#popd() abort " {{{1
                              let l:path = remove(s:qpath, -1)
                              if !empty(l:path)
                                execute s:cd fnameescape(l:path)
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#paths#join(root, tail) abort " {{{1
                              return vimtex#paths#s(a:root . '/' . a:tail)
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#paths#s(path) abort " {{{1
                              " Use backslash on Windows
                              return simplify(vimtex#util#is_win()
                                    \ ? tr(a:path, '/', '\')
                                    \ : a:path)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#paths#is_abs(path) abort " {{{1
                              return a:path =~# s:re_abs
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#paths#shorten_relative(path) abort " {{{1
                              " Input: An absolute path
                              " Output: Relative path with respect to the VimTeX root, path relative to
                              "         VimTeX root (unless absolute path is shorter)
                            
                              let l:relative = vimtex#paths#relative(a:path, b:vimtex.root)
                              return strlen(l:relative) < strlen(a:path)
                                    \ ? l:relative : a:path
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#paths#relative(path, current) abort " {{{1
                              " Note: This algorithm is based on the one presented by @Offirmo at SO,
                              "       http://stackoverflow.com/a/12498485/51634
                            
                              let l:target = simplify(substitute(a:path, '\\', '/', 'g'))
                              let l:common = simplify(substitute(a:current, '\\', '/', 'g'))
                            
                              " This only works on absolute paths
                              if !vimtex#paths#is_abs(l:target)
                                return substitute(a:path, '^\.\/', '', '')
                              endif
                            
                              let l:tries = 50
                              let l:result = ''
                              while stridx(l:target, l:common) != 0 && l:tries > 0
                                let l:common = fnamemodify(l:common, ':h')
                                let l:result = empty(l:result) ? '..' : '../' . l:result
                                let l:tries -= 1
                              endwhile
                            
                              if l:tries == 0 | return a:path | endif
                            
                              if l:common ==# '/'
                                let l:result .= '/'
                              endif
                            
                              let l:forward = strpart(l:target, strlen(l:common))
                              if !empty(l:forward)
                                let l:result = empty(l:result)
                                      \ ? l:forward[1:]
                                      \ : l:result . l:forward
                              endif
                            
                              return l:result
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000007 let s:cd = haslocaldir()
                                  \ ? 'lcd'
                                  \ : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'
    1              0.000003 let s:qpath = get(s:, 'qpath', [])
                            
    1              0.000005 let s:re_abs = has('win32') ? '^\a:[\\/]' : '^/'

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/state.vim
Sourced 1 time
Total time:   0.000304
 Self time:   0.000304

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#state#init_buffer() abort " {{{1
                              command! -buffer VimtexToggleMain  call vimtex#state#toggle_main()
                              command! -buffer VimtexReloadState call vimtex#state#reload()
                            
                              nnoremap <buffer> <plug>(vimtex-toggle-main)  :VimtexToggleMain<cr>
                              nnoremap <buffer> <plug>(vimtex-reload-state) :VimtexReloadState<cr>
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#state#init() abort " {{{1
                              let [l:main, l:main_parser, l:unsupported_modules] = s:get_main()
                              let l:id = s:get_main_id(l:main)
                            
                              if l:id >= 0
                                let b:vimtex_id = l:id
                                let b:vimtex = s:vimtex_states[l:id]
                              else
                                let b:vimtex_id = s:vimtex_next_id
                                let b:vimtex = vimtex#state#class#new({
                                      \ 'main': l:main,
                                      \ 'main_parser': l:main_parser,
                                      \ 'unsupported_modules': l:unsupported_modules
                                      \})
                                let s:vimtex_next_id += 1
                                let s:vimtex_states[b:vimtex_id] = b:vimtex
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#state#init_local() abort " {{{1
                              let l:preserve_root = get(s:, 'subfile_preserve_root')
                              unlet! s:subfile_preserve_root
                            
                              if &filetype !=# 'tex' || empty(b:vimtex.tex) | return | endif
                            
                              let l:filename = expand('%:p')
                              if b:vimtex.tex ==# l:filename | return | endif
                            
                              let l:vimtex_id = s:get_main_id(l:filename)
                            
                              if l:vimtex_id < 0
                                let l:vimtex_id = s:vimtex_next_id
                                let l:vimtex = vimtex#state#class#new({
                                      \ 'main': l:filename,
                                      \ 'main_parser': 'local file',
                                      \ 'preserve_root': l:preserve_root || s:check_standalone(),
                                      \})
                                let s:vimtex_next_id += 1
                                let s:vimtex_states[l:vimtex_id] = l:vimtex
                            
                                if !has_key(b:vimtex, 'subids')
                                  let b:vimtex.subids = []
                                endif
                                call add(b:vimtex.subids, l:vimtex_id)
                                let l:vimtex.main_id = b:vimtex_id
                              endif
                            
                              let b:vimtex_local = {
                                    \ 'active' : 0,
                                    \ 'main_id' : b:vimtex_id,
                                    \ 'sub_id' : l:vimtex_id,
                                    \}
                            
                              if b:vimtex.main_parser ==# 'subfiles' && g:vimtex_subfile_start_local
                                silent call vimtex#state#toggle_main()
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#state#reload() abort " {{{1
                              let l:id = s:get_main_id(expand('%:p'))
                              if has_key(s:vimtex_states, l:id)
                                let l:vimtex = remove(s:vimtex_states, l:id)
                                call l:vimtex.cleanup()
                              endif
                            
                              if has_key(s:vimtex_states, get(b:, 'vimtex_id', -1))
                                let l:vimtex = remove(s:vimtex_states, b:vimtex_id)
                                call l:vimtex.cleanup()
                              endif
                            
                              call vimtex#state#init()
                              call vimtex#state#init_local()
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#state#toggle_main() abort " {{{1
                              if exists('b:vimtex_local')
                                let b:vimtex_local.active = !b:vimtex_local.active
                            
                                let b:vimtex_id = b:vimtex_local.active
                                      \ ? b:vimtex_local.sub_id
                                      \ : b:vimtex_local.main_id
                                let b:vimtex = vimtex#state#get(b:vimtex_id)
                            
                                call vimtex#log#info('Changed to `' . b:vimtex.base . "' "
                                      \ . (b:vimtex_local.active ? '[local]' : '[main]'))
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#state#list_all() abort " {{{1
                              return values(s:vimtex_states)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#state#exists(id) abort " {{{1
                              return has_key(s:vimtex_states, a:id)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#state#get(id) abort " {{{1
                              return s:vimtex_states[a:id]
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#state#get_all() abort " {{{1
                              return s:vimtex_states
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#state#cleanup(id) abort " {{{1
                              if !vimtex#state#exists(a:id) | return | endif
                            
                              "
                              " Count the number of open buffers for the given blob
                              "
                              let l:buffers = filter(range(1, bufnr('$')), 'buflisted(v:val)')
                              let l:ids = map(l:buffers, "getbufvar(v:val, 'vimtex_id', -1)")
                              let l:count = count(l:ids, a:id)
                            
                              "
                              " Don't clean up if there are more than one buffer connected to the current
                              " blob
                              "
                              if l:count > 1 | return | endif
                              let l:vimtex = vimtex#state#get(a:id)
                            
                              "
                              " Handle possible subfiles properly
                              "
                              if has_key(l:vimtex, 'subids')
                                let l:subcount = 0
                                for l:sub_id in get(l:vimtex, 'subids', [])
                                  let l:subcount += count(l:ids, l:sub_id)
                                endfor
                                if l:count + l:subcount > 1 | return | endif
                            
                                for l:sub_id in get(l:vimtex, 'subids', [])
                                  call remove(s:vimtex_states, l:sub_id).cleanup()
                                endfor
                            
                                call remove(s:vimtex_states, a:id).cleanup()
                              else
                                call remove(s:vimtex_states, a:id).cleanup()
                            
                                if has_key(l:vimtex, 'main_id')
                                  let l:main = vimtex#state#get(l:vimtex.main_id)
                            
                                  let l:count_main = count(l:ids, l:vimtex.main_id)
                                  for l:sub_id in get(l:main, 'subids', [])
                                    let l:count_main += count(l:ids, l:sub_id)
                                  endfor
                            
                                  if l:count_main + l:count <= 1
                                    call remove(s:vimtex_states, l:vimtex.main_id).cleanup()
                                  endif
                                endif
                              endif
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:get_main_id(main) abort " {{{1
                              for [l:id, l:state] in items(s:vimtex_states)
                                if l:state.tex == a:main
                                  return str2nr(l:id)
                                endif
                              endfor
                            
                              return -1
                            endfunction
                            
    1              0.000001 function! s:get_main() abort " {{{1
                              " Use buffer variable if it exists
                              if exists('b:vimtex_main') && filereadable(b:vimtex_main)
                                return [fnamemodify(b:vimtex_main, ':p'), 'buffer variable', []]
                              endif
                            
                              " Search for TEX root specifier at the beginning of file. This is used by
                              " several other plugins and editors.
                              let l:candidate = s:get_main_from_texroot()
                              if !empty(l:candidate)
                                return [l:candidate, 'texroot specifier', []]
                              endif
                            
                              if &filetype ==# 'tex'
                                " Check if the current file is a main file
                                if s:file_is_main(expand('%:p'))
                                  return [expand('%:p'), 'current file verified', []]
                                endif
                            
                                " Support for subfiles package
                                let l:candidate = s:get_main_from_subfile()
                                if !empty(l:candidate)
                                  return [l:candidate, 'subfiles', []]
                                endif
                              endif
                            
                              " Search for .latexmain-specifier
                              let l:candidate = s:get_main_latexmain(expand('%:p'))
                              if !empty(l:candidate)
                                return [l:candidate, 'latexmain specifier', []]
                              endif
                            
                              " Search for .latexmkrc @default_files specifier
                              let l:candidate = s:get_main_latexmk()
                              if !empty(l:candidate)
                                return [l:candidate, 'latexmkrc @default_files', []]
                              endif
                            
                              " Check if we are class or style file
                              if index(['cls', 'sty'], expand('%:e')) >= 0
                                let l:id = getbufvar('#', 'vimtex_id', -1)
                                if l:id >= 0 && has_key(s:vimtex_states, l:id)
                                  return [
                                        \ s:vimtex_states[l:id].tex,
                                        \ 'cls/sty file (inherit from alternate)',
                                        \ []
                                        \]
                                else
                                  return [
                                        \ expand('%:p'),
                                        \ 'cls/sty file',
                                        \ ['compiler', 'view', 'toc', 'qf']
                                        \]
                                endif
                              endif
                            
                              " Search for main file recursively through include specifiers
                              if &filetype ==# 'tex'
                                let l:candidate = s:get_main_choose(s:get_main_recurse())
                                if !empty(l:candidate)
                                  return [l:candidate, 'recursive search', []]
                                endif
                              else
                                let l:candidate = s:get_main_choose(s:get_main_recurse_from_bib())
                                if !empty(l:candidate)
                                  return [l:candidate, 'recursive search (bib)', []]
                                endif
                              endif
                            
                              " Fallbacks:
                              " 1.  fallback candidate from get_main_latexmain
                              " 2. a. tex: current file
                              "    b. bib: check alternate file or current
                              if exists('s:cand_fallback')
                                let l:candidate = s:cand_fallback
                                unlet s:cand_fallback
                                return [l:candidate, 'fallback', []]
                              elseif &filetype ==# 'bib'
                                let l:id = getbufvar('#', 'vimtex_id', -1)
                                if l:id >= 0 && has_key(s:vimtex_states, l:id)
                                  return [
                                        \ s:vimtex_states[l:id].tex,
                                        \ 'bib file (inherit from alternate)',
                                        \ []
                                        \]
                                else
                                  return [
                                        \ expand('%:p'),
                                        \ 'bib file',
                                        \ ['compiler', 'view', 'toc', 'qf', 'fold']
                                        \]
                                endif
                              else
                                return [expand('%:p'), 'fallback current file', []]
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_main_from_texroot() abort " {{{1
                              for l:line in getline(1, 5)
                                let l:file_pattern = matchstr(l:line, g:vimtex#re#tex_input_root)
                                if empty(l:file_pattern) | continue | endif
                            
                                if !vimtex#paths#is_abs(l:file_pattern)
                                  let l:file_pattern = simplify(expand('%:p:h') . '/' . l:file_pattern)
                                endif
                            
                                let l:candidates = glob(l:file_pattern, 0, 1)
                                if len(l:candidates) > 1
                                  return s:get_main_choose(l:candidates)
                                elseif len(l:candidates) == 1
                                  return l:candidates[0]
                                endif
                              endfor
                            
                              return ''
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_main_from_subfile() abort " {{{1
                              for l:line in getline(1, 5)
                                let l:filename = matchstr(l:line,
                                      \ '^\C\s*\\documentclass\[\zs.*\ze\]{subfiles}')
                                if len(l:filename) > 0
                                  if l:filename !~# '\.tex$'
                                    let l:filename .= '.tex'
                                  endif
                            
                                  if vimtex#paths#is_abs(l:filename)
                                    " Specified path is absolute
                                    if filereadable(l:filename) | return l:filename | endif
                                  else
                                    " Try specified path as relative to current file path
                                    let l:candidate = simplify(expand('%:p:h') . '/' . l:filename)
                                    if filereadable(l:candidate) | return l:candidate | endif
                            
                                    " Try specified path as relative to the project main file. This is
                                    " difficult, since the main file is the one we are looking for. We
                                    " therefore assume that the main file lives somewhere upwards in the
                                    " directory tree.
                                    let l:candidate = fnamemodify(findfile(l:filename, '.;'), ':p')
                                    if filereadable(l:candidate)
                                          \ && s:file_reaches_current(l:candidate)
                                      let s:subfile_preserve_root = 1
                                      return fnamemodify(candidate, ':p')
                                    endif
                            
                                    " Check the alternate buffer. This seems sensible e.g. in cases where one
                                    " enters an "outer" subfile through a 'gf' motion from the main file.
                                    let l:vimtex = getbufvar('#', 'vimtex', {})
                                    for l:file in get(l:vimtex, 'sources', [])
                                      if expand('%:p') ==# simplify(l:vimtex.root . '/' . l:file)
                                        let s:subfile_preserve_root = 1
                                        return l:vimtex.tex
                                      endif
                                    endfor
                                  endif
                                endif
                              endfor
                            
                              return ''
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_main_latexmain(file) abort " {{{1
                              for l:cand in s:globpath_upwards('*.latexmain', expand('%:p:h'))
                                let l:cand = fnamemodify(l:cand, ':p:r')
                                if s:file_reaches_current(l:cand)
                                  return l:cand
                                else
                                  let s:cand_fallback = l:cand
                                endif
                              endfor
                            
                              return ''
                            endfunction
                            
    1              0.000001 function! s:get_main_latexmk() abort " {{{1
                              let l:root = expand('%:p:h')
                              let l:results = vimtex#compiler#latexmk#get_rc_opt(
                                    \ l:root, 'default_files', 2, [])
                              if l:results[1] < 1 | return '' | endif
                            
                              for l:candidate in l:results[0]
                                let l:file = l:root . '/' . l:candidate
                                if filereadable(l:file)
                                  return l:file
                                endif
                              endfor
                            
                              return ''
                            endfunction
                            
    1              0.000002 function! s:get_main_recurse(...) abort " {{{1
                              " Either start the search from the original file, or check if the supplied
                              " file is a main file (or invalid)
                              if a:0 == 0
                                let l:file = expand('%:p')
                                let l:tried = {}
                              else
                                let l:file = a:1
                                let l:tried = a:2
                            
                                if s:file_is_main(l:file)
                                  return [l:file]
                                elseif !filereadable(l:file)
                                  return []
                                endif
                              endif
                            
                              " Create list of candidates that was already tried for the current file
                              if !has_key(l:tried, l:file)
                                let l:tried[l:file] = [l:file]
                              endif
                            
                              " Apply filters successively (minor optimization)
                              let l:re_filter1 = fnamemodify(l:file, ':t:r')
                              let l:re_filter2 = g:vimtex#re#tex_input . '\s*\f*' . l:re_filter1
                            
                              " Search through candidates found upwards in the directory tree
                              let l:results = []
                              for l:cand in s:globpath_upwards('*.tex', fnamemodify(l:file, ':p:h'))
                                if index(l:tried[l:file], l:cand) >= 0 | continue | endif
                                call add(l:tried[l:file], l:cand)
                            
                                if len(filter(filter(readfile(l:cand),
                                      \ 'v:val =~# l:re_filter1'),
                                      \ 'v:val =~# l:re_filter2')) > 0
                                  let l:results += s:get_main_recurse(fnamemodify(l:cand, ':p'), l:tried)
                                endif
                              endfor
                            
                              return l:results
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_main_recurse_from_bib() abort " {{{1
                              let l:file = expand('%:p')
                              let l:tried = {}
                              let l:tried[l:file] = [l:file]
                            
                              " Apply filters successively (minor optimization)
                              let l:re_filter1 = fnamemodify(l:file, ':t:r')
                              let l:re_filter2 = g:vimtex#re#bib_input . '\s*\f*' . l:re_filter1
                            
                              " Search through candidates found upwards in the directory tree
                              let l:results = []
                              for l:cand in s:globpath_upwards('*.tex', fnamemodify(l:file, ':p:h'))
                                if index(l:tried[l:file], l:cand) >= 0 | continue | endif
                                call add(l:tried[l:file], l:cand)
                            
                                if len(filter(filter(readfile(l:cand),
                                      \ 'v:val =~# l:re_filter1'),
                                      \ 'v:val =~# l:re_filter2')) > 0
                                  let l:results += s:get_main_recurse(fnamemodify(l:cand, ':p'), l:tried)
                                endif
                              endfor
                            
                              return l:results
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_main_choose(list) abort " {{{1
                              let l:list = vimtex#util#uniq_unsorted(a:list)
                            
                              if empty(l:list) | return '' | endif
                              if len(l:list) == 1 | return l:list[0] | endif
                            
                              let l:all = map(copy(l:list), {_, x -> [s:get_main_id(x), x]})
                              let l:new = map(filter(copy(l:all), 'v:val[0] < 0'), 'v:val[1]')
                              let l:existing = {}
                              for [l:key, l:val] in filter(copy(l:all), 'v:val[0] >= 0')
                                let l:existing[l:key] = l:val
                              endfor
                              let l:alternate_id = getbufvar('#', 'vimtex_id', -1)
                            
                              if len(l:existing) == 1
                                return values(l:existing)[0]
                              elseif len(l:existing) > 1 && has_key(l:existing, l:alternate_id)
                                return l:existing[l:alternate_id]
                              elseif len(l:existing) < 1 && len(l:new) == 1
                                return l:new[0]
                              else
                                let l:choices = {}
                                for l:tex in l:list
                                  let l:choices[l:tex] = vimtex#paths#relative(l:tex, getcwd())
                                endfor
                            
                                unsilent return vimtex#ui#select(l:choices, {
                                      \ 'prompt': 'Please select an appropriate main file:',
                                      \ 'return': 'key',
                                      \ 'force_choice': v:true,
                                      \})
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:file_is_main(file) abort " {{{1
                              if !filereadable(a:file) | return 0 | endif
                            
                              let l:preamble = vimtex#parser#preamble(a:file, {
                                    \ 'root' : fnamemodify(a:file, ':p:h'),
                                    \})
                            
                              " Check if a:file is a main file by looking for the \documentclass command,
                              " but ignore the following:
                              " * \documentclass[...]{subfiles}
                              " * \documentclass[...]{standalone}
                              let l:lines = copy(l:preamble)
                              call filter(l:lines, 'v:val =~# ''^\s*\\documentclass\_\s*[\[{]''')
                              call filter(l:lines, 'v:val !~# ''{subfiles}''')
                              call filter(l:lines, 'v:val !~# ''{standalone}''')
                              if len(l:lines) == 0 | return 0 | endif
                            
                              " A main file must also contain `\begin{document}`
                              let l:lines = copy(l:preamble)
                              call filter(l:lines, 'v:val =~# ''^\s*\\begin\s*{document}''')
                              return len(l:lines) > 0
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:file_reaches_current(file, ...) abort " {{{1
                              let l:visited = a:0 > 0 ? a:1 : []
                            
                              " Note: This function assumes that the input a:file is an absolute path
                              if !filereadable(a:file) | return 0 | endif
                            
                              if index(l:visited, a:file) >= 0 | return 0 | endif
                              call add(l:visited, a:file)
                            
                              for l:line in filter(readfile(a:file), 'v:val =~# g:vimtex#re#tex_input')
                                let l:file = vimtex#parser#tex#input_parser(l:line, a:file, '')
                                if empty(l:file) | continue | endif
                            
                                if !vimtex#paths#is_abs(l:file)
                                  let l:file = fnamemodify(a:file, ':h') . '/' . l:file
                                endif
                            
                                if l:file !~# '\.tex$'
                                  let l:file .= '.tex'
                                endif
                            
                                if expand('%:p') ==# l:file || s:file_reaches_current(l:file, l:visited)
                                  return 1
                                endif
                              endfor
                            
                              return 0
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:globpath_upwards(expr, path) abort " {{{1
                              " Returns the list of files (NOT directories) obtained by globpath(p, a:expr)
                              " with p going from a:path and upwards in the directory tree.
                              let l:path = a:path
                              let l:dirs = l:path
                              while l:path != fnamemodify(l:path, ':h')
                                let l:path = fnamemodify(l:path, ':h')
                                let l:dirs .= ',' . l:path
                              endwhile
                              return filter(
                                    \ split(globpath(fnameescape(l:dirs), a:expr), '\n'),
                                    \ 'filereadable(v:val)')
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! s:check_standalone() abort " {{{1
                              return match(getline(1, 5),
                                    \      '\v^\C\s*\\documentclass%(\[.*\])?\{standalone\}') >= 0
                            endfunction
                            
                            " }}}1
                            
                            
                            " Initialize module
    1              0.000002 let s:vimtex_states = {}
    1              0.000002 let s:vimtex_next_id = 0

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/re.vim
Sourced 1 time
Total time:   0.000210
 Self time:   0.000210

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000003 let g:vimtex#re#not_bslash =  '\v%(\\@<!%(\\\\)*)@<='
    1              0.000003 let g:vimtex#re#not_comment = '\v%(' . g:vimtex#re#not_bslash . '\%.*)@<!'
                            
    1              0.000003 let g:vimtex#re#tex_input_root =
                                  \ '\v^\c\s*\%\s*!?\s*tex\s+root\s*[=:]\s*\zs.*\ze\s*$'
    1              0.000011 let g:vimtex#re#tex_input_latex = '\v\\%('
                                  \ . join(get(g:, 'vimtex_include_indicators',
                                  \            ['input', 'include', 'includeonly']),
                                  \        '|')
                                  \ . ')\s*\{'
    1              0.000005 let g:vimtex#re#tex_input_import = '\v\\%('
                                  \ . 'subfile%(include)?'
                                  \ . '|'
                                  \ . '%(sub)?%(import|%(input|include)from)\*?\{[^\}]*\}'
                                  \ . ')\s*\{'
    1              0.000003 let g:vimtex#re#tex_input_package =
                                  \ '\v\\%(usepackage|RequirePackage)%(\s*\[[^]]*\])?\s*\{\zs[^}]*\ze\}'
                            
    1              0.000008 let g:vimtex#re#tex_input = '\v^\s*\zs%(' . join([
                                  \   g:vimtex#re#tex_input_latex,
                                  \   g:vimtex#re#tex_input_import,
                                  \ ], '|') . ')'
                            
    1              0.000002 let g:vimtex#re#bib_input = '\v^\s*\zs\\%(addbibresource|bibliography)\s*\{'
                            
    1              0.000007 let g:vimtex#re#tex_include = g:vimtex#re#tex_input_root
                                  \ . '|' . g:vimtex#re#tex_input . '\zs[^\}]*\ze\}?'
                                  \ . '|' . g:vimtex#re#tex_input_package
                            
                            " {{{1 Completion regexes
    1              0.000041 let g:vimtex#re#neocomplete =
                                  \ '\v\\%('
                                  \ .  '%(\a*cite|Cite)\a*\*?%(\s*\[[^]]*\]){0,2}\s*\{[^}]*'
                                  \ . '|%(\a*cites|Cites)%(\s*\([^)]*\)){0,2}'
                                  \     . '%(%(\s*\[[^]]*\]){0,2}\s*\{[^}]*\})*'
                                  \     . '%(\s*\[[^]]*\]){0,2}\s*\{[^}]*'
                                  \ . '|bibentry\s*\{[^}]*'
                                  \ . '|%(text|block)cquote\*?%(\s*\[[^]]*\]){0,2}\s*\{[^}]*'
                                  \ . '|%(for|hy)\w*cquote\*?\{[^}]*}%(\s*\[[^]]*\]){0,2}\s*\{[^}]*'
                                  \ . '|defbibentryset\{[^}]*}\{[^}]*'
                                  \ . '|\a*ref%(\s*\{[^}]*|range\s*\{[^,}]*%(}\{)?)'
                                  \ . '|hyperref\s*\[[^]]*'
                                  \ . '|includegraphics\*?%(\s*\[[^]]*\]){0,2}\s*\{[^}]*'
                                  \ . '|%(include%(only)?|input|subfile)\s*\{[^}]*'
                                  \ . '|([cpdr]?(gls|Gls|GLS)|acr|Acr|ACR)\a*\s*\{[^}]*'
                                  \ . '|(ac|Ac|AC)\s*\{[^}]*'
                                  \ . '|includepdf%(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|includestandalone%(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|%(usepackage|RequirePackage|PassOptionsToPackage)%(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|documentclass%(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|begin%(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|end%(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|\a*'
                                  \ . ')'
                            
    1              0.000040 let g:vimtex#re#deoplete = '\\(?:'
                                  \ .  '(?:\w*cite|Cite)\w*\*?(?:\s*\[[^]]*\]){0,2}\s*{[^}]*'
                                  \ . '|(?:\w*cites|Cites)(?:\s*\([^)]*\)){0,2}'
                                  \     . '(?:(?:\s*\[[^]]*\]){0,2}\s*\{[^}]*\})*'
                                  \     . '(?:\s*\[[^]]*\]){0,2}\s*\{[^}]*'
                                  \ . '|bibentry\s*{[^}]*'
                                  \ . '|(text|block)cquote\*?(?:\s*\[[^]]*\]){0,2}\s*{[^}]*'
                                  \ . '|(for|hy)\w*cquote\*?{[^}]*}(?:\s*\[[^]]*\]){0,2}\s*{[^}]*'
                                  \ . '|defbibentryset{[^}]*}{[^}]*'
                                  \ . '|\w*ref(?:\s*\{[^}]*|range\s*\{[^,}]*(?:}{)?)'
                                  \ . '|hyperref\s*\[[^]]*'
                                  \ . '|includegraphics\*?(?:\s*\[[^]]*\]){0,2}\s*\{[^}]*'
                                  \ . '|(?:include(?:only)?|input|subfile)\s*\{[^}]*'
                                  \ . '|([cpdr]?(gls|Gls|GLS)|acr|Acr|ACR)[a-zA-Z]*\s*\{[^}]*'
                                  \ . '|(ac|Ac|AC)\s*\{[^}]*'
                                  \ . '|includepdf(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|includestandalone(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|(usepackage|RequirePackage|PassOptionsToPackage)(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|documentclass(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|begin(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|end(\s*\[[^]]*\])?\s*\{[^}]*'
                                  \ . '|\w*'
                                  \ .')'
                            
    1              0.000008 let g:vimtex#re#ncm2#cmds = [
                                  \ '\\[A-Za-z]+',
                                  \ '\\(usepackage|RequirePackage|PassOptionsToPackage)(\s*\[[^]]*\])?\s*\{[^}]*',
                                  \ '\\documentclass(\s*\[[^]]*\])?\s*\{[^}]*',
                                  \ '\\begin(\s*\[[^]]*\])?\s*\{[^}]*',
                                  \ '\\end(\s*\[[^]]*\])?\s*\{[^}]*',
                                  \]
    1              0.000013 let g:vimtex#re#ncm2#bibtex = [
                                  \ '\\([A-Za-z]*cite|Cite)[A-Za-z]*\*?(\[[^]]*\]){0,2}{[^}]*',
                                  \ '\\([A-Za-z]*cites|Cites)(\s*\([^)]*\)){0,2}'
                                  \     . '((\s*\[[^]]*\]){0,2}\s*\{[^}]*\})*'
                                  \     . '(\s*\[[^]]*\]){0,2}\s*\{[^}]*',
                                  \ '\\bibentry\s*{[^}]*',
                                  \ '\\(text|block)cquote\*?(\[[^]]*\]){0,2}{[^}]*',
                                  \ '\\(for|hy)[A-Za-z]*cquote\*?{[^}]*}(\[[^]]*\]){0,2}{[^}]*',
                                  \ '\\defbibentryset{[^}]*}{[^}]*',
                                  \]
    1              0.000006 let g:vimtex#re#ncm2#labels = [
                                  \ '\\[A-Za-z]*ref({[^}]*|range{([^,{}]*(}{)?))',
                                  \ '\\hyperref\[[^]]*',
                                  \ '\\([cpdr]?(gls|Gls|GLS)|acr|Acr|ACR)[a-zA-Z]*\s*\{[^}]*',
                                  \ '\\(ac|Ac|AC)\s*\{[^}]*',
                                  \]
    1              0.000006 let g:vimtex#re#ncm2#files = [
                                  \ '\\includegraphics\*?(\[[^]]*\]){0,2}{[^}]*',
                                  \ '\\(include(only)?|input|subfile){[^}]*',
                                  \ '\\includepdf(\s*\[[^]]*\])?\s*\{[^}]*',
                                  \ '\\includestandalone(\s*\[[^]]*\])?\s*\{[^}]*',
                                  \]
                            
    1              0.000012 let g:vimtex#re#ncm2 = g:vimtex#re#ncm2#cmds +
                                        \ g:vimtex#re#ncm2#bibtex +
                                        \ g:vimtex#re#ncm2#labels +
                                        \ g:vimtex#re#ncm2#files
                            
    1              0.000005 let g:vimtex#re#ncm = copy(g:vimtex#re#ncm2)
                            
    1              0.000021 let g:vimtex#re#youcompleteme = map(copy(g:vimtex#re#ncm), "'re!' . v:val")
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/parser.vim
Sourced 1 time
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#parser#tex(file, ...) abort " {{{1
                              return vimtex#parser#tex#parse(a:file, a:0 > 0 ? a:1 : {})
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#parser#preamble(file, ...) abort " {{{1
                              " This will return the list of lines of the current project from the
                              " beginning of the preamble until and including the `\begin{document}`
                              return vimtex#parser#tex#parse_preamble(a:file, a:0 > 0 ? a:1 : {})
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#parser#auxiliary(file) abort " {{{1
                              return vimtex#parser#auxiliary#parse(a:file)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#parser#fls(file) abort " {{{1
                              return vimtex#parser#fls#parse(a:file)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#parser#toc(...) abort " {{{1
                              let l:vimtex = a:0 > 0 ? a:1 : b:vimtex
                            
                              let l:cache = vimtex#cache#open('parser_toc', {
                                    \ 'persistent': v:false,
                                    \ 'default': {'entries': [], 'ftime': -1},
                                    \})
                              let l:current = l:cache.get(l:vimtex.tex)
                            
                              " Update cache if relevant
                              let l:ftime = l:vimtex.getftime()
                              if l:ftime > l:current.ftime
                                let l:current.ftime = l:ftime
                                let l:current.entries = vimtex#parser#toc#parse(l:vimtex.tex)
                              endif
                            
                              return deepcopy(l:current.entries)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#parser#bib(file, ...) abort " {{{1
                              return vimtex#parser#bib#parse(a:file, a:0 > 0 ? a:1 : {})
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#parser#get_externalfiles() abort " {{{1
                              let l:preamble = vimtex#parser#preamble(b:vimtex.tex)
                            
                              let l:result = []
                              for l:line in filter(l:preamble, 'v:val =~# ''\\externaldocument''')
                                let l:name = matchstr(l:line, '{\zs[^}]*\ze}')
                                call add(l:result, {
                                      \ 'tex' : l:name . '.tex',
                                      \ 'aux' : l:name . '.aux',
                                      \ 'opt' : matchstr(l:line, '\[\zs[^]]*\ze\]'),
                                      \ })
                              endfor
                            
                              return l:result
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#parser#selection_to_texfile(opts) range abort " {{{1
                              let l:opts = extend({
                                    \ 'type': 'range',
                                    \ 'range': [0, 0],
                                    \ 'name': b:vimtex.name . '_vimtex_selected',
                                    \ 'template_name': 'vimtex-template.tex',
                                    \}, a:opts)
                            
                              " Set range from selection type
                              if l:opts.type ==# 'command'
                                let l:opts.range = [a:firstline, a:lastline]
                              elseif l:opts.type ==# 'visual'
                                let l:opts.range = [line("'<"), line("'>")]
                              elseif l:opts.type ==# 'operator'
                                let l:opts.range = [line("'["), line("']")]
                              endif
                            
                              let l:lines = getline(l:opts.range[0], l:opts.range[1])
                            
                              " Restrict the selection to whatever is within the \begin{document} ...
                              " \end{document} environment
                              let l:start = 0
                              let l:end = len(l:lines)
                              for l:n in range(len(l:lines))
                                if l:lines[l:n] =~# '\\begin\s*{document}'
                                  let l:start = l:n + 1
                                elseif l:lines[l:n] =~# '\\end\s*{document}'
                                  let l:end = l:n - 1
                                  break
                                endif
                              endfor
                            
                              " Check if the selection has any real content
                              if l:start >= len(l:lines)
                                    \ || l:end < 0
                                    \ || empty(substitute(join(l:lines[l:start : l:end], ''), '\s*', '', ''))
                                return {}
                              endif
                              let l:lines = l:lines[l:start : l:end]
                            
                              " Load template (if available)
                              let l:template = []
                              for l:template_file in [
                                    \ expand('%:r') . '-' . l:opts.template_name,
                                    \ l:opts.template_name,
                                    \]
                                if filereadable(l:template_file)
                                  let l:template = readfile(l:template_file)
                                  break
                                endif
                              endfor
                            
                              " Define the set of lines to compile
                              if !empty(l:template)
                                let l:i = index(l:template, '%%% VIMTEX PLACEHOLDER')
                                let l:lines = l:template[:l:i-1] + l:lines + l:template[l:i+1:]
                              else
                                let l:lines = vimtex#parser#preamble(b:vimtex.tex)
                                      \ + l:lines
                                      \ + ['\end{document}']
                              endif
                            
                              " Respect the compiler out_dir option
                              if empty(b:vimtex.compiler.out_dir)
                                let l:out_dir = b:vimtex.root
                              else
                                let l:out_dir = vimtex#paths#is_abs(b:vimtex.compiler.out_dir)
                                      \ ? b:vimtex.compiler.out_dir
                                      \ : b:vimtex.root . '/' . b:vimtex.compiler.out_dir
                              endif
                            
                              " Write content to temporary file
                              let l:file = {}
                              let l:file.base = l:opts.name
                              let l:file.root = l:out_dir
                              let l:file.tex = l:out_dir . '/' . l:file.base . '.tex'
                              let l:file.pdf = l:out_dir . '/' . l:file.base . '.pdf'
                              let l:file.log = l:out_dir . '/' . l:file.base . '.log'
                              let l:file.base .= '.tex'
                              call writefile(l:lines, l:file.tex)
                            
                              return l:file
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/parser/tex.vim
Sourced 1 time
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#parser#tex#parse(file, opts) abort " {{{1
                              let l:opts = extend({
                                    \ 'detailed': 1,
                                    \ 'root' : exists('b:vimtex.root') ? b:vimtex.root : '',
                                    \}, a:opts)
                            
                              let l:cache = vimtex#cache#open('parser_tex', {
                                    \ 'local': 1,
                                    \ 'persistent': v:false,
                                    \ 'default': {'ftime': -2},
                                    \})
                            
                              let l:parsed = s:parse(a:file, l:opts, l:cache)
                            
                              if !l:opts.detailed
                                call map(l:parsed, 'v:val[2]')
                              endif
                            
                              return l:parsed
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#parser#tex#parse_files(file, opts) abort " {{{1
                              let l:opts = extend({
                                    \ 'root' : exists('b:vimtex.root') ? b:vimtex.root : '',
                                    \}, a:opts)
                            
                              let l:cache = vimtex#cache#open('parser_tex', {
                                    \ 'local': 1,
                                    \ 'persistent': v:false,
                                    \ 'default': {'ftime': -2},
                                    \})
                            
                              return vimtex#util#uniq_unsorted(
                                    \ s:parse_files(a:file, l:opts, l:cache))
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#parser#tex#parse_preamble(file, opts) abort " {{{1
                              let l:opts = extend({
                                      \ 'root': exists('b:vimtex.root') ? b:vimtex.root : '',
                                      \}, a:opts)
                            
                              let l:cache = vimtex#cache#open('parser_preamble', {
                                    \ 'persistent': v:false,
                                    \ 'default': {'time': -2},
                                    \})
                              let l:current = l:cache.get(a:file)
                            
                              let l:time = min([localtime() - 60, getftime(a:file)])
                              if l:time > l:current.time
                                let l:current.time = l:time
                                let l:current.lines = s:parse_preamble(a:file, l:opts, [])
                              endif
                            
                              return deepcopy(l:current.lines)
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#parser#tex#texorpdfstring(title) abort " {{{1
                              " \texorpdfstring{TEXstring}{PDFstring} -> TEXstring
                            
                              let l:i1 = match(a:title, '\\texorpdfstring')
                              if l:i1 < 0 | return a:title | endif
                            
                              " Find start of included part
                              let l:i2 = match(a:title, '{', l:i1+1)
                              if l:i2 < 0 | return a:title | endif
                            
                              " Find end of included part
                              let [l:i3, l:dummy] = vimtex#parser#tex#find_closing(l:i2+1, a:title, 1, '{')
                              if l:i3 < 0 | return a:title | endif
                            
                              " Find start, then end of excluded part
                              let l:i4 = match(a:title, '{', l:i3+1)
                              if l:i4 < 0 | return a:title | endif
                              let [l:i4, l:dummy] = vimtex#parser#tex#find_closing(l:i4+1, a:title, 1, '{')
                            
                              return strpart(a:title, 0, l:i1)
                                    \ . strpart(a:title, l:i2+1, l:i3-l:i2-1)
                                    \ . vimtex#parser#tex#texorpdfstring(strpart(a:title, l:i4+1))
                            endfunction
                            
                            " }}}1
    1              0.000003 function! vimtex#parser#tex#find_closing(start, string, count, type) abort " {{{1
                              if a:type ==# '{'
                                let l:re = '{\|}'
                                let l:open = '{'
                              else
                                let l:re = '\[\|\]'
                                let l:open = '['
                              endif
                              let l:i2 = a:start-1
                              let l:count = a:count
                              while l:count > 0
                                let l:i2 = match(a:string, l:re, l:i2+1)
                                if l:i2 < 0 | break | endif
                            
                                if a:string[l:i2] ==# l:open
                                  let l:count += 1
                                else
                                  let l:count -= 1
                                endif
                              endwhile
                            
                              return [l:i2, l:count]
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#parser#tex#input_parser(line, current_file, root) abort " {{{1
                              " Handle \space commands
                              let l:file = substitute(a:line, '\\space\s*', ' ', 'g')
                            
                              " Handle import and subfile package commands
                              if l:file =~# g:vimtex#re#tex_input_import
                                let l:root = l:file =~# '\\sub'
                                      \ ? fnamemodify(a:current_file, ':p:h')
                                      \ : a:root
                            
                                let l:candidate = s:input_to_filename(
                                      \ substitute(copy(l:file), '\/\?}\s*{', '\/', 'g'), l:root)
                            
                                return !empty(l:candidate)
                                      \ ? l:candidate
                                      \ : s:input_to_filename(
                                      \     substitute(copy(l:file), '{.{-}}', '', ''), l:root)
                              endif
                            
                              return s:input_to_filename(l:file, a:root)
                            endfunction
                            
    1              0.000002 function! s:input_to_filename(input, root) abort " {{{2
                              " Assumption: The input matches g:vimtex#re#tex_input, which means it will
                              " begin with an input line macro, e.g. "  \input{...". We need to extract the
                              " argument part.
                              let l:i0 = match(a:input, '{') + 1
                              let [l:i1, l:_] = vimtex#parser#tex#find_closing(l:i0, a:input, 1, '{')
                              let l:file = strpart(a:input, l:i0, l:i1-l:i0)
                            
                              " Trim whitespaces and quotes from beginning/end of string
                              let l:file = substitute(l:file, '^\(\s\|"\)*', '', '')
                              let l:file = substitute(l:file, '\(\s\|"\)*$', '', '')
                            
                              " Ensure that the file name has extension
                              if empty(fnamemodify(l:file, ':e'))
                                let l:file .= '.tex'
                              endif
                            
                              if vimtex#paths#is_abs(l:file)
                                return l:file
                              endif
                            
                              let l:candidate = a:root . '/' . l:file
                              if filereadable(l:candidate)
                                return l:candidate
                              endif
                            
                              let l:candidate = vimtex#kpsewhich#find(l:file)
                              return filereadable(l:candidate) ? l:candidate : l:file
                            endfunction
                            
                            " }}}2
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:parse(file, opts, cache) abort " {{{1
                              let l:current = a:cache.get(a:file)
                              let l:ftime = getftime(a:file)
                              if l:ftime > l:current.ftime
                                let l:current.ftime = l:ftime
                                call s:parse_current(a:file, a:opts, l:current)
                              endif
                            
                              let l:parsed = []
                            
                              for l:val in l:current.lines
                                if type(l:val) == v:t_list
                                  call add(l:parsed, l:val)
                                else
                                  call extend(l:parsed, s:parse(l:val, a:opts, a:cache))
                                endif
                              endfor
                            
                              return l:parsed
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parse_files(file, opts, cache) abort " {{{1
                              let l:current = a:cache.get(a:file)
                              let l:ftime = getftime(a:file)
                              if l:ftime > l:current.ftime
                                let l:current.ftime = l:ftime
                                call s:parse_current(a:file, a:opts, l:current)
                              endif
                            
                              " Only include existing files
                              if !filereadable(a:file) | return [] | endif
                            
                              let l:files = [a:file]
                              for l:file in l:current.includes
                                let l:files += s:parse_files(l:file, a:opts, a:cache)
                              endfor
                            
                              return l:files
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parse_current(file, opts, current) abort " {{{1
                              let a:current.lines = []
                              let a:current.includes = []
                            
                              " Also load includes from glsentries
                              let l:re_input = g:vimtex#re#tex_input . '|^\s*\\loadglsentries'
                            
                              if filereadable(a:file)
                                let l:lnum = 0
                                for l:line in readfile(a:file)
                                  let l:lnum += 1
                                  call add(a:current.lines, [a:file, l:lnum, l:line])
                            
                                  " Continue if the current line has \input{...} or similar
                                  " Note: The 'stridx' is a minor optimization to avoid running a complex
                                  "       regex on "simple" lines
                                  if stridx(l:line, '\') < 0 || l:line !~# l:re_input
                                    continue
                                  endif
                            
                                  let l:file = vimtex#parser#tex#input_parser(l:line, a:file, a:opts.root)
                                  call add(a:current.lines, l:file)
                            
                                  if a:file ==# l:file
                                    call vimtex#log#error([
                                          \ 'Recursive file inclusion!',
                                          \ 'File: ' . fnamemodify(a:file, ':.'),
                                          \ 'Line ' . l:lnum . ':',
                                          \ l:line,
                                          \])
                                  else
                                    call add(a:current.includes, l:file)
                                  endif
                                endfor
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parse_preamble(file, opts, parsed_files) abort " {{{1
                              if !filereadable(a:file) || index(a:parsed_files, a:file) >= 0
                                return []
                              endif
                              call add(a:parsed_files, a:file)
                            
                              let l:lines = []
                              for l:line in readfile(a:file)
                                if l:line =~# g:vimtex#re#tex_input
                                  let l:file = vimtex#parser#tex#input_parser(l:line, a:file, a:opts.root)
                                  call extend(l:lines, s:parse_preamble(l:file, a:opts, a:parsed_files))
                                else
                                  call add(l:lines, l:line)
                                endif
                            
                                if l:line =~# '\\begin\s*{document}'
                                  break
                                endif
                              endfor
                            
                              return l:lines
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/state/class.vim
Sourced 1 time
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#state#class#new(opts) abort " {{{1
                              let l:opts = extend({
                                    \ 'main': '',
                                    \ 'main_parser': '',
                                    \ 'preserve_root': v:false,
                                    \ 'unsupported_modules': [],
                                    \}, a:opts)
                            
                              let l:new = deepcopy(s:vimtex)
                            
                              let l:new.root = fnamemodify(l:opts.main, ':h')
                              let l:new.base = fnamemodify(l:opts.main, ':t')
                              let l:new.name = fnamemodify(l:opts.main, ':t:r')
                              let l:new.main_parser = l:opts.main_parser
                            
                              if l:opts.preserve_root && exists('b:vimtex')
                                let l:new.root = b:vimtex.root
                                let l:new.base = vimtex#paths#relative(l:opts.main, l:new.root)
                              endif
                            
                              let l:ext = fnamemodify(l:opts.main, ':e')
                              let l:new.tex = l:ext =~? '\v^%(%(la)?tex|dtx|tikz|ins)$' ? l:opts.main : ''
                            
                              " Get preamble for some state parsing
                              let l:preamble = !empty(l:new.tex)
                                    \ ? vimtex#parser#preamble(l:new.tex, {'root' : l:new.root})
                                    \ : []
                            
                              let l:new.documentclass = s:parse_documentclass(l:preamble)
                              let l:new.packages = s:parse_packages(l:preamble)
                              let l:new.graphicspath = s:parse_graphicspath(l:preamble, l:new.root)
                            
                              " Initialize state in submodules
                              for l:mod in filter(
                                    \ ['view', 'compiler', 'qf', 'toc', 'fold', 'context'],
                                    \ 'index(l:opts.unsupported_modules, v:val) < 0')
                                call vimtex#{l:mod}#init_state(l:new)
                              endfor
                            
                              " Update package list from fls file (if available)
                              call l:new.update_packages()
                            
                              return l:new
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 let s:vimtex = {}
                            
    1              0.000002 function! s:vimtex.__pprint() abort dict " {{{1
                              let l:items = [
                                    \ ['name', self.name],
                                    \ ['base', self.base],
                                    \ ['root', self.root],
                                    \ ['tex', self.tex],
                                    \ ['main parser', self.main_parser],
                                    \]
                            
                              if exists('self.documentclass')
                                call add(l:items, ['document class', self.documentclass])
                              endif
                            
                              if !empty(self.packages)
                                call add(l:items, ['packages', join(sort(keys(self.packages)))])
                              endif
                            
                              let l:sources = self.get_sources()
                              if len(l:sources) >= 2
                                call add(l:items, ['source files', l:sources])
                              endif
                            
                              call add(l:items, ['compiler', get(self, 'compiler', {})])
                              call add(l:items, ['viewer', get(self, 'viewer', {})])
                            
                              if exists('self.qf.name')
                                call add(l:items, ['qf method', self.qf.name])
                              endif
                            
                              return [['VimTeX project', l:items]]
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:vimtex.cleanup() abort dict " {{{1
                              if exists('self.compiler.is_running')
                                    \ && self.compiler.is_running()
                                call self.compiler.kill()
                              endif
                            
                              if exists('#User#VimtexEventQuit')
                                if exists('b:vimtex')
                                  let b:vimtex_tmp = b:vimtex
                                endif
                                let b:vimtex = self
                                doautocmd <nomodeline> User VimtexEventQuit
                                if exists('b:vimtex_tmp')
                                  let b:vimtex = b:vimtex_tmp
                                  unlet b:vimtex_tmp
                                else
                                  unlet b:vimtex
                                endif
                              endif
                            
                              " Close quickfix window
                              silent! cclose
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:vimtex.getftime() abort dict " {{{1
                              return max(map(self.get_sources(), 'getftime(self.root . ''/'' . v:val)'))
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:vimtex.update_packages() abort dict " {{{1
                              if !has_key(self, 'compiler') | return | endif
                            
                              " Try to parse .fls file if present, as it is usually more complete. That is,
                              " it contains a generated list of all the packages that are used.
                              for l:line in vimtex#parser#fls(self.compiler.get_file('fls'))
                                let l:package = matchstr(l:line, '^INPUT \zs.\+\ze\.sty$')
                                let l:package = fnamemodify(l:package, ':t')
                                if !empty(l:package)
                                  let self.packages[l:package] = {}
                                endif
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:vimtex.get_tex_program() abort dict " {{{1
                              let l:tex_program_re =
                                    \ '\v^\c\s*\%\s*!?\s*tex\s+%(ts-)?program\s*\=\s*\zs.*\ze\s*$'
                            
                              let l:lines = vimtex#parser#preamble(self.tex, {'root' : self.root})[:20]
                              call map(l:lines, 'matchstr(v:val, l:tex_program_re)')
                              call filter(l:lines, '!empty(v:val)')
                              return tolower(get(l:lines, -1, '_'))
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:vimtex.is_compileable() abort dict " {{{1
                              if self.main_parser ==# 'fallback current file'
                                " This conditional branch essentially means VimTeX gave up on finding the
                                " current project's main file. This _sometimes_ indicates a file that is
                                " not compileable. We therefore do a weak check of whether the file is
                                " compileable by looking for the classic preamble header and
                                " \begin{document} + \end{document}.
                            
                                let l:lines = getline(1, '$')
                                let l:index = match(l:lines, '^\s*\\documentclass\_\s*[\[{]')
                                if l:index < 0 | return v:false | endif
                            
                                let l:index = match(l:lines, '^\s*\\begin\s*{document}', l:index+1)
                                if l:index < 0 | return v:false | endif
                            
                                let l:index = match(l:lines, '^\s*\\end\s*{document}', l:index+1)
                                return l:index >= 0
                              endif
                            
                              return v:true
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! s:vimtex.get_sources() abort dict " {{{1
                              if !has_key(self, '__sources')
                                let self.__sources = s:gather_sources(self.tex, self.root)
                              endif
                            
                              return copy(self.__sources)
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:parse_documentclass(preamble) abort " {{{1
                              let l:preamble_lines = filter(copy(a:preamble), {_, x -> x !~# '^\s*%'})
                              return matchstr(join(l:preamble_lines, ''),
                                    \ '\\documentclass[^{]*{\zs[^}]\+\ze}')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parse_packages(preamble) abort " {{{1
                              let l:usepackages = filter(copy(a:preamble),
                                    \ 'v:val =~# ''\v%(usep|RequireP)ackage''')
                              let l:pat = g:vimtex#re#not_comment . g:vimtex#re#not_bslash
                                  \ . '\v\\%(usep|RequireP)ackage\s*%(\[[^[\]]*\])?\s*\{\s*\zs%([^{}]+)\ze\s*\}'
                              call map(l:usepackages, {_, x -> split(matchstr(x, l:pat), '\s*,\s*')})
                            
                              let l:parsed = {}
                              for l:packages in l:usepackages
                                for l:package in l:packages
                                  let l:parsed[l:package] = {}
                                endfor
                              endfor
                            
                              return l:parsed
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parse_graphicspath(preamble, root) abort " {{{1
                              " Combine the preamble as one long string of commands
                              let l:preamble = join(map(copy(a:preamble),
                                    \ {_, x -> substitute(x, '\\\@<!%.*', '', '')}))
                            
                              " Extract the graphicspath command from this string
                              let l:graphicspath = matchstr(l:preamble,
                                      \ g:vimtex#re#not_bslash
                                      \ . '\\graphicspath\s*\{\s*\{\s*\zs.{-}\ze\s*\}\s*\}'
                                      \)
                            
                              " Add all parsed graphicspaths
                              let l:paths = []
                              for l:path in split(l:graphicspath, '\s*}\s*{\s*')
                                let l:path = substitute(l:path, '\/\s*$', '', '')
                                call add(l:paths, vimtex#paths#is_abs(l:path)
                                      \ ? l:path
                                      \ : simplify(a:root . '/' . l:path))
                              endfor
                            
                              return l:paths
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:gather_sources(texfile, root) abort " {{{1
                              let l:sources = vimtex#parser#tex#parse_files(
                                    \ a:texfile, {'root' : a:root})
                            
                              return map(l:sources, 'vimtex#paths#relative(v:val, a:root)')
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/view.vim
Sourced 1 time
Total time:   0.000166
 Self time:   0.000119

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#view#init_buffer() abort " {{{1
                              if !g:vimtex_view_enabled | return | endif
                            
                              command! -buffer -nargs=? -complete=file VimtexView
                                    \ call vimtex#view#view(<q-args>)
                            
                              nnoremap <buffer> <plug>(vimtex-view) :VimtexView<cr>
                            
                              if has('nvim')
                                call s:nvim_prune_servernames()
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#view#init_state(state) abort " {{{1
                              if !g:vimtex_view_enabled | return | endif
                              if has_key(a:state, 'viewer') | return | endif
                            
                              augroup vimtex_viewer
                                autocmd!
                                autocmd User VimtexEventCompileSuccess call vimtex#view#compiler_callback()
                                autocmd User VimtexEventCompileStopped call vimtex#view#compiler_stopped()
                              augroup END
                            
                              try
                                let a:state.viewer = vimtex#view#{g:vimtex_view_method}#new()
                              catch /E117/
                                call vimtex#log#warning(
                                      \ 'Invalid viewer: ' . g:vimtex_view_method,
                                      \ 'Please see :h g:vimtex_view_method')
                                return
                              endtry
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#view#view(...) abort " {{{1
                              if exists('*b:vimtex.viewer.view')
                                call b:vimtex.viewer.view(a:0 > 0 ? a:1 : '')
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#view#compiler_callback() abort " {{{1
                              if exists('*b:vimtex.viewer.compiler_callback')
                                if !b:vimtex.viewer.check() | return | endif
                            
                                let l:outfile = b:vimtex.viewer.out()
                                if !filereadable(l:outfile) | return | endif
                            
                                call b:vimtex.viewer.compiler_callback(l:outfile)
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#view#compiler_stopped() abort " {{{1
                              if exists('*b:vimtex.viewer.compiler_stopped')
                                call b:vimtex.viewer.compiler_stopped()
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#view#inverse_search(line, filename) abort " {{{1
                              " Only activate in VimTeX buffers
                              if !exists('b:vimtex') | return -1 | endif
                            
                              " Only activate in relevant VimTeX projects
                              let l:file = resolve(a:filename)
                              let l:sources = b:vimtex.get_sources()
                              if vimtex#paths#is_abs(l:file)
                                call map(l:sources, {_, x -> vimtex#paths#join(b:vimtex.root, x)})
                              endif
                              if index(l:sources, l:file) < 0 | return -2 | endif
                            
                            
                              if mode() ==# 'i' | stopinsert | endif
                            
                              " Open file if necessary
                              if !bufloaded(l:file)
                                if filereadable(l:file)
                                  try
                                    execute g:vimtex_view_reverse_search_edit_cmd l:file
                                  catch
                                    call vimtex#log#warning([
                                          \ 'Reverse goto failed!',
                                          \ printf('Command error: %s %s',
                                          \        g:vimtex_view_reverse_search_edit_cmd, l:file)])
                                    return -3
                                  endtry
                                else
                                  call vimtex#log#warning([
                                        \ 'Reverse goto failed!',
                                        \ printf('File not readable: "%s"', l:file)])
                                  return -4
                                endif
                              endif
                            
                              " Get buffer, window, and tab numbers
                              " * If tab/window exists, switch to it/them
                              let l:bufnr = bufnr(l:file)
                              try
                                let [l:winid] = win_findbuf(l:bufnr)
                                let [l:tabnr, l:winnr] = win_id2tabwin(l:winid)
                                execute l:tabnr . 'tabnext'
                                execute l:winnr . 'wincmd w'
                              catch
                                execute g:vimtex_view_reverse_search_edit_cmd l:file
                              endtry
                            
                              execute 'normal!' a:line . 'G'
                              if b:vimtex.viewer.xdo_check()
                                call b:vimtex.viewer.xdo_focus_vim()
                              endif
                              redraw
                            
                              if exists('#User#VimtexEventViewReverse')
                                doautocmd <nomodeline> User VimtexEventViewReverse
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#view#inverse_search_cmd(line, filename) abort " {{{1
                              " One may call this function manually, but the main usage is to through the
                              " command "VimtexInverseSearch". See ":help vimtex-synctex-inverse-search"
                              " for more info.
                            
                              if a:line > 0 && !empty(a:filename)
                                try
                                  if has('nvim')
                                    call s:inverse_search_cmd_nvim(a:line, a:filename)
                                  else
                                    call s:inverse_search_cmd_vim(a:line, a:filename)
                                  endif
                                catch
                                endtry
                              endif
                            
                              quitall!
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 function! s:inverse_search_cmd_nvim(line, filename) abort " {{{1
                              if !filereadable(s:nvim_servernames) | return | endif
                            
                              for l:server in readfile(s:nvim_servernames)
                                try
                                  let l:socket = sockconnect('pipe', l:server, {'rpc': 1})
                                catch
                                endtry
                            
                                call rpcnotify(l:socket,
                                      \ 'nvim_call_function',
                                      \ 'vimtex#view#inverse_search',
                                      \ [a:line, a:filename])
                                call chanclose(l:socket)
                              endfor
                            endfunction
                            
    1              0.000002 function! s:inverse_search_cmd_vim(line, filename) abort " {{{1
                              for l:server in split(serverlist(), "\n")
                                call remote_expr(l:server,
                                      \ printf("vimtex#view#inverse_search(%d, '%s')", a:line, a:filename))
                              endfor
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:nvim_prune_servernames() abort " {{{1
                              " Load servernames from file
                              let l:servers = filereadable(s:nvim_servernames)
                                    \ ? readfile(s:nvim_servernames)
                                    \ : []
                            
                              " Check which servers are available
                              let l:available_servernames = []
                              for l:server in vimtex#util#uniq_unsorted(l:servers + [v:servername])
                                try
                                  let l:socket = sockconnect('pipe', l:server)
                                  call add(l:available_servernames, l:server)
                                  call chanclose(l:socket)
                                catch
                                endtry
                              endfor
                            
                              " Write the pruned list to file
                              call writefile(l:available_servernames, s:nvim_servernames)
                            endfunction
                            
                            " }}}1
                            
                            
    1   0.000053   0.000007 let s:nvim_servernames = vimtex#cache#path('nvim_servernames.log')

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/view/general.vim
Sourced 1 time
Total time:   0.000255
 Self time:   0.000080

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#view#general#new() abort " {{{1
                              return s:viewer.init()
                            endfunction
                            
                            " }}}1
                            
                            
    1   0.000216   0.000042 let s:viewer = vimtex#view#_template#new({
                                  \ 'name' : 'General'
                                  \})
                            
    1              0.000001 function! s:viewer._check() abort " {{{1
                              " Check if the viewer is executable
                              " * split to ensure that we handle stuff like "gio open"
                              let l:exe = get(split(g:vimtex_view_general_viewer), 0, '')
                              if empty(l:exe)
                                    \ || (!executable(l:exe)
                                    \     && !(vimtex#util#get_os() ==# 'win'
                                    \          && g:vimtex_view_general_viewer ==# 'start ""'))
                                call vimtex#log#warning(
                                      \ 'Generic viewer is not executable!',
                                      \ '- Viewer: ' . g:vimtex_view_general_viewer,
                                      \ '- Executable: ' . l:exe,
                                      \ '- Please see :h g:vimtex_view_general_viewer')
                                return v:false
                              endif
                            
                              return v:true
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:viewer._start(file) dict abort " {{{1
                              " Update file path for Windows+cygwin
                              let l:path_pdf = executable('cygpath')
                                    \ ? join(vimtex#jobs#capture('cygpath -aw "' . a:file . '"'), '')
                                    \ : a:file
                            
                              " Escapes for shell command and the substitute
                              let l:path_tex = vimtex#util#shellescape(expand('%:p'))
                              let l:path_tex = escape(l:path_tex, '&')
                              let l:path_pdf = vimtex#util#shellescape(l:path_pdf)
                              let l:path_pdf = escape(l:path_pdf, '&')
                            
                              " Parse options
                              let l:cmd = g:vimtex_view_general_viewer
                              let l:cmd .= ' ' . g:vimtex_view_general_options
                            
                              " Substitute magic patterns
                              let l:cmd = substitute(l:cmd, '@line', line('.'), 'g')
                              let l:cmd = substitute(l:cmd, '@col', col('.'), 'g')
                              let l:cmd = substitute(l:cmd, '@tex', l:path_tex, 'g')
                              let l:cmd = substitute(l:cmd, '@pdf', l:path_pdf, 'g')
                            
                              " Start the view process
                              " NB: Use vimtex#jobs#start to ensure it runs in the background
                              let self.job = vimtex#jobs#start(l:cmd, {
                                    \ 'detached': vimtex#util#get_os() !=# 'win'
                                    \})
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/view/_template.vim
Sourced 1 time
Total time:   0.000157
 Self time:   0.000157

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#view#_template#new(viewer) abort " {{{1
                              return extend(deepcopy(s:viewer), a:viewer)
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 let s:viewer = {}
                            
    1              0.000002 function! s:viewer.init() abort dict " {{{1
                              let l:viewer = deepcopy(self)
                              unlet l:viewer.init
                              return l:viewer
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:viewer.check() abort " {{{1
                              if !has_key(self, '_check_value')
                                let self._check_value = self._check()
                              endif
                            
                              return self._check_value
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:viewer.out() dict abort " {{{1
                              let l:out = b:vimtex.compiler.get_file('pdf')
                            
                              " Copy pdf and synctex files if we use temporary files
                              if g:vimtex_view_use_temp_files
                                let l:temp = b:vimtex.root . '/' . b:vimtex.name . '_vimtex.pdf'
                                if getftime(l:out) > getftime(l:temp)
                                  call writefile(readfile(l:out, 'b'), l:temp, 'b')
                                endif
                                let l:out = l:temp
                            
                                let l:old = b:vimtex.compiler.get_file('synctex.gz')
                                let l:new = fnamemodify(l:out, ':r') . '.synctex.gz'
                                if getftime(l:old) > getftime(l:new)
                                  call rename(l:old, l:new)
                                endif
                              endif
                            
                              return filereadable(l:out) ? l:out : ''
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:viewer.view(file) dict abort " {{{1
                              if !self.check() | return | endif
                            
                              if !empty(a:file)
                                let l:outfile = a:file
                              else
                                let l:outfile = self.out()
                              endif
                            
                              if !filereadable(l:outfile)
                                call vimtex#log#warning('Viewer cannot read PDF file!', l:outfile)
                                return
                              endif
                            
                              if self._exists()
                                call self._forward_search(l:outfile)
                              else
                                call self._start(l:outfile)
                              endif
                            
                              if exists('#User#VimtexEventView')
                                doautocmd <nomodeline> User VimtexEventView
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:viewer.compiler_callback(outfile) dict abort " {{{1
                              if !g:vimtex_view_automatic
                                  \ || has_key(self, 'started_through_callback') | return | endif
                            
                              call self._start(a:outfile)
                              let self.started_through_callback = 1
                            
                              if exists('#User#VimtexEventView')
                                doautocmd <nomodeline> User VimtexEventView
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:viewer.compiler_stopped() dict abort " {{{1
                              if has_key(self, 'started_through_callback')
                                unlet self.started_through_callback
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! s:viewer._exists() dict abort " {{{1
                              return v:false
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! s:viewer.__pprint() abort dict " {{{1
                              let l:list = []
                            
                              if has_key(self, 'xwin_id')
                                call add(l:list, ['xwin id', self.xwin_id])
                              endif
                            
                              if has_key(self, 'job')
                                call add(l:list, ['job', self.job])
                              endif
                            
                              for l:key in filter(keys(self), 'v:val =~# ''^cmd''')
                                call add(l:list, [l:key, self[l:key]])
                              endfor
                            
                              return l:list
                            endfunction
                            
                            " }}}1
                            
                            
                            " Methods that rely on xdotool. These are made available to all viewers, but
                            " they are only relevant for those that has the "xwin_id" attribute.
                            
    1              0.000001 function! s:viewer.xdo_check() dict abort " {{{1
                              return executable('xdotool') && has_key(self, 'xwin_id')
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:viewer.xdo_get_id() dict abort " {{{1
                              if !self.xdo_check() | return 0 | endif
                            
                              if self.xwin_id > 0 | return self.xwin_id | endif
                            
                              " Allow some time for the viewer to start properly
                              sleep 500m
                            
                              " Try to find viewer's window ID by different methods:
                              " * by PID (probably most reliable when it works)
                              " * by window name
                              " * by window class (fallback)
                              for l:method in ['pid', 'name', 'class']
                                execute "let self.xwin_id = self.xdo_find_win_id_by_" . l:method . "()"
                                if self.xwin_id > 0 | return self.xwin_id | endif
                              endfor
                            
                              call vimtex#log#warning('Viewer cannot find ' . self.name . ' window ID!')
                              return self.xwin_id
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:viewer.xdo_exists() dict abort " {{{1
                              if !self.xdo_check() | return v:false | endif
                            
                              " If xwin_id is already set, check if a matching viewer window still exists
                              if self.xwin_id > 0
                                let l:xwin_ids = vimtex#jobs#capture('xdotool search --class ' . self.name)
                                if index(l:xwin_ids, self.xwin_id) < 0
                                  let self.xwin_id = 0
                                endif
                                if self.xwin_id > 0 | return v:true | endif
                              endif
                            
                              " If xwin_id is unset, then search for viewer by PID
                              let self.xwin_id = self.xdo_find_win_id_by_pid()
                              if self.xwin_id > 0 | return v:true | endif
                            
                              " If xwin_id is still unset, then search for viewer by window name
                              let self.xwin_id = self.xdo_find_win_id_by_name()
                            
                              return self.xwin_id > 0
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:viewer.xdo_find_win_id_by_class() dict abort " {{{1
                              " Attempt to find viewer's X window ID by window class name.
                              " Returns the viewer's window ID if one is found or 0. If multiple IDs are
                              " found, return the last one. This seems to work well in most cases.
                              let l:xwin_ids = vimtex#jobs#capture('xdotool search --class ' . self.name)
                              return get(l:xwin_ids, -1)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:viewer.xdo_find_win_id_by_name() dict abort " {{{1
                              " Attempt to find viewer's X window ID by window name (i.e. the string in the
                              " window titlebar).
                              " Returns the viewer's window ID if one is found or 0.
                              let l:xwin_ids = vimtex#jobs#capture(
                                    \ 'xdotool search --name ' . fnamemodify(self.out(), ':t'))
                            
                              " Note: We filter by existing VimTeX states because a user may have multiple
                              "       VimTeX sessions going with the same basename.
                              let l:xwin_ids_in_use = filter(map(
                                    \   deepcopy(vimtex#state#list_all()),
                                    \   {_, x -> get(get(x, 'viewer', {}), 'xwin_id')}),
                                    \ 'v:val > 0')
                              call filter(l:xwin_ids, {_, x -> index(l:xwin_ids_in_use, x) < 0})
                            
                              return get(l:xwin_ids, 0)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:viewer.xdo_find_win_id_by_pid() dict abort " {{{1
                              " Attempt to find the viewer's X window ID by the viewer's process ID.
                              " Returns the viewer's window ID if one is found or 0. If more than one ID is
                              " found, return the first.
                              let l:pid = has_key(self, 'get_pid') ? self.get_pid() : 0
                              if l:pid <= 0 | return 0 | endif
                            
                              let l:xwin_ids = vimtex#jobs#capture(
                                    \   'xdotool search --all --pid ' . l:pid
                                    \ . ' --name ' . fnamemodify(self.out(), ':t'))
                              return get(l:xwin_ids, 0)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:viewer.xdo_send_keys(keys) dict abort " {{{1
                              if !self.xdo_check() || empty(a:keys) || self.xwin_id <= 0 | return | endif
                            
                              call vimtex#jobs#run('xdotool key --window ' . self.xwin_id . ' ' . a:keys)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:viewer.xdo_focus_viewer() dict abort " {{{1
                              if !self.xdo_check() || self.xwin_id <= 0 | return | endif
                            
                              call vimtex#jobs#run('xdotool windowactivate ' . self.xwin_id . ' --sync')
                              call vimtex#jobs#run('xdotool windowraise ' . self.xwin_id)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:viewer.xdo_focus_vim() dict abort " {{{1
                              if !executable('xdotool') | return | endif
                              if !executable('pstree') | return | endif
                            
                              " The idea is to use xdotool to focus the window ID of the relevant windowed
                              " process. To do this, we need to check the process tree. Inside TMUX we need
                              " to check from the PID of the tmux client. We find this PID by listing the
                              " PIDS of the corresponding pty.
                              if empty($TMUX)
                                let l:current_pid = getpid()
                              else
                                let l:output = vimtex#jobs#capture('tmux display-message -p "#{client_tty}"')
                                let l:pts = split(trim(l:output[0]), '/')[-1]
                                let l:current_pid = str2nr(vimtex#jobs#capture('ps o pid t ' . l:pts)[1])
                              endif
                            
                              let l:output = join(vimtex#jobs#capture('pstree -s -p ' . l:current_pid))
                              let l:pids = split(l:output, '\D\+')
                              let l:pids = l:pids[: index(l:pids, string(l:current_pid))]
                            
                              for l:pid in reverse(l:pids)
                                let l:output = vimtex#jobs#capture(
                                      \ 'xdotool search --onlyvisible --pid ' . l:pid)
                                let l:xwinids = filter(reverse(l:output), '!empty(v:val)')
                            
                                if !empty(l:xwinids)
                                  call vimtex#jobs#run('xdotool mousemove --window '. l:xwinids[0] . ' --polar 0 0')
                                  call vimtex#jobs#run('xdotool windowactivate ' . l:xwinids[0] . ' &')
                                  return l:xwinids[0]
                                  break
                                endif
                              endfor
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler.vim
Sourced 1 time
Total time:   0.000247
 Self time:   0.000247

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#compiler#init_buffer() abort " {{{1
                              if !g:vimtex_compiler_enabled | return | endif
                            
                              " Define commands
                              command! -buffer        VimtexCompile                        call vimtex#compiler#compile()
                              command! -buffer -bang  VimtexCompileSS                      call vimtex#compiler#compile_ss()
                              command! -buffer -range VimtexCompileSelected <line1>,<line2>call vimtex#compiler#compile_selected('command')
                              command! -buffer        VimtexCompileOutput                  call vimtex#compiler#output()
                              command! -buffer        VimtexStop                           call vimtex#compiler#stop()
                              command! -buffer        VimtexStopAll                        call vimtex#compiler#stop_all()
                              command! -buffer -bang  VimtexClean                          call vimtex#compiler#clean(<q-bang> == "!")
                              command! -buffer -bang  VimtexStatus                         call vimtex#compiler#status(<q-bang> == "!")
                            
                              " Define mappings
                              nnoremap <buffer> <plug>(vimtex-compile)          :call vimtex#compiler#compile()<cr>
                              nnoremap <buffer> <plug>(vimtex-compile-ss)       :call vimtex#compiler#compile_ss()<cr>
                              nnoremap <buffer> <plug>(vimtex-compile-selected) :set opfunc=vimtex#compiler#compile_selected<cr>g@
                              xnoremap <buffer> <plug>(vimtex-compile-selected) :<c-u>call vimtex#compiler#compile_selected('visual')<cr>
                              nnoremap <buffer> <plug>(vimtex-compile-output)   :call vimtex#compiler#output()<cr>
                              nnoremap <buffer> <plug>(vimtex-stop)             :call vimtex#compiler#stop()<cr>
                              nnoremap <buffer> <plug>(vimtex-stop-all)         :call vimtex#compiler#stop_all()<cr>
                              nnoremap <buffer> <plug>(vimtex-clean)            :call vimtex#compiler#clean(0)<cr>
                              nnoremap <buffer> <plug>(vimtex-clean-full)       :call vimtex#compiler#clean(1)<cr>
                              nnoremap <buffer> <plug>(vimtex-status)           :call vimtex#compiler#status(0)<cr>
                              nnoremap <buffer> <plug>(vimtex-status-all)       :call vimtex#compiler#status(1)<cr>
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#compiler#init_state(state) abort " {{{1
                              let a:state.compiler = s:init_compiler({'state': a:state})
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#compiler#callback(status) abort " {{{1
                              " Status:
                              " 1: Compilation cycle has started
                              " 2: Compilation complete - Success
                              " 3: Compilation complete - Failed
                              if !exists('b:vimtex.compiler') | return | endif
                              silent! call s:output.pause()
                            
                              if b:vimtex.compiler.silence_next_callback
                                if g:vimtex_compiler_silent
                                  let b:vimtex.compiler.silence_next_callback = 0
                                else
                                  call vimtex#log#set_silent()
                                endif
                              endif
                            
                              let b:vimtex.compiler.status = a:status
                            
                              if a:status == 1
                                if exists('#User#VimtexEventCompiling')
                                  doautocmd <nomodeline> User VimtexEventCompiling
                                endif
                                silent! call s:output.resume()
                                return
                              endif
                            
                              if a:status == 2
                                if !g:vimtex_compiler_silent
                                  call vimtex#log#info('Compilation completed')
                                endif
                            
                                if exists('b:vimtex')
                                  call b:vimtex.update_packages()
                                  call vimtex#syntax#packages#init()
                                endif
                            
                                if exists('#User#VimtexEventCompileSuccess')
                                  doautocmd <nomodeline> User VimtexEventCompileSuccess
                                endif
                              elseif a:status == 3
                                if !g:vimtex_compiler_silent
                                  call vimtex#log#warning('Compilation failed!')
                                endif
                            
                                if exists('#User#VimtexEventCompileFailed')
                                  doautocmd <nomodeline> User VimtexEventCompileFailed
                                endif
                              endif
                            
                              if b:vimtex.compiler.silence_next_callback
                                call vimtex#log#set_silent_restore()
                                let b:vimtex.compiler.silence_next_callback = 0
                              endif
                            
                              call vimtex#qf#open(0)
                              silent! call s:output.resume()
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#compiler#compile() abort " {{{1
                              if !b:vimtex.compiler.enabled | return | endif
                            
                              if b:vimtex.compiler.is_running()
                                call vimtex#compiler#stop()
                              else
                                call vimtex#compiler#start()
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#compiler#compile_ss() abort " {{{1
                              if !b:vimtex.compiler.enabled | return | endif
                            
                              if b:vimtex.compiler.is_running()
                                call vimtex#log#info(
                                      \ 'Compiler is already running, use :VimtexStop to stop it!')
                                return
                              endif
                            
                              call b:vimtex.compiler.start_single()
                            
                              if g:vimtex_compiler_silent | return | endif
                              call vimtex#log#info('Compiler started in background!')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#compiler#compile_selected(type) abort range " {{{1
                              if !b:vimtex.compiler.enabled | return | endif
                            
                              " Values of a:firstline and a:lastline are not available in nested function
                              " calls, so we must handle them here.
                              let l:opts = a:type ==# 'command'
                                    \ ? {'type': 'range', 'range': [a:firstline, a:lastline]}
                                    \ : {'type':  a:type =~# 'line\|char\|block' ? 'operator' : a:type}
                            
                              let l:file = vimtex#parser#selection_to_texfile(l:opts)
                              if empty(l:file) | return | endif
                              let l:tex_program = b:vimtex.get_tex_program()
                              let l:file.get_tex_program = {-> l:tex_program}
                            
                              " Create and initialize temporary compiler
                              let l:compiler = s:init_compiler({
                                    \ 'state': l:file,
                                    \ 'out_dir': '',
                                    \ 'continuous': 0,
                                    \ 'callback': 0,
                                    \})
                              if empty(l:compiler) | return | endif
                            
                              call vimtex#log#info('Compiling selected lines ...')
                              call vimtex#log#set_silent()
                              call l:compiler.start()
                              call l:compiler.wait()
                            
                              " Check if successful
                              if vimtex#qf#inquire(l:file.tex)
                                call vimtex#log#set_silent_restore()
                                call vimtex#log#warning('Compiling selected lines ... failed!')
                                botright cwindow
                                return
                              else
                                call l:compiler.clean(0)
                                call b:vimtex.viewer.view(l:file.pdf)
                                call vimtex#log#set_silent_restore()
                                call vimtex#log#info('Compiling selected lines ... done')
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#compiler#output() abort " {{{1
                              if !b:vimtex.compiler.enabled | return | endif
                            
                              if !exists('b:vimtex.compiler.output')
                                    \ || !filereadable(b:vimtex.compiler.output)
                                call vimtex#log#warning('No output exists!')
                                return
                              endif
                            
                              " If relevant output is open, then reuse it
                              if exists('s:output')
                                if s:output.name ==# b:vimtex.compiler.output
                                  if bufwinnr(b:vimtex.compiler.output) == s:output.winnr
                                    execute s:output.winnr . 'wincmd w'
                                  endif
                                  return
                                else
                                  call s:output.destroy()
                                endif
                              endif
                            
                              call s:output_factory.create(b:vimtex.compiler.output)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#compiler#start() abort " {{{1
                              if !b:vimtex.compiler.enabled | return | endif
                            
                              if !b:vimtex.is_compileable()
                                call vimtex#log#error(
                                      \ 'Compilation error due to failed mainfile detection!',
                                      \ 'Please ensure that VimTeX can locate the proper main .tex file.',
                                      \ 'Read ":help vimtex-multi-file" for more info.'
                                      \)
                                return
                              endif
                              if b:vimtex.compiler.is_running()
                                call vimtex#log#warning(
                                      \ 'Compiler is already running for `' . b:vimtex.base . "'")
                                return
                              endif
                            
                              call b:vimtex.compiler.start()
                            
                              if g:vimtex_compiler_silent | return | endif
                            
                              " We add a redraw here to clear messages (e.g. file written). This is useful
                              " to avoid the "Press ENTER" prompt in some cases, see e.g.
                              " https://github.com/lervag/vimtex/issues/2149
                              redraw
                            
                              if b:vimtex.compiler.continuous
                                call vimtex#log#info('Compiler started in continuous mode')
                              else
                                call vimtex#log#info('Compiler started in background!')
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#compiler#stop() abort " {{{1
                              if !b:vimtex.compiler.enabled | return | endif
                            
                              if !b:vimtex.compiler.is_running()
                                call vimtex#log#warning(
                                      \ 'There is no process to stop (' . b:vimtex.base . ')')
                                return
                              endif
                            
                              call b:vimtex.compiler.stop()
                            
                              if g:vimtex_compiler_silent | return | endif
                              call vimtex#log#info('Compiler stopped (' . b:vimtex.base . ')')
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#compiler#stop_all() abort " {{{1
                              for l:state in vimtex#state#list_all()
                                if exists('l:state.compiler.enabled')
                                      \ && l:state.compiler.enabled
                                      \ && l:state.compiler.is_running()
                                  call l:state.compiler.stop()
                                  call vimtex#log#info('Compiler stopped (' . l:state.compiler.state.base . ')')
                                endif
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#compiler#clean(full) abort " {{{1
                              if !b:vimtex.compiler.enabled | return | endif
                            
                              let l:restart = b:vimtex.compiler.is_running()
                              if l:restart
                                call b:vimtex.compiler.stop()
                              endif
                            
                            
                              call b:vimtex.compiler.clean(a:full)
                              sleep 100m
                              call b:vimtex.compiler.remove_dirs()
                              call vimtex#log#info('Compiler clean finished' . (a:full ? ' (full)' : ''))
                            
                            
                              if l:restart
                                let b:vimtex.compiler.silence_next_callback = 1
                                silent call b:vimtex.compiler.start()
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#compiler#status(detailed) abort " {{{1
                              if !b:vimtex.compiler.enabled | return | endif
                            
                              if a:detailed
                                let l:running = []
                                for l:data in vimtex#state#list_all()
                                  if l:data.compiler.is_running()
                                    let l:name = l:data.tex
                                    if len(l:name) >= winwidth('.') - 20
                                      let l:name = '...' . l:name[-winwidth('.')+23:]
                                    endif
                                    call add(l:running, printf('%-6s %s',
                                          \ string(l:data.compiler.get_pid()) . ':', l:name))
                                  endif
                                endfor
                            
                                if empty(l:running)
                                  call vimtex#log#info('Compiler is not running!')
                                else
                                  call vimtex#log#info('Compiler is running', l:running)
                                endif
                              else
                                if exists('b:vimtex.compiler')
                                      \ && b:vimtex.compiler.is_running()
                                  call vimtex#log#info('Compiler is running')
                                else
                                  call vimtex#log#info('Compiler is not running!')
                                endif
                              endif
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:init_compiler(options) abort " {{{1
                              if type(g:vimtex_compiler_method) == v:t_func
                                    \ || exists('*' . g:vimtex_compiler_method)
                                let l:method = call(g:vimtex_compiler_method, [a:options.state.tex])
                              else
                                let l:method = g:vimtex_compiler_method
                              endif
                            
                              if index([
                                    \ 'arara',
                                    \ 'generic',
                                    \ 'latexmk',
                                    \ 'latexrun',
                                    \ 'tectonic',
                                    \], l:method) < 0
                                call vimtex#log#error('Error! Invalid compiler method: ' . l:method)
                                let l:method = 'latexmk'
                              endif
                            
                              let l:options =
                                    \ get(g:, 'vimtex_compiler_' . l:method, {})
                              let l:options = extend(deepcopy(l:options), a:options)
                              let l:compiler
                                    \ = vimtex#compiler#{l:method}#init(l:options)
                              return l:compiler
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 let s:output_factory = {}
    1              0.000002 function! s:output_factory.create(file) dict abort " {{{1
                              let l:vimtex = b:vimtex
                              silent execute 'split' a:file
                              let b:vimtex = l:vimtex
                            
                              setlocal autoread
                              setlocal nomodifiable
                              setlocal bufhidden=wipe
                            
                              nnoremap <silent><buffer><nowait> q :bwipeout<cr>
                              if has('nvim') || has('gui_running')
                                nnoremap <silent><buffer><nowait> <esc> :bwipeout<cr>
                              endif
                            
                              let s:output = deepcopy(self)
                              unlet s:output.create
                            
                              let s:output.name = a:file
                              let s:output.ftime = -1
                              let s:output.paused = v:false
                              let s:output.bufnr = bufnr('%')
                              let s:output.winnr = bufwinnr('%')
                              let s:output.timer = timer_start(100,
                                    \ {_ -> s:output.update()},
                                    \ {'repeat': -1})
                            
                              augroup vimtex_output_window
                                autocmd!
                                autocmd BufDelete <buffer> call s:output.destroy()
                                autocmd BufEnter     *     call s:output.update()
                                autocmd FocusGained  *     call s:output.update()
                                autocmd CursorHold   *     call s:output.update()
                                autocmd CursorHoldI  *     call s:output.update()
                                autocmd CursorMoved  *     call s:output.update()
                                autocmd CursorMovedI *     call s:output.update()
                              augroup END
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:output_factory.pause() dict abort " {{{1
                              let self.paused = v:true
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:output_factory.resume() dict abort " {{{1
                              let self.paused = v:false
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:output_factory.update() dict abort " {{{1
                              if self.paused | return | endif
                            
                              let l:ftime = getftime(self.name)
                              if self.ftime >= l:ftime
                                    \ || mode() ==? 'v' || mode() ==# "\<c-v>"
                                return
                              endif
                              let self.ftime = getftime(self.name)
                            
                              if bufwinnr(self.name) != self.winnr
                                let self.winnr = bufwinnr(self.name)
                              endif
                            
                              let l:swap = bufwinnr('%') != self.winnr
                              if l:swap
                                let l:return = bufwinnr('%')
                                execute 'keepalt' self.winnr . 'wincmd w'
                              endif
                            
                              " Force reload file content
                              silent edit
                            
                              if l:swap
                                " Go to last line of file if it is not the current window
                                normal! Gzb
                                execute 'keepalt' l:return . 'wincmd w'
                                redraw
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:output_factory.destroy() dict abort " {{{1
                              call timer_stop(self.timer)
                              autocmd! vimtex_output_window
                              augroup! vimtex_output_window
                              unlet s:output
                            endfunction
                            
                            " }}}1
                            
                            
                            " {{{1 Initialize module
                            
    1              0.000005 if !get(g:, 'vimtex_compiler_enabled') | finish | endif
                            
    1              0.000002 augroup vimtex_compiler
    1              0.000006   autocmd!
    1              0.000005   autocmd VimLeave * call vimtex#compiler#stop_all()
    1              0.000001 augroup END
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/latexmk.vim
Sourced 1 time
Total time:   0.000589
 Self time:   0.000204

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#compiler#latexmk#init(options) abort " {{{1
                              return s:compiler.new(a:options)
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 function! vimtex#compiler#latexmk#get_rc_opt(root, opt, type, default) abort " {{{1
                              "
                              " Parse option from .latexmkrc.
                              "
                              " Arguments:
                              "   root         Root of LaTeX project
                              "   opt          Name of options
                              "   type         0 if string, 1 if integer, 2 if list
                              "   default      Value to return if option not found in latexmkrc file
                              "
                              " Output:
                              "   [value, location]
                              "
                              "   value        Option value (integer or string)
                              "   location     An integer that indicates where option was found
                              "                 -1: not found (default value returned)
                              "                  0: global latexmkrc file
                              "                  1: local latexmkrc file
                              "
                            
                              if a:type == 0
                                let l:pattern = '^\s*\$' . a:opt . '\s*=\s*[''"]\(.\+\)[''"]'
                              elseif a:type == 1
                                let l:pattern = '^\s*\$' . a:opt . '\s*=\s*\(\d\+\)'
                              elseif a:type == 2
                                let l:pattern = '^\s*@' . a:opt . '\s*=\s*(\(.*\))'
                              else
                                throw 'VimTeX: Argument error'
                              endif
                            
                              " Candidate files
                              " - each element is a pair [path_to_file, is_local_rc_file].
                              let l:files = [
                                    \ [a:root . '/latexmkrc', 1],
                                    \ [a:root . '/.latexmkrc', 1],
                                    \ [fnamemodify('~/.latexmkrc', ':p'), 0],
                                    \ [fnamemodify(
                                    \    !empty($XDG_CONFIG_HOME) ? $XDG_CONFIG_HOME : '~/.config', ':p')
                                    \    . '/latexmk/latexmkrc', 0]
                                    \]
                            
                              let l:result = [a:default, -1]
                            
                              for [l:file, l:is_local] in l:files
                                if filereadable(l:file)
                                  let l:match = matchlist(readfile(l:file), l:pattern)
                                  if len(l:match) > 1
                                    let l:result = [l:match[1], l:is_local]
                                    break
                                  end
                                endif
                              endfor
                            
                              " Parse the list
                              if a:type == 2 && l:result[1] > -1
                                let l:array = split(l:result[0], ',')
                                let l:result[0] = []
                                for l:x in l:array
                                  let l:x = substitute(l:x, "^'", '', '')
                                  let l:x = substitute(l:x, "'$", '', '')
                                  let l:result[0] += [l:x]
                                endfor
                              endif
                            
                              return l:result
                            endfunction
                            
                            " }}}1
                            
                            
    1   0.000438   0.000053 let s:compiler = vimtex#compiler#_template#new({
                                  \ 'name' : 'latexmk',
                                  \ 'aux_dir': '',
                                  \ 'callback' : 1,
                                  \ 'continuous': 1,
                                  \ 'executable' : 'latexmk',
                                  \ 'options' : [
                                  \   '-verbose',
                                  \   '-file-line-error',
                                  \   '-synctex=1',
                                  \   '-interaction=nonstopmode',
                                  \ ],
                                  \})
                            
    1              0.000002 function! s:compiler.__check_requirements() abort dict " {{{1
                              if !executable(self.executable)
                                call vimtex#log#warning(self.executable . ' is not executable')
                                let self.enabled = v:false
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:compiler.__init() abort dict " {{{1
                              call vimtex#util#materialize_property(self, 'aux_dir')
                            
                              call s:compare_with_latexmkrc(self, 'out_dir')
                              call s:compare_with_latexmkrc(self, 'aux_dir')
                              
                              " $VIMTEX_OUTPUT_DIRECTORY overrides configured compiler.aux_dir
                              if !empty($VIMTEX_OUTPUT_DIRECTORY)
                                if !empty(self.aux_dir)
                                      \ && (self.aux_dir !=# $VIMTEX_OUTPUT_DIRECTORY)
                                  call vimtex#log#warning(
                                        \ 'Setting VIMTEX_OUTPUT_DIRECTORY overrides aux_dir!',
                                        \ 'Changed aux_dir from: ' . self.aux_dir,
                                        \ 'Changed aux_dir to: ' . $VIMTEX_OUTPUT_DIRECTORY)
                                endif
                            
                                let self.aux_dir = $VIMTEX_OUTPUT_DIRECTORY
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler.__build_cmd() abort dict " {{{1
                              let l:cmd = (has('win32')
                                    \ ? 'set max_print_line=2000 & '
                                    \ : 'max_print_line=2000 ') . self.executable
                            
                              let l:cmd .= ' ' . join(self.options)
                              let l:cmd .= ' ' . self.get_engine()
                            
                              if !empty(self.out_dir)
                                let l:cmd .= ' -outdir=' . fnameescape(self.out_dir)
                              endif
                            
                              if !empty(self.aux_dir)
                                let l:cmd .= ' -emulate-aux-dir'
                                let l:cmd .= ' -auxdir=' . fnameescape(self.aux_dir)
                              endif
                            
                              if self.continuous
                                let l:cmd .= ' -pvc -view=none'
                            
                                if self.callback
                                  for [l:opt, l:val] in [
                                        \ ['compiling_cmd', 'vimtex_compiler_callback_compiling'],
                                        \ ['success_cmd', 'vimtex_compiler_callback_success'],
                                        \ ['failure_cmd', 'vimtex_compiler_callback_failure'],
                                        \]
                                    let l:cmd .= s:wrap_option_appendcmd(l:opt, 'echo ' . l:val)
                                  endfor
                                endif
                              endif
                            
                              return l:cmd . ' ' . vimtex#util#shellescape(self.state.base)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:compiler.__pprint_append() abort dict " {{{1
                              let l:list = []
                            
                              if !empty(self.aux_dir)
                                call add(l:list, ['aux_dir', self.aux_dir])
                              endif
                              
                              call add(l:list, ['callback', self.callback])
                              call add(l:list, ['continuous', self.continuous])
                              call add(l:list, ['executable', self.executable])
                            
                              return l:list
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:compiler.get_file(ext) abort dict " {{{1
                              for l:root in [
                                    \ $VIMTEX_OUTPUT_DIRECTORY,
                                    \ self.aux_dir,
                                    \ self.out_dir,
                                    \ self.state.root
                                    \]
                                if empty(l:root) | continue | endif
                            
                                let l:cand = printf('%s/%s.%s', l:root, self.state.name, a:ext)
                                if !vimtex#paths#is_abs(l:root)
                                  let l:cand = self.state.root . '/' . l:cand
                                endif
                            
                                if filereadable(l:cand)
                                  return fnamemodify(l:cand, ':p')
                                endif
                              endfor
                            
                              return ''
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler.create_dirs() abort dict " {{{1
                              call self._create_build_dir(self.out_dir)
                              call self._create_build_dir(self.aux_dir)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler.remove_dirs() abort dict " {{{1
                              call self._remove_dir(self.out_dir)
                              call self._remove_dir(self.aux_dir)
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:compiler.clean(full) abort dict " {{{1
                              let l:cmd = self.executable
                              let l:cmd .= a:full ? ' -C' : ' -c'
                            
                              if !empty(self.out_dir)
                                let l:cmd .= ' -outdir=' . fnameescape(self.out_dir)
                              endif
                              if !empty(self.aux_dir)
                                let l:cmd .= ' -emulate-aux-dir'
                                let l:cmd .= ' -auxdir=' . fnameescape(self.aux_dir)
                              endif
                            
                              let l:cmd .= ' ' . vimtex#util#shellescape(self.state.base)
                            
                              call vimtex#jobs#run(l:cmd, {'cwd': self.state.root})
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler.get_engine() abort dict " {{{1
                              " Parse tex_program from TeX directive
                              let l:tex_program_directive = self.state.get_tex_program()
                              let l:tex_program = l:tex_program_directive
                            
                              " Parse tex_program from from pdf_mode option in .latexmkrc
                              let [l:pdf_mode, l:is_local] =
                                    \ vimtex#compiler#latexmk#get_rc_opt(self.state.root, 'pdf_mode', 1, -1)
                            
                              if l:pdf_mode >= 1 && l:pdf_mode <= 5
                                let l:tex_program_pdfmode = [
                                      \ 'pdflatex',
                                      \ 'pdfps',
                                      \ 'pdfdvi',
                                      \ 'lualatex',
                                      \ 'xelatex',
                                      \][l:pdf_mode-1]
                            
                                " Use pdf_mode if there is no TeX directive
                                if l:tex_program_directive ==# '_'
                                  let l:tex_program = l:tex_program_pdfmode
                                elseif l:is_local && l:tex_program_directive !=# l:tex_program_pdfmode
                                  " Give warning when there may be a confusing conflict
                                  call vimtex#log#warning(
                                        \ 'Value of pdf_mode from latexmkrc is inconsistent with ' .
                                        \ 'TeX program directive!',
                                        \ 'TeX program: ' . l:tex_program_directive,
                                        \ 'pdf_mode:    ' . l:tex_program_pdfmode,
                                        \ 'The value of pdf_mode will be ignored.')
                                endif
                              endif
                            
                              return get(g:vimtex_compiler_latexmk_engines,
                                    \ l:tex_program,
                                    \ g:vimtex_compiler_latexmk_engines._)
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:compare_with_latexmkrc(dict, option) abort " {{{1
                              " Check if option is specified in .latexmkrc.
                              " If it is, .latexmkrc should be respected!
                              let l:value = vimtex#compiler#latexmk#get_rc_opt(
                                    \ a:dict.state.root, a:option, 0, '')[0]
                              if !empty(l:value)
                                if !empty(a:dict[a:option]) && (a:dict[a:option] !=# l:value)
                                  call vimtex#log#warning(
                                        \ 'Option "' . a:option . '" is overriden by latexmkrc',
                                        \ 'Changed from: ' . a:dict[a:option],
                                        \ 'Changed to: ' . l:value)
                                endif
                                let a:dict[a:option] = l:value
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:wrap_option_appendcmd(name, value) abort " {{{1
                              " Note: On Linux, we use double quoted perl strings; these interpolate
                              "       variables. One should therefore NOT pass values that contain `$`.
                              let l:win_cmd_sep = has('nvim') ? '^&' : '&'
                              let l:common = printf('$%s = ($%s ? $%s', a:name, a:name, a:name)
                              return has('win32')
                                    \ ? printf(' -e "%s . '' %s '' : '''') . ''%s''"',
                                    \          l:common, l:win_cmd_sep, a:value)
                                    \ : printf(' -e ''%s . " ; " : "") . "%s"''',
                                    \          l:common, a:value)
                            endfunction
                            
                            "}}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/_template.vim
Sourced 1 time
Total time:   0.000366
 Self time:   0.000366

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#compiler#_template#new(opts) abort " {{{1
                              return extend(deepcopy(s:compiler), a:opts)
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000093 let s:compiler = {
                                  \ 'name': '__template__',
                                  \ 'enabled': v:true,
                                  \ 'out_dir': '',
                                  \ 'continuous': 0,
                                  \ 'hooks': [],
                                  \ 'output': tempname(),
                                  \ 'silence_next_callback': 0,
                                  \ 'state': {},
                                  \ 'status': -1,
                                  \}
                            
    1              0.000002 function! s:compiler.new(options) abort dict " {{{1
                              let l:compiler = extend(deepcopy(self), a:options)
                              let l:backend = has('nvim') ? 'nvim' : 'jobs'
                              call extend(l:compiler, deepcopy(s:compiler_{l:backend}))
                            
                              call l:compiler.__check_requirements()
                            
                              call vimtex#util#materialize_property(l:compiler, 'out_dir')
                              call l:compiler.__init()
                            
                              " $VIMTEX_OUTPUT_DIRECTORY overrides configured compiler.out_dir
                              if !empty($VIMTEX_OUTPUT_DIRECTORY)
                                if !empty(l:compiler.out_dir)
                                      \ && (l:compiler.out_dir !=# $VIMTEX_OUTPUT_DIRECTORY)
                                  call vimtex#log#warning(
                                        \ 'Setting VIMTEX_OUTPUT_DIRECTORY overrides out_dir!',
                                        \ 'Changed out_dir from: ' . l:compiler.out_dir,
                                        \ 'Changed out_dir to: ' . $VIMTEX_OUTPUT_DIRECTORY)
                                endif
                            
                                let l:compiler.out_dir = $VIMTEX_OUTPUT_DIRECTORY
                              endif
                            
                              " Remove init methods
                              unlet l:compiler.new
                              unlet l:compiler.__check_requirements
                              unlet l:compiler.__init
                            
                              return l:compiler
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:compiler.__check_requirements() abort dict " {{{1
                              let self.enabled = v:false
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:compiler.__init() abort dict " {{{1
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:compiler.__build_cmd() abort dict " {{{1
                              throw 'VimTeX: __build_cmd method must be defined!'
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler.__pprint() abort dict " {{{1
                              let l:list = []
                            
                              if self.state.tex !=# b:vimtex.tex
                                call add(l:list, ['root', self.state.root])
                                call add(l:list, ['target', self.state.tex])
                              endif
                            
                              if has_key(self, 'get_engine')
                                call add(l:list, ['engine', self.get_engine()])
                              endif
                            
                              if has_key(self, 'options')
                                call add(l:list, ['options', self.options])
                              endif
                            
                              if !empty(self.out_dir)
                                call add(l:list, ['out_dir', self.out_dir])
                              endif
                            
                              if has_key(self, '__pprint_append')
                                call extend(l:list, self.__pprint_append())
                              endif
                            
                              if has_key(self, 'job')
                                let l:job = []
                                call add(l:job, ['jobid', self.job])
                                call add(l:job, ['output', self.output])
                                call add(l:job, ['cmd', self.cmd])
                                if self.continuous
                                  call add(l:job, ['pid', self.get_pid()])
                                endif
                                call add(l:list, ['job', l:job])
                              endif
                            
                              return l:list
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:compiler._create_build_dir(path) abort dict " {{{1
                              " Create build dir "path" if it does not exist
                              " Note: This may need to create a hierarchical structure!
                              if empty(a:path) | return | endif
                            
                              if has_key(self.state, 'get_sources')
                                let l:dirs = self.state.get_sources()
                                call filter(map(
                                      \ l:dirs, "fnamemodify(v:val, ':h')"),
                                      \ {_, x -> x !=# '.'})
                                call filter(l:dirs, {_, x -> stridx(x, '../') != 0})
                              else
                                let l:dirs = glob(self.state.root . '/**/*.tex', v:false, v:true)
                                call map(l:dirs, "fnamemodify(v:val, ':h')")
                                call map(l:dirs, 'strpart(v:val, strlen(self.state.root) + 1)')
                              endif
                              call uniq(sort(filter(l:dirs, '!empty(v:val)')))
                            
                              call map(l:dirs, {_, x ->
                                    \ (vimtex#paths#is_abs(a:path) ? '' : self.state.root . '/')
                                    \ . a:path . '/' . x})
                              call filter(l:dirs, '!isdirectory(v:val)')
                              if empty(l:dirs) | return | endif
                            
                              " Create the non-existing directories
                              call vimtex#log#warning(["Creating directorie(s):"]
                                    \ + map(copy(l:dirs), {_, x -> '* ' . x}))
                            
                              for l:dir in l:dirs
                                call mkdir(l:dir, 'p')
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:compiler._remove_dir(path) abort dict " {{{1
                              if empty(a:path) | return | endif
                            
                              let l:out_dir = vimtex#paths#is_abs(a:path)
                                    \ ? a:path
                                    \ : self.state.root . '/' . a:path
                              if !isdirectory(l:out_dir) | return | endif
                            
                              let l:tree = glob(l:out_dir . '/**/*', 0, 1)
                              let l:files = filter(copy(l:tree), 'filereadable(v:val)')
                            
                              if empty(l:files)
                                for l:dir in sort(l:tree) + [l:out_dir]
                                  call delete(l:dir, 'd')
                                endfor
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! s:compiler.create_dirs() abort dict " {{{1
                              call self._create_build_dir(self.out_dir)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler.remove_dirs() abort dict " {{{1
                              call self._remove_dir(self.out_dir)
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:compiler.get_file(ext) abort dict " {{{1
                              for l:root in [
                                    \ $VIMTEX_OUTPUT_DIRECTORY,
                                    \ self.out_dir,
                                    \ self.state.root
                                    \]
                                if empty(l:root) | continue | endif
                            
                                let l:cand = printf('%s/%s.%s', l:root, self.state.name, a:ext)
                                if !vimtex#paths#is_abs(l:root)
                                  let l:cand = self.state.root . '/' . l:cand
                                endif
                            
                                if filereadable(l:cand)
                                  return fnamemodify(l:cand, ':p')
                                endif
                              endfor
                            
                              return ''
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:compiler.clean(full) abort dict " {{{1
                              let l:extensions = ['synctex.gz', 'toc', 'out', 'aux', 'log', 'xdv', 'fls']
                              if a:full
                                call extend(l:extensions, ['pdf'])
                              endif
                            
                              call map(l:extensions, { _, x -> self.get_file(x) })
                              for l:file in filter(l:extensions, { _, x -> !empty(x) })
                                call delete(l:file)
                              endfor
                            
                              for l:expr in g:vimtex_compiler_clean_paths
                                for l:path in glob(self.state.root . '/' . l:expr, v:false, v:true)
                                  call delete(l:path, 'rf')
                                endfor
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:compiler.start(...) abort dict " {{{1
                              if self.is_running() | return | endif
                            
                              call self.create_dirs()
                            
                              " Initialize output file
                              call writefile([], self.output, 'a')
                            
                              " Prepare compile command
                              let self.cmd = self.__build_cmd()
                              let l:cmd = has('win32')
                                    \ ? 'cmd /s /c "' . self.cmd . '"'
                                    \ : ['sh', '-c', self.cmd]
                            
                              " Execute command and toggle status
                              call self.exec(l:cmd)
                              let self.status = 1
                            
                              " Use timer to check that compiler started properly
                              if self.continuous
                                let self.check_timer
                                      \ = timer_start(50, function('s:check_if_running'), {'repeat': 20})
                                let self.vimtex_id = b:vimtex_id
                                let s:check_timers[self.check_timer] = self
                              endif
                            
                              if exists('#User#VimtexEventCompileStarted')
                                doautocmd <nomodeline> User VimtexEventCompileStarted
                              endif
                            endfunction
                            
                            
    1              0.000002 let s:check_timers = {}
    1              0.000002 function! s:check_if_running(timer) abort " {{{2
                              if s:check_timers[a:timer].is_running() | return | endif
                            
                              call timer_stop(a:timer)
                              let l:compiler = remove(s:check_timers, a:timer)
                              unlet l:compiler.check_timer
                            
                              if l:compiler.vimtex_id == get(b:, 'vimtex_id', -1)
                                call vimtex#compiler#output()
                              endif
                              call vimtex#log#error('Compiler did not start successfully!')
                            endfunction
                            
                            " }}}2
                            
                            " }}}1
    1              0.000001 function! s:compiler.start_single() abort dict " {{{1
                              let l:continuous = self.continuous
                              let self.continuous = 0
                              call self.start()
                              let self.continuous = l:continuous
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler.stop() abort dict " {{{1
                              if !self.is_running() | return | endif
                            
                              silent! call timer_stop(self.check_timer)
                              let self.status = 0
                              call self.kill()
                            
                              if exists('#User#VimtexEventCompileStopped')
                                doautocmd <nomodeline> User VimtexEventCompileStopped
                              endif
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 let s:compiler_jobs = {}
    1              0.000002 function! s:compiler_jobs.exec(cmd) abort dict " {{{1
                              let l:options = {
                                    \ 'in_io': 'null',
                                    \ 'out_io': 'file',
                                    \ 'err_io': 'file',
                                    \ 'out_name': self.output,
                                    \ 'err_name': self.output,
                                    \ 'cwd': self.state.root,
                                    \}
                              if self.continuous
                                let l:options.out_io = 'pipe'
                                let l:options.err_io = 'pipe'
                                let l:options.out_cb = function('s:callback_continuous_output')
                                let l:options.err_cb = function('s:callback_continuous_output')
                              else
                                let s:cb_target = self.state.tex !=# b:vimtex.tex ? self.state.tex : ''
                                let s:cb_output = self.output
                                let l:options.exit_cb = function('s:callback')
                              endif
                            
                              let self.job = job_start(a:cmd, l:options)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:compiler_jobs.kill() abort dict " {{{1
                              call job_stop(self.job)
                              for l:dummy in range(25)
                                sleep 1m
                                if !self.is_running() | return | endif
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler_jobs.wait() abort dict " {{{1
                              for l:dummy in range(500)
                                sleep 10m
                                if !self.is_running() | return | endif
                              endfor
                            
                              call self.stop()
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:compiler_jobs.is_running() abort dict " {{{1
                              return has_key(self, 'job') && job_status(self.job) ==# 'run'
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler_jobs.get_pid() abort dict " {{{1
                              return has_key(self, 'job')
                                    \ ? get(job_info(self.job), 'process') : 0
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:callback(ch, msg) abort " {{{1
                              if !exists('b:vimtex.compiler') | return | endif
                              if b:vimtex.compiler.status == 0 | return | endif
                            
                              try
                                call vimtex#compiler#callback(2 + vimtex#qf#inquire(s:cb_target))
                              catch /E565:/
                                " In some edge cases, the callback seems to be issued while executing code
                                " in a protected context where "cclose" is not allowed with the resulting
                                " error code from compiler#callback->qf#open. The reported error message
                                " is:
                                "
                                "   E565: Not allowed to change text or change window:       cclose
                                "
                                " See https://github.com/lervag/vimtex/issues/2225
                              endtry
                            
                              if !exists('b:vimtex.compiler.hooks') | return | endif
                              try
                                let l:lines = readfile(s:cb_output)
                                for l:Hook in b:vimtex.compiler.hooks
                                  for l:line in l:lines
                                    call l:Hook(l:line)
                                  endfor
                                endfor
                              catch /E716/
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:callback_continuous_output(channel, msg) abort " {{{1
                              if exists('b:vimtex.compiler.output')
                                    \ && filewritable(b:vimtex.compiler.output)
                                call writefile([a:msg], b:vimtex.compiler.output, 'aS')
                              endif
                            
                              call s:check_callback(a:msg)
                            
                              if !exists('b:vimtex.compiler.hooks') | return | endif
                              try
                                for l:Hook in b:vimtex.compiler.hooks
                                  call l:Hook(a:msg)
                                endfor
                              catch /E716/
                              endtry
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 let s:compiler_nvim = {}
    1              0.000002 function! s:compiler_nvim.exec(cmd) abort dict " {{{1
                              let l:shell = {
                                    \ 'stdin': 'null',
                                    \ 'on_stdout': function('s:callback_nvim_output'),
                                    \ 'on_stderr': function('s:callback_nvim_output'),
                                    \ 'cwd': self.state.root,
                                    \ 'tex': self.state.tex,
                                    \ 'output': self.output,
                                    \}
                            
                              if !self.continuous
                                let l:shell.on_exit = function('s:callback_nvim_exit')
                              endif
                            
                              call vimtex#jobs#neovim#shell_default()
                              let self.job = jobstart(a:cmd, l:shell)
                              call vimtex#jobs#neovim#shell_restore()
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler_nvim.kill() abort dict " {{{1
                              call jobstop(self.job)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler_nvim.wait() abort dict " {{{1
                              let l:retvals = jobwait([self.job], 5000)
                              if empty(l:retvals) | return | endif
                              let l:status = l:retvals[0]
                              if l:status >= 0 | return | endif
                            
                              if l:status == -1 | call self.stop() | endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:compiler_nvim.is_running() abort dict " {{{1
                              try
                                let pid = jobpid(self.job)
                                return l:pid > 0
                              catch
                                return v:false
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:compiler_nvim.get_pid() abort dict " {{{1
                              try
                                return jobpid(self.job)
                              catch
                                return 0
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:callback_nvim_output(id, data, event) abort dict " {{{1
                              " Filter out unwanted newlines
                              let l:data = split(substitute(join(a:data, 'QQ'), '^QQ\|QQ$', '', ''), 'QQ')
                            
                              if !empty(l:data) && filewritable(self.output)
                                call writefile(l:data, self.output, 'a')
                              endif
                            
                              call s:check_callback(
                                    \ get(filter(copy(a:data),
                                    \   {_, x -> x =~# '^vimtex_compiler_callback'}), -1, ''))
                            
                              if !exists('b:vimtex.compiler.hooks') | return | endif
                              try
                                for l:Hook in b:vimtex.compiler.hooks
                                  call l:Hook(join(a:data, "\n"))
                                endfor
                              catch /E716/
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:callback_nvim_exit(id, data, event) abort dict " {{{1
                              if !exists('b:vimtex.compiler') | return | endif
                              if b:vimtex.compiler.status == 0 | return | endif
                            
                              let l:target = self.tex !=# b:vimtex.tex ? self.tex : ''
                              call vimtex#compiler#callback(2 + vimtex#qf#inquire(l:target))
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:check_callback(line) abort " {{{1
                              let l:status = get(s:callbacks, substitute(a:line, '\r', '', ''))
                              if l:status <= 0 | return | endif
                            
                              call vimtex#compiler#callback(l:status)
                            endfunction
                            
    1              0.000007 let s:callbacks = {
                                  \ 'vimtex_compiler_callback_compiling': 1,
                                  \ 'vimtex_compiler_callback_success': 2,
                                  \ 'vimtex_compiler_callback_failure': 3,
                                  \}
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf.vim
Sourced 1 time
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#qf#init_buffer() abort " {{{1
                              if !g:vimtex_quickfix_enabled | return | endif
                            
                              command! -buffer VimtexErrors  call vimtex#qf#toggle()
                            
                              nnoremap <buffer> <plug>(vimtex-errors)  :call vimtex#qf#toggle()<cr>
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#qf#init_state(state) abort " {{{1
                              if !g:vimtex_quickfix_enabled | return | endif
                            
                              try
                                let l:qf = vimtex#qf#{g:vimtex_quickfix_method}#new()
                                call l:qf.init(a:state)
                                unlet l:qf.init
                                let a:state.qf = l:qf
                              catch /VimTeX: Requirements not met/
                                call vimtex#log#warning(
                                      \ 'Quickfix state not initialized!',
                                      \ 'Please see :help g:vimtex_quickfix_method')
                              endtry
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#qf#toggle() abort " {{{1
                              if vimtex#qf#is_open()
                                cclose
                              else
                                call vimtex#qf#open(1)
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#qf#open(force) abort " {{{1
                              if !exists('b:vimtex.qf.addqflist') | return | endif
                            
                              try
                                call vimtex#qf#setqflist()
                              catch /VimTeX: No log file found/
                                if a:force
                                  call vimtex#log#warning('No log file found')
                                endif
                                if g:vimtex_quickfix_mode > 0
                                  cclose
                                endif
                                return
                              catch
                                call vimtex#log#error(
                                      \ 'Something went wrong when parsing log files!',
                                      \ v:exception)
                                if g:vimtex_quickfix_mode > 0
                                  cclose
                                endif
                                return
                              endtry
                            
                              if empty(getqflist())
                                if a:force
                                  call vimtex#log#info('No errors!')
                                endif
                                if g:vimtex_quickfix_mode > 0
                                  cclose
                                endif
                                return
                              endif
                            
                              "
                              " There are two options that determine when to open the quickfix window.  If
                              " forced, the quickfix window is always opened when there are errors or
                              " warnings (forced typically imply that the functions is called from the
                              " normal mode mapping).  Else the behaviour is based on the settings.
                              "
                              let l:errors_or_warnings = s:qf_has_errors()
                                    \ || g:vimtex_quickfix_open_on_warning
                            
                              if a:force || (g:vimtex_quickfix_mode > 0 && l:errors_or_warnings)
                                let s:previous_window = win_getid()
                                botright cwindow
                                if g:vimtex_quickfix_mode == 2
                                  redraw
                                  call win_gotoid(s:previous_window)
                                endif
                                if g:vimtex_quickfix_autoclose_after_keystrokes > 0
                                  augroup vimtex_qf_autoclose
                                    autocmd!
                                    autocmd CursorMoved,CursorMovedI * call s:qf_autoclose_check()
                                  augroup END
                                endif
                                redraw
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#qf#setqflist(...) abort " {{{1
                              if !exists('b:vimtex.qf.addqflist') | return | endif
                            
                              if a:0 > 0 && !empty(a:1)
                                let l:tex = a:1
                                let l:log = fnamemodify(l:tex, ':r') . '.log'
                                let l:blg = fnamemodify(l:tex, ':r') . '.blg'
                                let l:jump = 0
                              else
                                let l:tex = b:vimtex.tex
                                let l:log = b:vimtex.compiler.get_file('log')
                                let l:blg = b:vimtex.compiler.get_file('blg')
                                let l:jump = g:vimtex_quickfix_autojump
                              endif
                            
                              try
                                " Initialize the quickfix list
                                " Note: Only create new list if the current list is not a VimTeX qf list
                                if get(getqflist({'title': 1}), 'title') =~# 'VimTeX'
                                  call setqflist([], 'r')
                                else
                                  call setqflist([])
                                endif
                            
                                " Parse LaTeX errors
                                call b:vimtex.qf.addqflist(l:tex, l:log)
                            
                                " Parse bibliography errors
                                if has_key(b:vimtex.packages, 'biblatex')
                                  call vimtex#qf#biblatex#addqflist(l:blg)
                                else
                                  call vimtex#qf#bibtex#addqflist(l:blg)
                                endif
                            
                                " Ignore entries if desired
                                if !empty(g:vimtex_quickfix_ignore_filters)
                                  let l:qflist = getqflist()
                                  for l:re in g:vimtex_quickfix_ignore_filters
                                    call filter(l:qflist, 'v:val.text !~# l:re')
                                  endfor
                                  call setqflist(l:qflist, 'r')
                                endif
                            
                                " Set title if supported
                                try
                                  call setqflist([], 'r', {'title': 'VimTeX errors (' . b:vimtex.qf.name . ')'})
                                catch
                                endtry
                            
                                " Jump to first error if wanted
                                if l:jump
                                  cfirst
                                endif
                              catch /VimTeX: No log file found/
                                throw 'VimTeX: No log file found'
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#qf#inquire(file) abort " {{{1
                              try
                                call vimtex#qf#setqflist(a:file)
                                return s:qf_has_errors()
                              catch
                                return 0
                              endtry
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#qf#is_open() abort " {{{1
                              redir => l:bufstring
                              silent! ls!
                              redir END
                            
                              let l:buflist = filter(split(l:bufstring, '\n'), 'v:val =~# ''Quickfix''')
                            
                              for l:line in l:buflist
                                let l:bufnr = str2nr(matchstr(l:line, '^\s*\zs\d\+'))
                                if bufwinnr(l:bufnr) >= 0
                                      \ && getbufvar(l:bufnr, '&buftype', '') ==# 'quickfix'
                                  return 1
                                endif
                              endfor
                            
                              return 0
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:qf_has_errors() abort " {{{1
                              return len(filter(getqflist(), 'v:val.type ==# ''E''')) > 0
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:qf_autoclose_check() abort " {{{1
                              " Avoid this check if command-line window is open
                              " See :help E11
                              if bufexists("[Command Line]") | return | endif
                            
                              if get(s:, 'keystroke_counter') == 0
                                let s:keystroke_counter = g:vimtex_quickfix_autoclose_after_keystrokes
                              endif
                            
                              let l:qf_winnr = map(
                                    \ filter(getwininfo(),
                                    \   {_, x -> x.tabnr == tabpagenr() && x.quickfix && !x.loclist}),
                                    \ {_, x -> x.winnr})
                            
                              if empty(l:qf_winnr)
                                let s:keystroke_counter = 0
                              elseif l:qf_winnr[0] == winnr()
                                let s:keystroke_counter = g:vimtex_quickfix_autoclose_after_keystrokes + 1
                              else
                                let s:keystroke_counter -= 1
                              endif
                            
                              if s:keystroke_counter == 0
                                cclose
                                autocmd! vimtex_qf_autoclose
                                augroup! vimtex_qf_autoclose
                              endif
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/latexlog.vim
Sourced 1 time
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#qf#latexlog#new() abort " {{{1
                              return deepcopy(s:qf)
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000004 let s:qf = {
                                  \ 'name' : 'LaTeX logfile',
                                  \}
                            
    1              0.000002 function! s:qf.init(state) abort dict "{{{1
                              let self.types = map(
                                    \ filter(items(s:), 'v:val[0] =~# ''^type_'''),
                                    \ 'v:val[1]')
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:qf.set_errorformat() abort dict "{{{1
                              "
                              " Note: The errorformat assumes we're using the -file-line-error with
                              "       [pdf]latex. For more info, see |errorformat-LaTeX|.
                              "
                            
                              " Push file to file stack
                              setlocal errorformat=%-P**%f
                              setlocal errorformat+=%-P**\"%f\"
                            
                              " Match errors
                              setlocal errorformat+=%E!\ LaTeX\ %trror:\ %m
                              setlocal errorformat+=%E%f:%l:\ %m
                              setlocal errorformat+=%+ERunaway\ argument?
                              setlocal errorformat+=%+C{%m
                              setlocal errorformat+=%C!\ %m
                            
                              " More info for undefined control sequences
                              setlocal errorformat+=%Z<argument>\ %m
                            
                              " More info for some errors
                              setlocal errorformat+=%Cl.%l\ %m
                            
                              "
                              " Define general warnings
                              "
                              setlocal errorformat+=%+WLaTeX\ Font\ Warning:\ %.%#line\ %l%.%#
                              setlocal errorformat+=%-CLaTeX\ Font\ Warning:\ %m
                              setlocal errorformat+=%-C(Font)%m
                            
                              setlocal errorformat+=%+WLaTeX\ %.%#Warning:\ %.%#line\ %l%.%#
                              setlocal errorformat+=%+WLaTeX\ %.%#Warning:\ %m
                            
                              setlocal errorformat+=%+WOverfull\ %\\%\\hbox%.%#\ at\ lines\ %l--%*\\d
                              setlocal errorformat+=%+WOverfull\ %\\%\\hbox%.%#\ at\ line\ %l
                              setlocal errorformat+=%+WOverfull\ %\\%\\vbox%.%#\ at\ line\ %l
                            
                              setlocal errorformat+=%+WUnderfull\ %\\%\\hbox%.%#\ at\ lines\ %l--%*\\d
                              setlocal errorformat+=%+WUnderfull\ %\\%\\vbox%.%#\ at\ line\ %l
                            
                              "
                              " Define package related warnings
                              "
                              setlocal errorformat+=%+WPackage\ natbib\ Warning:\ %m\ on\ input\ line\ %l.
                            
                              setlocal errorformat+=%+WPackage\ biblatex\ Warning:\ %m
                              setlocal errorformat+=%-C(biblatex)%.%#in\ t%.%#
                              setlocal errorformat+=%-C(biblatex)%.%#Please\ v%.%#
                              setlocal errorformat+=%-C(biblatex)%.%#LaTeX\ a%.%#
                              setlocal errorformat+=%-C(biblatex)%m
                            
                              setlocal errorformat+=%+WPackage\ babel\ Warning:\ %m
                              setlocal errorformat+=%-Z(babel)%.%#input\ line\ %l.
                              setlocal errorformat+=%-C(babel)%m
                            
                              setlocal errorformat+=%+WPackage\ hyperref\ Warning:\ %m
                              setlocal errorformat+=%-C(hyperref)%m\ on\ input\ line\ %l.
                              setlocal errorformat+=%-C(hyperref)%m
                            
                              setlocal errorformat+=%+WPackage\ scrreprt\ Warning:\ %m
                              setlocal errorformat+=%-C(scrreprt)%m
                            
                              setlocal errorformat+=%+WPackage\ fixltx2e\ Warning:\ %m
                              setlocal errorformat+=%-C(fixltx2e)%m
                            
                              setlocal errorformat+=%+WPackage\ titlesec\ Warning:\ %m
                              setlocal errorformat+=%-C(titlesec)%m
                            
                              setlocal errorformat+=%+WPackage\ %.%#\ Warning:\ %m\ on\ input\ line\ %l.
                              setlocal errorformat+=%+WPackage\ %.%#\ Warning:\ %m
                              setlocal errorformat+=%-Z(%.%#)\ %m\ on\ input\ line\ %l.
                              setlocal errorformat+=%-C(%.%#)\ %m
                            
                              " Ignore unmatched lines
                              setlocal errorformat+=%-G%.%#
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:qf.addqflist(tex, log) abort dict "{{{1
                              if empty(a:log) || !filereadable(a:log)
                                throw 'VimTeX: No log file found'
                              endif
                            
                              call vimtex#qf#u#caddfile(self, fnameescape(a:log))
                            
                              " Apply some post processing of the quickfix list
                              let self.main = a:tex
                              let self.root = fnamemodify(a:tex, ':h')
                              call self.fix_paths(a:log)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:qf.fix_paths(log) abort dict " {{{1
                              let l:qflist = getqflist()
                              let l:lines = readfile(a:log)
                              let l:nlines = len(l:lines)
                              let l:hbox_cache = {'index': {}, 'paths': {}}
                            
                              for l:qf in l:qflist
                                " Handle missing buffer/filename: Fallback to the main file (this is always
                                " correct in single-file projects and is thus a good fallback).
                                if l:qf.bufnr == 0
                                  let l:bufnr_main = bufnr(self.main)
                                  if bufnr(self.main) < 0
                                    execute 'badd' self.main
                                    let l:bufnr_main = bufnr(self.main)
                                  endif
                                  let l:qf.bufnr = l:bufnr_main
                                endif
                            
                                " Try to parse the filename from logfile for certain errors, except for
                                " large log files where this makes for bad UI because it locks Vim while
                                " waiting for this parsing to finish.
                                if l:nlines < 10000
                                      \ && s:fix_paths_hbox_warning(l:qf, l:lines, self.root, l:hbox_cache)
                                  continue
                                endif
                            
                                " Check and possibly fix invalid file from file:line type entries
                                call s:fix_paths_invalid_bufname(l:qf, self.root)
                              endfor
                            
                              call setqflist(l:qflist, 'r')
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 function! s:fix_paths_hbox_warning(qf, log, root, cache) abort " {{{1
                              if a:qf.text !~# 'Underfull\|Overfull' | return v:false | endif
                            
                              let l:index = index(a:log, a:qf.text)
                              if l:index < 0 | return v:false | endif
                            
                              " Check index cache first
                              if has_key(a:cache.index, l:index)
                                if has_key(a:cache.index[l:index], 'bufnr')
                                  let a:qf.bufnr = a:cache.index[l:index].bufnr
                                else
                                  let a:qf.bufnr = 0
                                  let a:qf.filename = a:cache.index[l:index].filename
                                endif
                                return v:true
                              endif
                            
                              " Search for a line above the Overflow/Underflow message that specifies the
                              " correct source filename
                              let l:file = ''
                              let l:level = 1
                              for l:lnum in range(l:index - 1, 1, -1)
                                " Check line number cache
                                if has_key(a:cache.paths, l:lnum)
                                  let l:file = a:cache.paths[l:lnum]
                                  let a:cache.paths[l:index] = l:file
                                  break
                                endif
                            
                                let l:level += vimtex#util#count(a:log[l:lnum], ')')
                                let l:level -= vimtex#util#count(a:log[l:lnum], '(')
                                if l:lnum < l:index - 1 && l:level > 0 | continue | endif
                            
                                let l:file = matchstr(a:log[l:lnum], '\v\(\zs\f+\ze\)?\s*%(\[\d+]?)?$')
                                if !empty(l:file)
                                  " Do some simple parsing and cleanup of the filename
                                  if !vimtex#paths#is_abs(l:file)
                                    let l:file = simplify(a:root . '/' . l:file)
                                  endif
                            
                                  " Store in line number cache
                                  let a:cache.paths[l:index] = l:file
                                  break
                                endif
                              endfor
                            
                              if empty(l:file) || !filereadable(l:file) | return v:false | endif
                            
                              let l:bufnr = bufnr(l:file)
                              if l:bufnr > 0
                                let a:qf.bufnr = bufnr(l:file)
                                let a:cache.index[l:index] = {'bufnr': a:qf.bufnr}
                              else
                                let a:qf.bufnr = 0
                                let a:qf.filename = fnamemodify(l:file, ':.')
                                let a:cache.index[l:index] = {'filename': a:qf.filename}
                              endif
                            
                              return v:true
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:fix_paths_invalid_bufname(qf, root) abort " {{{1
                              " First check if the entry bufnr is already valid
                              let l:file = getbufinfo(a:qf.bufnr)[0].name
                              if filereadable(l:file) | return | endif
                            
                              " The file names of all file:line type entries in the log output are listed
                              " relative to the root of the main LaTeX file. The quickfix mechanism adds
                              " the buffer with the file string. Thus, if the current buffer is not
                              " correct, we can fix by prepending the root to the filename.
                              let l:file = fnamemodify(
                                    \ simplify(a:root . '/' . bufname(a:qf.bufnr)), ':.')
                              if !filereadable(l:file) | return | endif
                            
                              let l:bufnr = bufnr(l:file)
                              if l:bufnr > 0
                                let a:qf.bufnr = bufnr(l:file)
                              else
                                let a:qf.bufnr = 0
                                let a:qf.filename = l:file
                              endif
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/toc.vim
Sourced 1 time
Total time:   0.000418
 Self time:   0.000418

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#toc#init_buffer() abort " {{{1
                              if !g:vimtex_toc_enabled | return | endif
                            
                              command! -buffer VimtexTocOpen   call b:vimtex.toc.open()
                              command! -buffer VimtexTocToggle call b:vimtex.toc.toggle()
                            
                              nnoremap <buffer> <plug>(vimtex-toc-open)   :call b:vimtex.toc.open()<cr>
                              nnoremap <buffer> <plug>(vimtex-toc-toggle) :call b:vimtex.toc.toggle()<cr>
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#toc#init_state(state) abort " {{{1
                              if !g:vimtex_toc_enabled | return | endif
                            
                              let a:state.toc = vimtex#toc#new()
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#toc#new(...) abort " {{{1
                              return extend(
                                    \ deepcopy(s:toc),
                                    \ vimtex#util#extend_recursive(
                                    \   deepcopy(g:vimtex_toc_config),
                                    \   a:0 > 0 ? a:1 : {}))
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#toc#get_entries() abort " {{{1
                              if !has_key(b:vimtex, 'toc') | return [] | endif
                            
                              return b:vimtex.toc.get_entries(0)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#toc#refresh() abort " {{{1
                              if has_key(b:vimtex, 'toc')
                                call b:vimtex.toc.get_entries(1)
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 let s:toc = {}
                            
                            "
                            " Open and close TOC window
                            "
    1              0.000002 function! s:toc.open() abort dict " {{{1
                              if self.is_open() | return | endif
                            
                              if has_key(self, 'layers')
                                for l:key in keys(self.layer_status)
                                  let self.layer_status[l:key] = index(self.layers, l:key) >= 0
                                endfor
                              endif
                            
                              let self.calling_file = expand('%:p')
                              let self.calling_line = line('.')
                            
                              call self.get_entries(0)
                            
                              if self.mode > 1
                                call setloclist(0, map(filter(deepcopy(self.entries), 'v:val.active'),
                                      \ {_, x -> {
                                      \   'lnum': x.line,
                                      \   'filename': x.file,
                                      \   'text': x.title,
                                      \ }
                                      \}))
                                try
                                  call setloclist(0, [], 'r', {'title': self.name})
                                catch
                                endtry
                                if self.mode == 4 | lopen | endif
                              endif
                            
                              if self.mode < 3
                                call self.create()
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:toc.is_open() abort dict " {{{1
                              return bufwinnr(bufnr(self.name)) >= 0
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.toggle() abort dict " {{{1
                              if self.is_open()
                                call self.close()
                              else
                                call self.open()
                                if has_key(self, 'winid_prev')
                                  call win_gotoid(self.winid_prev)
                                endif
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.close() abort dict " {{{1
                              let self.fold_level = &l:foldlevel
                            
                              if self.resize
                                silent exe 'set columns -=' . self.split_width
                              endif
                            
                              if self.split_pos ==# 'full'
                                silent execute 'buffer' self.bufnr_prev
                              else
                                silent execute 'bwipeout' bufnr(self.name)
                              endif
                            
                              if self.bufnr_alternate >= 0
                                let @# = self.bufnr_alternate
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.goto() abort dict " {{{1
                              if self.is_open()
                                let l:winid_prev = win_getid()
                                silent execute bufwinnr(bufnr(self.name)) . 'wincmd w'
                                let b:toc.winid_prev = l:winid_prev
                              endif
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Get the TOC entries
                            "
    1              0.000002 function! s:toc.get_entries(force) abort dict " {{{1
                              if has_key(self, 'entries') && !self.refresh_always && !a:force
                                return self.entries
                              endif
                            
                              let self.entries = vimtex#parser#toc()
                              let self.topmatters = vimtex#parser#toc#get_topmatters()
                            
                              "
                              " Sort todo entries
                              "
                              if self.todo_sorted
                                let l:todos = filter(copy(self.entries), 'v:val.type ==# ''todo''')
                                for l:t in l:todos[1:]
                                  let l:t.level = 1
                                endfor
                                call filter(self.entries, 'v:val.type !=# ''todo''')
                                let self.entries = l:todos + self.entries
                              endif
                            
                              "
                              " Add hotkeys to entries
                              "
                              if self.hotkeys_enabled
                                let k = strwidth(self.hotkeys)
                                let n = len(self.entries)
                                let m = len(s:base(n, k))
                                let i = 0
                                for entry in self.entries
                                  let keys = map(s:base(i, k), 'strcharpart(self.hotkeys, v:val, 1)')
                                  let keys = repeat([self.hotkeys[0]], m - len(keys)) + keys
                                  let i+=1
                                  let entry.num = i
                                  let entry.hotkey = join(keys, '')
                                endfor
                              endif
                            
                              "
                              " Apply active layers
                              "
                              for entry in self.entries
                                let entry.active = self.layer_status[entry.type]
                              endfor
                            
                              "
                              " Refresh if wanted
                              "
                              if a:force && self.is_open()
                                call self.refresh()
                              endif
                            
                              return self.entries
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:toc.get_visible_entries() abort dict " {{{1
                              return filter(deepcopy(get(self, 'entries', [])),
                                    \ 'self.entry_is_visible(v:val)')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:toc.entry_is_visible(entry) abort " {{{1
                              return get(a:entry, 'active', 1) && !get(a:entry, 'hidden')
                                    \ && (a:entry.type !=# 'content' || a:entry.level <= self.tocdepth)
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Creating, refreshing and filling the buffer
                            "
    1              0.000001 function! s:toc.create() abort dict " {{{1
                              let l:bufnr = bufnr('')
                              let l:bufnr_alternate = bufnr('#')
                              let l:winid = win_getid()
                              let l:vimtex = get(b:, 'vimtex', {})
                              let l:vimtex_syntax = get(b:, 'vimtex_syntax', {})
                            
                              if self.split_pos ==# 'full'
                                silent execute 'edit' escape(self.name, ' ')
                              else
                                if self.resize
                                  silent exe 'set columns +=' . self.split_width
                                endif
                                silent execute
                                      \ self.split_pos self.split_width
                                      \ 'new' escape(self.name, ' ')
                              endif
                            
                              let self.bufnr_prev = l:bufnr
                              let self.bufnr_alternate = l:bufnr_alternate
                              let self.winid_prev = l:winid
                              let b:toc = self
                              let b:vimtex = l:vimtex
                              let b:vimtex_syntax = l:vimtex_syntax
                            
                              setlocal noreadonly
                              setlocal bufhidden=wipe
                              setlocal buftype=nofile
                              setlocal filetype=vimtex-toc
                              setlocal concealcursor=nvic
                              setlocal conceallevel=2
                              setlocal cursorline
                              setlocal nobuflisted
                              setlocal nolist
                              setlocal nospell
                              setlocal noswapfile
                              setlocal nowrap
                              setlocal tabstop=8
                              setlocal winfixwidth
                              setlocal winfixheight
                            
                              if self.hide_line_numbers
                                setlocal nonumber
                                setlocal norelativenumber
                              endif
                            
                              call self.refresh()
                              call self.set_syntax()
                            
                              if self.fold_enable
                                let self.foldexpr = function('s:foldexpr')
                                let self.foldtext  = function('s:foldtext')
                                setlocal foldmethod=expr
                                setlocal foldexpr=b:toc.foldexpr(v:lnum)
                                setlocal foldtext=b:toc.foldtext()
                                let &l:foldlevel = get(self, 'fold_level',
                                      \ (self.fold_level_start > 0
                                      \ ? self.fold_level_start
                                      \ : self.tocdepth))
                              endif
                            
                              nnoremap <silent><buffer><nowait><expr> gg b:toc.show_help ? 'gg}}j' : 'gg'
                              nnoremap <silent><buffer><nowait> <esc>OA k
                              nnoremap <silent><buffer><nowait> <esc>OB j
                              nnoremap <silent><buffer><nowait> <esc>OC k
                              nnoremap <silent><buffer><nowait> <esc>OD j
                              nnoremap <silent><buffer><nowait> q             :call b:toc.close()<cr>
                              nnoremap <silent><buffer><nowait> <esc>         :call b:toc.close()<cr>
                              nnoremap <silent><buffer><nowait> <space>       :call b:toc.activate_current(0)<cr>
                              nnoremap <silent><buffer><nowait> <2-leftmouse> :call b:toc.activate_current(0)<cr>
                              nnoremap <silent><buffer><nowait> <cr>          :call b:toc.activate_current(1)<cr>
                              nnoremap <silent><buffer><nowait> h             :call b:toc.toggle_help()<cr>
                              nnoremap <silent><buffer><nowait> f             :call b:toc.filter()<cr>
                              nnoremap <silent><buffer><nowait> F             :call b:toc.clear_filter()<cr>
                              nnoremap <silent><buffer><nowait> s             :call b:toc.toggle_numbers()<cr>
                              nnoremap <silent><buffer><nowait> t             :call b:toc.toggle_sorted_todos()<cr>
                              nnoremap <silent><buffer><nowait> r             :call b:toc.get_entries(1)<cr>
                              nnoremap <silent><buffer><nowait> -             :call b:toc.decrease_depth()<cr>
                              nnoremap <silent><buffer><nowait> +             :call b:toc.increase_depth()<cr>
                            
                              command! -buffer VimtexTocToggle call b:toc.close()
                            
                              for [type, key] in items(self.layer_keys)
                                execute printf(
                                      \ 'nnoremap <silent><buffer><nowait> %s'
                                      \ . ' :call b:toc.toggle_type(''%s'')<cr>',
                                      \ key, type)
                              endfor
                            
                              if self.hotkeys_enabled
                                for entry in self.entries
                                  execute printf(
                                        \ 'nnoremap <silent><buffer><nowait> %s%s'
                                        \ . ' :call b:toc.activate_hotkey(''%s'')<cr>',
                                        \ self.hotkeys_leader, entry.hotkey, entry.hotkey)
                                endfor
                              endif
                            
                              " Jump to closest index
                              call vimtex#pos#set_cursor(self.get_closest_index())
                            
                              if exists('#User#VimtexEventTocCreated')
                                doautocmd <nomodeline> User VimtexEventTocCreated
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.refresh() abort dict " {{{1
                              let l:toc_winnr = bufwinnr(bufnr(self.name))
                              let l:buf_winnr = bufwinnr(bufnr(''))
                            
                              if l:toc_winnr < 0
                                return
                              elseif l:buf_winnr != l:toc_winnr
                                silent execute l:toc_winnr . 'wincmd w'
                              endif
                            
                              call self.position_save()
                              setlocal modifiable
                              silent %delete _
                            
                              call self.print_help()
                              call self.print_entries()
                            
                              0delete _
                              setlocal nomodifiable
                              call self.position_restore()
                            
                              if l:buf_winnr != l:toc_winnr
                                silent execute l:buf_winnr . 'wincmd w'
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.set_syntax() abort dict "{{{1
                              syntax clear
                            
                              execute 'syntax match VimtexTocHelp'
                                    \ '/^\%<' . self.help_nlines . 'l.*/'
                                    \ 'contains=VimtexTocHelpKey,VimtexTocHelpLayerOn,VimtexTocHelpLayerOff'
                            
                              if self.show_help
                                syntax match VimtexTocHelpKey /<\S*>/ contained
                                syntax match VimtexTocHelpKey /^\s*[-+<>a-zA-Z\/]\+\ze\s/ contained
                                      \ contains=VimtexTocHelpKeySeparator
                                syntax match VimtexTocHelpKey /^Layers:\s*\zs[-+<>a-zA-Z\/]\+/ contained
                                syntax match VimtexTocHelpKeySeparator /\// contained
                            
                                syntax match VimtexTocHelpLayerOn /\w\++/ contained
                                      \ contains=VimtexTocHelpConceal
                                syntax match VimtexTocHelpLayerOff /(hidden)/ contained
                                syntax match VimtexTocHelpLayerOff /\w\+-/ contained
                                      \ contains=VimtexTocHelpConceal
                                syntax match VimtexTocHelpConceal /[+-]/ contained conceal
                            
                                highlight link VimtexTocHelpKeySeparator VimtexTocHelp
                              else
                                syntax match VimtexTocHelpKey / h / contained
                              endif
                            
                              execute 'syntax match VimtexTocTodo'
                                    \ '"\v\zs%('
                                    \   . toupper(join(keys(g:vimtex_toc_todo_labels), '|')) . '):\ze "'
                                    \ 'contained'
                              syntax match VimtexTocTodo "\v\zs%(an)?fxnote:\ze " contained
                              syntax match VimtexTocWarning "\v\zs%(an)?fxwarning:\ze " contained
                              syntax match VimtexTocError "\v\zs%(an)?fxerror:\ze " contained
                              syntax match VimtexTocFatal "\v\zs%(an)?fxfatal:\ze " contained
                            
                              syntax match VimtexTocInclPath /.*/ contained
                              syntax match VimtexTocIncl /\w\+ incl:/ contained
                                    \ nextgroup=VimtexTocInclPath
                            
                              syntax match VimtexTocLabelsSecs /\v(chap|(sub)*sec):.*$/ contained
                              syntax match VimtexTocLabelsEq   /eq:.*$/ contained
                              syntax match VimtexTocLabelsFig  /fig:.*$/ contained
                              syntax match VimtexTocLabelsTab  /tab:.*$/ contained
                            
                              syntax cluster VimtexTocTitleStuff add=VimtexTocIncl
                              syntax cluster VimtexTocTitleStuff add=VimtexTocTodo
                              syntax cluster VimtexTocTitleStuff add=VimtexTocWarning
                              syntax cluster VimtexTocTitleStuff add=VimtexTocError
                              syntax cluster VimtexTocTitleStuff add=VimtexTocFatal
                              syntax cluster VimtexTocTitleStuff add=VimtexTocLabelsSecs
                              syntax cluster VimtexTocTitleStuff add=VimtexTocLabelsEq
                              syntax cluster VimtexTocTitleStuff add=VimtexTocLabelsFig
                              syntax cluster VimtexTocTitleStuff add=VimtexTocLabelsTab
                              syntax cluster VimtexTocTitleStuff add=@Tex
                            
                              syntax match VimtexTocTitle /.*$/ contained transparent
                                    \ contains=@VimtexTocTitleStuff
                              syntax match VimtexTocNum /\v(([A-Z]+>|\d+)(\.\d+)*)?\s*/ contained
                                    \ nextgroup=VimtexTocTitle
                              syntax match VimtexTocHotkey /\[[^] ]\+\]\s*/ contained
                                    \ nextgroup=VimtexTocNum
                              syntax match VimtexTocSecLabel /^L\d / contained conceal
                                    \ nextgroup=VimtexTocHotkey,VimtexTocNum,VimtexTocTitle
                            
                              syntax match VimtexTocSec0 /^L0.*/     contains=VimtexTocSecLabel
                              syntax match VimtexTocSec1 /^L1.*/     contains=VimtexTocSecLabel
                              syntax match VimtexTocSec2 /^L2.*/     contains=VimtexTocSecLabel
                              syntax match VimtexTocSec3 /^L3.*/     contains=VimtexTocSecLabel
                              syntax match VimtexTocSec4 /^L[4-9].*/ contains=VimtexTocSecLabel
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Print the TOC entries
                            "
    1              0.000001 function! s:toc.print_help() abort dict " {{{1
                              if !self.show_help
                                call append('$', ['Press h to toggle help text.', ''])
                                let self.help_nlines = 2
                                return
                              endif
                            
                              let help_text = [
                                    \ '      h  Toggle help text',
                                    \ '<Esc>/q  Close',
                                    \ '<Space>  Jump',
                                    \ '<Enter>  Jump and close',
                                    \ '      r  Refresh',
                                    \ '      h  Toggle help text',
                                    \ '      t  Toggle sorted TODOs',
                                    \ '    -/+  Decrease/increase ToC depth (for content layer)',
                                    \ '    f/F  Apply/clear filter',
                                    \]
                            
                              if self.layer_status.content
                                call add(help_text, '      s  Hide numbering')
                              endif
                              call add(help_text, '')
                            
                              let l:first = 1
                              let l:frmt = printf('%%-%ds',
                                    \ max(map(values(self.layer_keys), 'strlen(v:val)')) + 2)
                              for [layer, status] in items(self.layer_status)
                                call add(help_text,
                                      \ (l:first ? 'Layers:  ' : '         ')
                                      \ . printf(l:frmt, self.layer_keys[layer])
                                      \ . layer . (status ? '+' : '- (hidden)'))
                                let l:first = 0
                              endfor
                            
                              call append('$', help_text)
                              call append('$', '')
                            
                              let self.help_nlines = len(help_text) + 1
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.print_entries() abort dict " {{{1
                              call self.set_number_format()
                            
                              for entry in self.get_visible_entries()
                                call self.print_entry(entry)
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:toc.print_entry(entry) abort dict " {{{1
                              let output = 'L' . a:entry.level . ' '
                            
                              if self.hotkeys_enabled
                                let output .= printf('[%S] ', a:entry.hotkey)
                              endif
                            
                              if self.indent_levels
                                let output .= repeat('  ', a:entry.level)
                              endif
                            
                              if self.show_numbers
                                let number = a:entry.level >= self.tocdepth + 2 ? ''
                                      \ : strpart(self.print_number(a:entry.number),
                                      \           0, self.number_width - 1)
                                let output .= printf(self.number_format, number)
                              endif
                            
                              let output .= a:entry.title
                            
                              call append('$', output)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:toc.print_number(number) abort dict " {{{1
                              if empty(a:number) | return '' | endif
                              if type(a:number) == v:t_string | return a:number | endif
                            
                              if get(a:number, 'part_toggle')
                                return s:int_to_roman(a:number.part)
                              endif
                            
                              let number = [
                                    \ a:number.chapter,
                                    \ a:number.section,
                                    \ a:number.subsection,
                                    \ a:number.subsubsection,
                                    \ a:number.subsubsubsection,
                                    \ ]
                            
                              " Remove unused parts
                              while len(number) > 0 && number[0] == 0
                                call remove(number, 0)
                              endwhile
                              while len(number) > 0 && number[-1] == 0
                                call remove(number, -1)
                              endwhile
                            
                              " Change numbering in frontmatter, appendix, and backmatter
                              if self.topmatters > 1
                                    \ && (a:number.frontmatter || a:number.backmatter)
                                return ''
                              elseif a:number.appendix
                                let number[0] = nr2char(number[0] + 64)
                              endif
                            
                              return join(number, '.')
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.set_number_format() abort dict " {{{1
                              let number_width = 0
                              for entry in self.get_visible_entries()
                                let number_width = max([number_width, strlen(self.print_number(entry.number)) + 1])
                              endfor
                            
                              let self.number_width = self.layer_status.content
                                    \ ? max([0, min([2*(self.tocdepth + 2), number_width])])
                                    \ : 0
                              let self.number_format = '%-' . self.number_width . 's'
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Interactions with TOC buffer/window
                            "
    1              0.000002 function! s:toc.activate_current(close_after) abort dict "{{{1
                              let n = vimtex#pos#get_cursor_line() - 1
                              if n < self.help_nlines | return {} | endif
                            
                              let l:count = 0
                              for l:entry in self.get_visible_entries()
                                if l:count == n - self.help_nlines
                                  return self.activate_entry(l:entry, a:close_after)
                                endif
                                let l:count += 1
                              endfor
                            
                              return {}
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:toc.activate_hotkey(key) abort dict "{{{1
                              for entry in self.entries
                                if entry.hotkey ==# a:key
                                  return self.activate_entry(entry, 1)
                                endif
                              endfor
                            
                              return {}
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:toc.activate_entry(entry, close_after) abort dict "{{{1
                              let self.prev_index = vimtex#pos#get_cursor_line()
                              let l:vimtex_main = get(b:vimtex, 'tex', '')
                            
                              " Save toc winnr info for later use
                              let toc_winnr = winnr()
                            
                              " Return to calling window
                              call win_gotoid(self.winid_prev)
                            
                              " Get buffer number, add buffer if necessary
                              let bnr = bufnr(a:entry.file)
                              if bnr == -1
                                execute 'badd ' . fnameescape(a:entry.file)
                                let bnr = bufnr(a:entry.file)
                              endif
                            
                              " Set bufferopen command
                              "   The point here is to use existing open buffer if the user has turned on
                              "   the &switchbuf option to either 'useopen' or 'usetab'
                              let cmd = 'buffer! '
                              if &switchbuf =~# 'usetab'
                                for i in range(tabpagenr('$'))
                                  if index(tabpagebuflist(i + 1), bnr) >= 0
                                    let cmd = 'sbuffer! '
                                    break
                                  endif
                                endfor
                              elseif &switchbuf =~# 'useopen'
                                if bufwinnr(bnr) > 0
                                  let cmd = 'sbuffer! '
                                endif
                              endif
                            
                              " Open file buffer
                              execute 'keepalt' cmd bnr
                            
                              " Go to entry line
                              if has_key(a:entry, 'line')
                                call vimtex#pos#set_cursor(a:entry.line, 0)
                              endif
                            
                              " If relevant, enable VimTeX stuff
                              if get(a:entry, 'link', 0) && !empty(l:vimtex_main)
                                let b:vimtex_main = l:vimtex_main
                                call vimtex#init()
                              endif
                            
                              " Ensure folds are opened
                              normal! zv
                            
                              " Keep or close toc window (based on options)
                              " Note: Ensure alternate buffer is restored
                              if a:close_after && self.split_pos !=# 'full'
                                call self.close()
                              elseif self.bufnr_alternate >= 0
                                let @# = self.bufnr_alternate
                              endif
                            
                              " Allow user entry points through autocmd events
                              if exists('#User#VimtexEventTocActivated')
                                doautocmd <nomodeline> User VimtexEventTocActivated
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.toggle_help() abort dict "{{{1
                              let l:pos = vimtex#pos#get_cursor()
                              let l:pos[1] = max([l:pos[1] - self.help_nlines, 1])
                            
                              let self.show_help = !self.show_help
                              call self.refresh()
                              call self.set_syntax()
                            
                              let l:pos[1] += self.help_nlines
                              call vimtex#pos#set_cursor(l:pos)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.toggle_numbers() abort dict "{{{1
                              let self.show_numbers = self.show_numbers ? 0 : 1
                              call self.refresh()
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.toggle_sorted_todos() abort dict "{{{1
                              let self.todo_sorted = self.todo_sorted ? 0 : 1
                              call self.get_entries(1)
                              call vimtex#pos#set_cursor(self.get_closest_index())
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:toc.toggle_type(type) abort dict "{{{1
                              let self.layer_status[a:type] = !self.layer_status[a:type]
                              for entry in self.entries
                                if entry.type ==# a:type
                                  let entry.active = self.layer_status[a:type]
                                endif
                              endfor
                              call self.refresh()
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.decrease_depth() abort dict "{{{1
                              let self.tocdepth = max([self.tocdepth - 1, -2])
                              call self.refresh()
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.increase_depth() abort dict "{{{1
                              let self.tocdepth = min([self.tocdepth + 1, 5])
                              call self.refresh()
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.filter() dict abort "{{{1
                              let re_filter = input('filter entry title by: ')
                              for entry in self.entries
                                let entry.hidden = get(entry, 'hidden') || entry.title !~# re_filter
                              endfor
                              call self.refresh()
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.clear_filter() dict abort "{{{1
                              for entry in self.entries
                                let entry.hidden = 0
                              endfor
                              call self.refresh()
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Utility functions
                            "
    1              0.000001 function! s:toc.get_closest_index() abort dict " {{{1
                              let l:calling_rank = 0
                              let l:not_found = 1
                              for [l:file, l:lnum, l:line] in vimtex#parser#tex(b:vimtex.tex)
                                let l:calling_rank += 1
                                if l:file ==# self.calling_file && l:lnum >= self.calling_line
                                  let l:not_found = 0
                                  break
                                endif
                              endfor
                            
                              if l:not_found
                                return [0, get(self, 'prev_index', self.help_nlines + 1), 0, 0]
                              endif
                            
                              let l:index = 0
                              let l:dist = 0
                              let l:closest_index = 1
                              let l:closest_dist = 10000
                              for l:entry in self.get_visible_entries()
                                let l:index += 1
                                let l:dist = l:calling_rank - entry.rank
                            
                                if l:dist >= 0 && l:dist < l:closest_dist
                                  let l:closest_dist = l:dist
                                  let l:closest_index = l:index
                                endif
                              endfor
                            
                              return [0, l:closest_index + self.help_nlines, 0, 0]
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.position_save() abort dict " {{{1
                              let self.position = vimtex#pos#get_cursor()
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:toc.position_restore() abort dict " {{{1
                              if self.position[1] <= self.help_nlines
                                let self.position[1] = self.help_nlines + 1
                              endif
                              call vimtex#pos#set_cursor(self.position)
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:foldexpr(lnum) abort " {{{1
                              let pline = getline(a:lnum - 1)
                              let cline = getline(a:lnum)
                              let nline = getline(a:lnum + 1)
                              let l:pn = matchstr(pline, '^L\zs\d')
                              let l:cn = matchstr(cline, '^L\zs\d')
                              let l:nn = matchstr(nline, '^L\zs\d')
                            
                              " Don't fold options
                              if cline =~# '^\s*$'
                                return 0
                              endif
                            
                              if l:nn > l:cn
                                return '>' . l:nn
                              endif
                            
                              if l:cn < l:pn
                                return l:cn
                              endif
                            
                              return '='
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:foldtext() abort " {{{1
                              let l:line = getline(v:foldstart)[3:]
                              if b:toc.todo_sorted
                                    \ && l:line =~# '\v%(' . join(keys(g:vimtex_toc_todo_labels), '|') . ')'
                                return substitute(l:line, '\w+\zs:.*', 's', '')
                              else
                                return l:line
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:int_to_roman(number) abort " {{{1
                              let l:number = a:number
                              let l:result = ''
                              for [l:val, l:romn] in [
                                    \ ['1000', 'M'],
                                    \ ['900', 'CM'],
                                    \ ['500', 'D'],
                                    \ ['400', 'CD' ],
                                    \ ['100', 'C'],
                                    \ ['90', 'XC'],
                                    \ ['50', 'L'],
                                    \ ['40', 'XL'],
                                    \ ['10', 'X'],
                                    \ ['9', 'IX'],
                                    \ ['5', 'V'],
                                    \ ['4', 'IV'],
                                    \ ['1', 'I'],
                                    \]
                                while l:number >= l:val
                                  let l:number -= l:val
                                  let l:result .= l:romn
                                endwhile
                              endfor
                            
                              return l:result
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:base(n, k) abort " {{{1
                              if a:n < a:k
                                return [a:n]
                              else
                                return add(s:base(a:n/a:k, a:k), a:n % a:k)
                              endif
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold.vim
Sourced 1 time
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fold#init_buffer() abort " {{{1
                              if !g:vimtex_fold_enabled
                                    \ || s:foldmethod_in_modeline() | return | endif
                            
                              " Set fold options
                              setlocal foldmethod=expr
                              setlocal foldexpr=vimtex#fold#level(v:lnum)
                              setlocal foldtext=vimtex#fold#text()
                            
                              if g:vimtex_fold_manual
                                " Remap zx to refresh fold levels
                                nnoremap <silent><buffer><nowait> zx :call vimtex#fold#refresh('zx')<cr>
                                nnoremap <silent><buffer><nowait> zX :call vimtex#fold#refresh('zX')<cr>
                            
                                " Define commands
                                command! -buffer VimtexRefreshFolds call vimtex#fold#refresh('zx')
                            
                                " Ensure that folds are refreshed on startup
                                augroup vimtex_temporary
                                  autocmd! * <buffer>
                                  autocmd CursorMoved <buffer>
                                        \   call vimtex#fold#refresh('zx')
                                        \ | autocmd! vimtex_temporary CursorMoved <buffer>
                                augroup END
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#fold#init_state(state) abort " {{{1
                              "
                              " Initialize the enabled fold types
                              "
                              let a:state.fold_types_dict = {}
                              for [l:key, l:val] in items(g:vimtex_fold_types_defaults)
                                let l:config = extend(deepcopy(l:val), get(g:vimtex_fold_types, l:key, {}))
                                if get(l:config, 'enabled', 1)
                                  let a:state.fold_types_dict[l:key] = vimtex#fold#{l:key}#new(l:config)
                                endif
                              endfor
                            
                              "
                              " Define ordered list and the global fold regex
                              "
                              let a:state.fold_types_ordered = []
                              let a:state.fold_re = '\v'
                                    \ .  '\\%(begin|end)>'
                                    \ . '|^\s*\%'
                                    \ . '|^\s*\]\s*%(\{|$)'
                                    \ . '|^\s*}'
                              let a:state.fold_re_next = ''
                              for l:name in [
                                    \ 'preamble',
                                    \ 'cmd_single',
                                    \ 'cmd_single_opt',
                                    \ 'cmd_multi',
                                    \ 'cmd_addplot',
                                    \ 'sections',
                                    \ 'markers',
                                    \ 'comments',
                                    \ 'items',
                                    \ 'envs',
                                    \ 'env_options',
                                    \]
                                let l:type = get(a:state.fold_types_dict, l:name, {})
                                if !empty(l:type)
                                  call add(a:state.fold_types_ordered, l:type)
                                  if exists('l:type.re.fold_re')
                                    let a:state.fold_re .= '|' . l:type.re.fold_re
                                  endif
                                  if exists('l:type.re.fold_re_next')
                                    let a:state.fold_re_next .=
                                          \ (empty(a:state.fold_re_next) ? '\v' : '|')
                                          \ . l:type.re.fold_re_next
                                  endif
                                endif
                              endfor
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#fold#refresh(map) abort " {{{1
                              if &diff
                                setlocal foldmethod=diff
                              else
                                setlocal foldmethod=expr
                                execute 'normal!' a:map
                                setlocal foldmethod=manual
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#fold#level(lnum) abort " {{{1
                              let l:line = getline(a:lnum)
                              let l:next = getline(a:lnum + 1)
                            
                              " Never fold \begin|end{document}
                              if l:line =~# '^\s*\\\%(begin\|end\){document}'
                                return 0
                              endif
                            
                              " Optimize: Filter out irrelevant lines
                              if l:line !~# b:vimtex.fold_re && l:next !~# b:vimtex.fold_re_next
                                return '='
                              endif
                            
                              for l:type in b:vimtex.fold_types_ordered
                                let l:value = l:type.level(l:line, a:lnum)
                                if !empty(l:value) | return l:value | endif
                              endfor
                            
                              return '='
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#fold#text() abort " {{{1
                              let l:line = getline(v:foldstart)
                              let l:level = v:foldlevel > 1
                                    \ ? repeat('-', v:foldlevel-2) . g:vimtex_fold_levelmarker
                                    \ : ''
                            
                              for l:type in b:vimtex.fold_types_ordered
                                if l:line =~# l:type.re.start
                                  let l:text = l:type.text(l:line, l:level)
                                  if !empty(l:text) | return l:text | endif
                                endif
                              endfor
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:foldmethod_in_modeline() abort " {{{1
                              let l:cursor_pos = vimtex#pos#get_cursor()
                              let l:fdm_modeline = 'vim:.*\%(foldmethod\|fdm\)'
                            
                              call vimtex#pos#set_cursor(1, 1)
                              let l:check_top = search(l:fdm_modeline, 'cn', &modelines)
                            
                              normal! G$
                              let l:check_btm = search(l:fdm_modeline, 'b', line('$') + 1 - &modelines)
                            
                              call vimtex#pos#set_cursor(l:cursor_pos)
                              return l:check_top || l:check_btm
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/envs.vim
Sourced 1 time
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fold#envs#new(config) abort " {{{1
                              return extend(deepcopy(s:folder), a:config).init()
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000017 let s:folder = {
                                  \ 'name' : 'environments',
                                  \ 're' : {
                                  \   'start' : g:vimtex#re#not_comment . '\\begin\s*\{.{-}\}',
                                  \   'end' : g:vimtex#re#not_comment . '\\end\s*\{.{-}\}',
                                  \   'name' : g:vimtex#re#not_comment . '\\%(begin|end)\s*\{\zs.{-}\ze\}'
                                  \ },
                                  \ 'whitelist' : [],
                                  \ 'blacklist' : [],
                                  \}
    1              0.000002 function! s:folder.init() abort dict " {{{1
                              " Define the validator as simple as possible
                              if empty(self.whitelist) && empty(self.blacklist)
                                function! self.validate(env) abort dict
                                  return 1
                                endfunction
                              elseif empty(self.whitelist)
                                function! self.validate(env) abort dict
                                  return index(self.blacklist, a:env) < 0
                                endfunction
                              elseif empty(self.blacklist)
                                function! self.validate(env) abort dict
                                  return index(self.whitelist, a:env) >= 0
                                endfunction
                              else
                                function! self.validate(env) abort dict
                                  return index(self.whitelist, a:env) >= 0 && index(self.blacklist, a:env) < 0
                                endfunction
                              endif
                            
                              return self
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.level(line, lnum) abort dict " {{{1
                              let l:env = matchstr(a:line, self.re.name)
                            
                              if !empty(l:env) && self.validate(l:env)
                                if a:line =~# self.re.start
                                  if a:line !~# '\\end'
                                    return 'a1'
                                  endif
                                elseif a:line =~# self.re.end
                                  if a:line !~# '\\begin'
                                    return 's1'
                                  endif
                                endif
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.text(line, level) abort dict " {{{1
                              let env = matchstr(a:line, self.re.name)
                              if !self.validate(env) | return | endif
                            
                              " Set caption/label based on type of environment
                              if env ==# 'frame'
                                let option = ''
                                let label = ''
                                let caption = self.parse_caption_frame(a:line)
                              elseif env ==# 'table' || env ==# 'figure'
                                let option = ''
                                let label = self.parse_label()
                                let caption = self.parse_caption(a:line)
                              else
                                let option = matchstr(a:line, '\[.*\]')
                                let label = self.parse_label()
                                let caption = self.parse_caption(a:line)
                              endif
                            
                              " Always make room for the label
                              let width_rhs = 0
                              if !empty(label)
                                let label = '(' . label . ')'
                                let width_rhs += len(label)
                              endif
                            
                              " Use the remaining width for the left-hand side content
                              let width_lhs = vimtex#ui#get_winwidth() - width_rhs - 2
                            
                              " Add the possibly indented \begin{...} part
                              let width_ind = len(matchstr(a:line, '^\s*'))
                              if len(env) > width_lhs - width_ind - 8
                                let env = strpart(env, 0, width_lhs - width_ind - 8)
                              endif
                              let title = repeat(' ', width_ind) . '\begin{' . env . '}'
                            
                              " Add option group text
                              if !empty(option)
                                let width_available = width_lhs - len(title)
                                if width_available >= 3
                                  let title .= (len(option) > width_available - strchars(caption)
                                        \ ? '[…]'
                                        \ : option)
                                endif
                              endif
                            
                              " Add caption text
                              if !empty(caption)
                                let title = printf('%-*S ', 18, title)
                                let width_title = strchars(title)
                                let width_available = width_lhs - width_title
                            
                                if width_available >= 5
                                  if strchars(caption) > width_available
                                    let caption = strpart(caption, 0, width_available - 1) . '…'
                                  endif
                                  let title .= caption
                                endif
                              endif
                            
                              " Finalle combine the left-hand side and right-hand side and remove trailing
                              " spaces
                              let title = printf('%-*S %*S', width_lhs, title, width_rhs, label)
                            
                              return substitute(title, '\s\+$', '', '')
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:folder.parse_label() abort dict " {{{1
                              let depth = -1
                              let i = v:foldstart
                            
                              while i <= v:foldend
                                let line = getline(i)
                            
                                let depth += vimtex#util#count(line, '\\begin{\w\+}')
                                let depth -= vimtex#util#count(line, '\\end{\w\+}')
                            
                                if depth == 0 && line =~# '^\s*\\label'
                                  return matchstr(line, '^\s*\\label\%(\[.*\]\)\?{\zs.*\ze}')
                                end
                            
                                let i += 1
                              endwhile
                            
                              return ''
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.parse_caption(line) abort dict " {{{1
                              let depth = -1
                              let i = v:foldstart
                            
                              while i <= v:foldend
                                let line = getline(i)
                            
                                let depth += vimtex#util#count(line, '\\begin{\w\+}')
                                let depth -= vimtex#util#count(line, '\\end{\w\+}')
                            
                                if depth == 0 && line =~# '^\s*\\caption'
                                  return matchstr(line,
                                        \ '^\s*\\caption\(\[.*\]\)\?{\zs.\{-1,}\ze\(}\s*\)\?$')
                                end
                            
                                let i += 1
                              endwhile
                            
                              " If no caption found, check for a caption comment
                              return matchstr(a:line,'\\begin\*\?{.*}\s*%\s*\zs.*')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.parse_caption_frame(line) abort dict " {{{1
                              " Test simple variants first
                              let caption1 = matchstr(a:line,'\\begin\*\?{.*}\%(\[[^]]*\]\)\?{\zs.\+\ze}')
                              let caption2 = matchstr(a:line,'\\begin\*\?{.*}\%(\[[^]]*\]\)\?{\zs.\+')
                              if !empty(caption1)
                                return caption1
                              elseif !empty(caption2)
                                return caption2
                              endif
                            
                              " Search for \frametitle command
                              let i = v:foldstart
                              while i <= v:foldend
                                if getline(i) =~# '^\s*\\frametitle'
                                  let frametitle = matchstr(getline(i),
                                        \ '^\s*\\frametitle\%(\[.*\]\)\?{\zs.\{-1,}\ze\%(}\s*\)\?$')
                                  if i+1 <= v:foldend && getline(i+1) =~# '^\s*\\framesubtitle'
                                    let framesubtitle = matchstr(getline(i+1),
                                          \ '^\s*\\framesubtitle\%(\[.*\]\)\?{\zs.\{-1,}\ze\%(}\s*\)\?$')
                                    return printf('%S: %S', frametitle, framesubtitle)
                                  end
                                  return frametitle
                                end
                                let i += 1
                              endwhile
                            
                              " If no caption found, check for a caption comment
                              return matchstr(a:line,'\\begin\*\?{.*}\%(\[.*\]\)\?\s*%\s*\zs.*')
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_single_opt.vim
Sourced 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fold#cmd_single_opt#new(config) abort " {{{1
                              return extend(deepcopy(s:folder), a:config).init()
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000006 let s:folder = {
                                  \ 'name' : 'cmd_single_opt',
                                  \ 're' : {},
                                  \ 'opened' : 0,
                                  \ 'cmds' : [],
                                  \}
    1              0.000002 function! s:folder.init() abort dict " {{{1
                              let l:re = '\v^\s*\\%(' . join(self.cmds, '|') . ')\*?'
                            
                              let self.re.start = l:re . '\s*\[\s*%($|\%)'
                              let self.re.end = '^\s*\]{'
                              let self.re.text = l:re
                              let self.re.fold_re = '\\%(' . join(self.cmds, '|') . ')'
                            
                              return self
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.level(line, lnum) abort dict " {{{1
                              if a:line =~# self.re.start
                                let self.opened = 1
                                return 'a1'
                              elseif self.opened && a:line =~# self.re.end
                                let self.opened = 0
                                return 's1'
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.text(line, level) abort dict " {{{1
                              let l:col = strlen(matchstr(a:line, '^\s*')) + 1
                              return matchstr(a:line, self.re.text) . '[...]{'
                                    \ . vimtex#cmd#get_at(v:foldstart, l:col).args[0].text . '}'
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/markers.vim
Sourced 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fold#markers#new(config) abort " {{{1
                              return extend(deepcopy(s:folder), a:config).init()
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000007 let s:folder = {
                                  \ 'name' : 'markers',
                                  \ 'open' : '{{{',
                                  \ 'close' : '}}}',
                                  \ 're' : {},
                                  \ 'opened' : 0,
                                  \}
    1              0.000001 function! s:folder.init() abort dict " {{{1
                              let self.re.start = '%.*' . self.open
                              let self.re.end = '%.*' . self.close
                              let self.re.text = [
                                    \ [self.re.start . '\d\?\s*\zs.*', '% ' . self.open . ' '],
                                    \ ['%\s*\zs.*\ze' . self.open, '% ' . self.open . ' '],
                                    \ ['^.*\ze\s*%', ''],
                                    \]
                            
                              let self.re.fold_re = escape(self.open . '|' . self.close, '{}%+*.')
                            
                              return self
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.level(line, lnum) abort dict " {{{1
                              if a:line =~# self.re.start
                                let self.opened = 1
                                return 'a1'
                              elseif a:line =~# self.re.end
                                let self.opened = 0
                                return 's1'
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.text(line, level) abort dict " {{{1
                              for [l:re, l:pre] in self.re.text
                                let l:text = matchstr(a:line, l:re)
                                if !empty(l:text) | return l:pre . l:text | endif
                              endfor
                            
                              return '% ' . self.open . ' ' . getline(v:foldstart + 1)
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/preamble.vim
Sourced 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fold#preamble#new(config) abort " {{{1
                              return extend(deepcopy(s:folder), a:config)
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000008 let s:folder = {
                                  \ 'name' : 'preamble',
                                  \ 're' : {
                                  \   'start' : '^\s*\\documentclass',
                                  \   'fold_re' : '\\documentclass',
                                  \ },
                                  \}
    1              0.000002 function! s:folder.level(line, lnum) abort dict " {{{1
                              if a:line =~# self.re.start
                                return '>1'
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.text(line, level) abort dict " {{{1
                              return '      Preamble'
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/sections.vim
Sourced 1 time
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fold#sections#new(config) abort " {{{1
                              return extend(deepcopy(s:folder), a:config).init()
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000009 let s:folder = {
                                  \ 'name' : 'sections',
                                  \ 'parse_levels' : 0,
                                  \ 're' : {},
                                  \ 'folds' : [],
                                  \ 'sections' : [],
                                  \ 'parts' : [],
                                  \ 'time' : 0,
                                  \}
    1              0.000001 function! s:folder.init() abort dict " {{{1
                              let self.re.parts = '\v^\s*\\%(' . join(self.parts, '|') . ')'
                              let self.re.sections = '\v^\s*\\%(' . join(self.sections, '|') . ')'
                              let self.re.fake_sections = '\v^\s*\% Fake%('
                                    \ . join(self.sections, '|') . ').*'
                              let self.re.any_sections = '\v^\s*%(\\|\% Fake)%('
                                    \ . join(self.sections, '|') . ').*'
                            
                              let self.re.start = self.re.parts
                                    \ . '|' . self.re.sections
                                    \ . '|' . self.re.fake_sections
                            
                              let self.re.secpat1 = self.re.sections . '\*?\s*\{\zs.*'
                              let self.re.secpat2 = self.re.sections . '\*?\s*\[\zs.*'
                            
                              let self.re.fold_re = '\\%(' . join(self.parts + self.sections, '|') . ')'
                            
                              return self
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.level(line, lnum) abort dict " {{{1
                              call self.refresh()
                            
                              " Fold chapters and sections
                              for [l:part, l:level] in self.folds
                                if a:line =~# l:part
                                  return '>' . l:level
                                endif
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.text(line, level) abort dict " {{{1
                              if a:line =~# '\\frontmatter'
                                let l:title = 'Frontmatter'
                              elseif a:line =~# '\\mainmatter'
                                let l:title = 'Mainmatter'
                              elseif a:line =~# '\\backmatter'
                                let l:title = 'Backmatter'
                              elseif a:line =~# '\\appendix'
                                let l:title = 'Appendix'
                              elseif a:line =~# self.re.secpat1
                                let l:title = s:parse_title(a:line, self.re.secpat1, '{')
                              elseif a:line =~# self.re.secpat2
                                let l:title = s:parse_title(a:line, self.re.secpat2, '[')
                              elseif a:line =~# self.re.fake_sections
                                let l:title = matchstr(a:line, self.re.fake_sections)
                              endif
                            
                              let l:level = self.parse_level(v:foldstart, a:level)
                            
                              return printf('%-5s %-s', l:level,
                                    \ substitute(strpart(l:title, 0, winwidth(0) - 7), '\s\+$', '', ''))
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.parse_level(lnum, level) abort dict " {{{1
                              if !self.parse_levels | return a:level | endif
                            
                              if !has_key(self, 'toc')
                                let self.toc = vimtex#toc#new({
                                    \ 'name' : 'Fold text ToC',
                                    \ 'layers' : ['content'],
                                    \ 'refresh_always' : 0,
                                    \})
                                let self.toc_updated = 0
                                let self.file_updated = {}
                              endif
                            
                              let l:file = expand('%')
                              let l:ftime = getftime(l:file)
                            
                              if l:ftime > get(self.file_updated, l:file)
                                    \ || localtime() > self.toc_updated + 300
                                call self.toc.get_entries(1)
                                let self.toc_entries = filter(
                                      \ self.toc.get_visible_entries(),
                                      \ '!empty(v:val.number)')
                                let self.file_updated[l:file] = l:ftime
                                let self.toc_updated = localtime()
                              endif
                            
                              let l:entries = filter(deepcopy(self.toc_entries), 'v:val.line == a:lnum')
                              if len(l:entries) > 1
                                call filter(l:entries, "v:val.file ==# expand('%:p')")
                              endif
                            
                              return empty(l:entries) ? '' : self.toc.print_number(l:entries[0].number)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:folder.refresh() abort dict " {{{1
                              "
                              " Parse current buffer to find which sections to fold and their levels.  The
                              " patterns are predefined to optimize the folding.
                              "
                              " We ignore top level parts such as \frontmatter, \appendix, \part, and
                              " similar, unless there are at least two such commands in a document.
                              "
                            
                              " Only refresh if file has been changed
                              let l:time = getftime(expand('%'))
                              if l:time == self.time | return | endif
                              let self.time = l:time
                            
                              " Initialize
                              let self.folds = []
                              let level = 0
                              let buffer = getline(1,'$')
                            
                              " Parse part commands (frontmatter, appendix, etc)
                              " Note: We want a minimum of two top level parts
                              let lines = filter(copy(buffer), {_, x -> x =~# self.re.parts})
                              if len(lines) >= 2
                                let level += 1
                                call insert(self.folds, [self.re.parts, level])
                              endif
                            
                              " Parse section commands (part, chapter, [sub...]section)
                              let lines = filter(copy(buffer), {_, x -> x =~# self.re.any_sections})
                              for part in self.sections
                                let partpattern = '\v^\s*%(\\|\% Fake)' . part . ':?>'
                                for line in lines
                                  if line =~# partpattern
                                    let level += 1
                                    call insert(self.folds, [partpattern, level])
                                    break
                                  endif
                                endfor
                              endfor
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:parse_title(line, re, type) abort " {{{1
                              let l:title = matchstr(a:line, a:re)
                              let [l:end, l:depth] = vimtex#parser#tex#find_closing(
                                    \ 0, l:title, 1, a:type)
                            
                              let l:lnum = v:foldstart
                              while l:depth > 0 && l:lnum <= v:foldend
                                let l:lnum += 1
                                let l:start = strlen(l:title)
                                let l:title .= getline(l:lnum)
                                let [l:end, l:depth] = vimtex#parser#tex#find_closing(
                                      \ l:start, l:title, l:depth, a:type)
                              endwhile
                            
                              if l:depth == 0
                                let l:title = strpart(l:title, 0, l:end)
                              endif
                            
                              let l:title = substitute(l:title, '^\s*', '', '')
                              let l:title = substitute(l:title, '\s\{2,}', ' ', 'g')
                              return vimtex#parser#tex#texorpdfstring(l:title)
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_addplot.vim
Sourced 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fold#cmd_addplot#new(config) abort " {{{1
                              return extend(deepcopy(s:folder), a:config).init()
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000006 let s:folder = {
                                  \ 'name' : 'cmd_addplot',
                                  \ 're' : {},
                                  \ 'opened' : 0,
                                  \ 'cmds' : [],
                                  \}
    1              0.000002 function! s:folder.init() abort dict " {{{1
                              let l:re = '\v^\s*\\%(' . join(self.cmds, '|') . ')\s*%(\[[^\]]*\])?'
                            
                              let self.re.start = l:re . '\s*\w+\s*%(\[[^\]]*\])?\s*\ze\{\s*%($|\%)'
                              let self.re.end = '^\s*}'
                              let self.re.fold_re = '\\%(' . join(self.cmds, '|') . ')'
                            
                              return self
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.level(line, lnum) abort dict " {{{1
                              if a:line =~# self.re.start
                                let self.opened = 1
                                return 'a1'
                              elseif self.opened && a:line =~# self.re.end
                                let self.opened = 0
                                return 's1'
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.text(line, level) abort dict " {{{1
                              return matchstr(a:line, self.re.start) . '{...}'
                                    \ . substitute(getline(v:foldend), self.re.end, '', '')
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/env_options.vim
Sourced 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fold#env_options#new(config) abort " {{{1
                              return extend(deepcopy(s:folder), a:config)
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000010 let s:folder = {
                                  \ 'name' : 'envs with options',
                                  \ 're' : {
                                  \   'start' : g:vimtex#re#not_comment . '\\begin\s*\{.{-}\}\[\s*($|\%)',
                                  \   'end' : '\s*\]\s*$',
                                  \ },
                                  \ 'opened' : 0,
                                  \}
    1              0.000002 function! s:folder.level(line, lnum) abort dict " {{{1
                              return self.opened
                                    \ ? self.fold_closed(a:line, a:lnum)
                                    \ : self.fold_opened(a:line, a:lnum)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.fold_opened(line, lnum) abort dict " {{{1
                              if a:line =~# self.re.start
                                let self.opened = 1
                                return 'a1'
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.fold_closed(line, lnum) abort dict " {{{1
                              if a:line =~# self.re.end
                                let self.opened = 0
                                return 's1'
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.text(line, level) abort dict " {{{1
                              return a:line . '...] '
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_multi.vim
Sourced 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fold#cmd_multi#new(config) abort " {{{1
                              return extend(deepcopy(s:folder), a:config).init()
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000006 let s:folder = {
                                  \ 'name' : 'cmd_multi',
                                  \ 're' : {},
                                  \ 'opened' : 0,
                                  \ 'cmds' : [],
                                  \}
    1              0.000002 function! s:folder.init() abort dict " {{{1
                              let l:re = '\v^\s*\\%(' . join(self.cmds, '|') . ')\*?'
                            
                              let self.re.start = l:re . '.*(\{|\[)\s*(\%.*)?$'
                              let self.re.end = '\v^\s*%(\}\s*\{)*\}\s*%(\%|$)'
                              let self.re.text = l:re . '\{[^}]*\}'
                              let self.re.fold_re = '\\%(' . join(self.cmds, '|') . ')'
                            
                              return self
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.level(line, lnum) abort dict " {{{1
                              if a:line =~# self.re.start
                                let self.opened += 1
                                return 'a1'
                              elseif self.opened > 0 && a:line =~# self.re.end
                                let self.opened -= 1
                                return 's1'
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.text(line, level) abort dict " {{{1
                              return a:line
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/items.vim
Sourced 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fold#items#new(config) abort " {{{1
                              return extend(deepcopy(s:folder), a:config).init()
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000005 let s:folder = {
                                  \ 'name' : 'items',
                                  \ 're' : {},
                                  \ 'state' : [],
                                  \}
    1              0.000001 function! s:folder.init() dict abort " {{{1
                              let l:envs = '\{%(' . join(g:vimtex_indent_lists, '|') . ')\*?}'
                            
                              let self.re.env_start = '\v^\s*\\begin' . l:envs
                              let self.re.env_end = '\v^\s*\\end' . l:envs
                            
                              let self.re.fold_re = '^\s*\\item>'
                              let self.re.fold_re_next = '^\s*\\%(item>|end' . l:envs . ')'
                            
                              let self.re.start = '\v' . self.re.fold_re
                              let self.re.end = '\v' . self.re.fold_re_next
                            
                              return self
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.level(line, lnum) dict abort " {{{1
                              let l:env_val = has_key(b:vimtex.fold_types_dict, 'envs')
                                    \ ? b:vimtex.fold_types_dict['envs'].level(a:line, a:lnum)
                                    \ : 0
                            
                              let l:next = getline(a:lnum + 1)
                            
                              if a:line =~# self.re.env_start
                                call add(self.state, {'folded': v:false})
                              elseif a:line =~# self.re.env_end
                                call remove(self.state, -1)
                                if get(self.state, -1, {'folded': v:false}).folded
                                      \ && l:next =~# self.re.end
                                  return 's2'
                                endif
                              elseif a:line =~# '\v^\s*\\begin\{'
                                call add(self.state, {})
                              elseif len(self.state) > 0
                                let l:state = self.state[-1]
                                if a:line =~# '\v^\s*\\end\{' && empty(l:state)
                                  call remove(self.state, -1)
                                elseif !empty(l:state)
                                  if a:line =~# self.re.start
                                    if l:next !~# self.re.end
                                      let l:state.folded = v:true
                                      return l:env_val is# 'a1' ? 'a2' : 'a1'
                                    endif
                                  elseif l:state.folded && l:next =~# self.re.end
                                    let l:state.folded = v:false
                                    return l:env_val is# 's1' ? 's2' : 's1'
                                  endif
                                endif
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.text(line, level) abort dict " {{{1
                              return a:line
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_single.vim
Sourced 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fold#cmd_single#new(config) abort " {{{1
                              return extend(deepcopy(s:folder), a:config).init()
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000006 let s:folder = {
                                  \ 'name' : 'cmd_single',
                                  \ 're' : {},
                                  \ 'opened' : 0,
                                  \ 'cmds' : [],
                                  \}
    1              0.000001 function! s:folder.init() abort dict " {{{1
                              let l:re = '\v^\s*\\%(' . join(self.cmds, '|') . ')\*?\s*%(\[.*\])?'
                            
                              let self.re.start = l:re . '\s*\{\s*%($|\%)'
                              let self.re.end = '^\s*}'
                              let self.re.text = l:re
                              let self.re.fold_re = '\\%(' . join(self.cmds, '|') . ')'
                            
                              return self
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.level(line, lnum) abort dict " {{{1
                              if a:line =~# self.re.start
                                let self.opened = 1
                                return 'a1'
                              elseif self.opened && a:line =~# self.re.end
                                let self.opened = 0
                                return 's1'
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:folder.text(line, level) abort dict " {{{1
                              return matchstr(a:line, self.re.text) . '{...}'
                                    \ . substitute(getline(v:foldend), self.re.end, '', '')
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/context.vim
Sourced 1 time
Total time:   0.000079
 Self time:   0.000077

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#context#init_buffer() abort " {{{1
                              command! -buffer VimtexContextMenu call vimtex#context#menu()
                            
                              nnoremap <buffer> <plug>(vimtex-context-menu) :VimtexContextMenu<cr>
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#context#init_state(state) abort " {{{1
                              let a:state.context_menu = []
                            
                              for l:handler in copy(s:handlers)
                                call add(a:state.context_menu, vimtex#context#{l:handler}#new())
                              endfor
                            endfunction
                            
    1   0.000042   0.000039 let s:handlers = map(
                                  \ glob(expand('<sfile>:r') . '/*.vim', 0, 1),
                                  \ { _, x -> fnamemodify(x, ':t:r') })
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#context#menu() abort " {{{1
                              let l:cmd = vimtex#cmd#get_current()
                              if empty(l:cmd) | return | endif
                            
                              let l:word = expand('<cword>')
                            
                              for l:handler in b:vimtex.context_menu
                                if l:handler.match(l:cmd, l:word)
                                  return vimtex#ui#menu(l:handler.get_actions())
                                endif
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#context#get(...) abort " {{{1
                              if a:0 > 0
                                let l:pos_saved = vimtex#pos#get_cursor()
                                call vimtex#pos#set_cursor(a:000)
                              endif
                            
                              let l:cmd = vimtex#cmd#get_current()
                              let l:word = expand('<cword>')
                            
                              if a:0 > 0
                                call vimtex#pos#set_cursor(l:pos_saved)
                              endif
                            
                              if empty(l:cmd) | return | endif
                            
                              for l:handler in b:vimtex.context_menu
                                if l:handler.match(l:cmd, l:word)
                                  return {
                                        \ 'cmd': l:cmd,
                                        \ 'word': l:word,
                                        \ 'handler': l:handler,
                                        \}
                                endif
                              endfor
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/context/cite.vim
Sourced 1 time
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#context#cite#new() abort " {{{1
                              return deepcopy(s:handler)
                            endfunction
                            
                            " }}}1
                            
    1              0.000006 let s:handler = {
                                  \ 'name': 'citation handler',
                                  \ 're': '\v%(%(\a*cite|Cite)\a*|bibentry|%(text|block|%(for|hy)\w+)cquote)',
                                  \}
    1              0.000002 function! s:handler.match(cmd, word) abort dict " {{{1
                              if a:cmd.name[1:] !~# self.re
                                return v:false
                              endif
                            
                              if len(a:cmd.args) < 1 || len(a:cmd.args) > 2
                                return v:false
                              endif
                            
                              let l:text = a:cmd.args[0].text
                              if len(a:cmd.args) == 2
                                let l:text .= ',' . a:cmd.args[1].text
                              endif
                            
                              let self.cites = split(l:text, ',\s*')
                              if index(self.cites, a:word) >= 0
                                let self.selected = a:word
                              else
                                let self.selected = self.cites[0]
                              endif
                            
                              if empty(self.selected)
                                return v:false
                              endif
                            
                              return v:true
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:handler.get_actions() abort dict " {{{1
                              " Ensure we're at the root directory when locating bib files
                              call vimtex#paths#pushd(b:vimtex.root)
                              let l:entries = []
                              for l:file in vimtex#bib#files()
                                let l:entries += vimtex#parser#bib(l:file, {'backend': 'vim'})
                              endfor
                              call vimtex#paths#popd()
                            
                              let l:entry = get(
                                    \ filter(copy(l:entries), {_, x -> x.key ==# self.selected}), 0, {})
                            
                              if empty(l:entry)
                                call vimtex#log#warning('Cite key not found: ' . self.selected)
                                return {}
                              endif
                            
                              return s:actions.create(l:entry)
                            endfunction
                            
                            " }}}1
                            
    1              0.000009 let s:actions = {
                                  \ 'menu': [
                                  \   {'name': 'Edit entry',
                                  \    'func': 'edit'},
                                  \   {'name': 'Show entry',
                                  \    'func': 'show'},
                                  \ ],
                                  \}
    1              0.000002 function! s:actions.create(entry) abort dict " {{{1
                              let l:new = deepcopy(self)
                              unlet l:new.create
                            
                              let l:new.entry = deepcopy(a:entry)
                              let l:new.prompt = 'Context menu for citekey ' . a:entry.key
                            
                              if has_key(a:entry, 'file')
                                let l:pdfs = filter(split(a:entry.file, ';'),
                                      \ {_, x -> fnamemodify(x, ':e') ==? 'pdf'})
                                if !empty(l:pdfs)
                                  let l:new.pdfs = map(l:pdfs, {_, x -> expand(x)})
                                  call add(l:new.menu, {'name': 'Open PDF', 'func': 'open_pdf'})
                                endif
                              endif
                            
                              if has_key(a:entry, 'doi')
                                call add(l:new.menu, {'name': 'Open doi', 'func': 'open_doi'})
                              endif
                            
                              if has_key(a:entry, 'eprint')
                                    \ && (a:entry.eprint[0:4] ==# 'arXiv'
                                    \     || (has_key(a:entry, 'archiveprefix')
                                    \         && a:entry.archiveprefix ==# 'arXiv'))
                                call add(l:new.menu, {'name': 'Open arXiv', 'func': 'open_arxiv'})
                              endif
                            
                              if has_key(a:entry, 'url')
                                call add(l:new.menu, {'name': 'Open url', 'func': 'open_url'})
                              endif
                            
                              return l:new
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:actions.show() abort dict " {{{1
                              let l:entry = deepcopy(self.entry)
                            
                              call vimtex#ui#echo([
                                    \ ['Normal', '@'],
                                    \ ['VimtexMsg', l:entry.type],
                                    \ ['Normal', '{'],
                                    \ ['Special', l:entry.key],
                                    \ ['Normal', ','],
                                    \])
                            
                              for l:x in ['key', 'type', 'vimtex_lnum', 'vimtex_file']
                                if has_key(l:entry, l:x)
                                  call remove(l:entry, l:x)
                                endif
                              endfor
                            
                              for l:x in ['title', 'author', 'year']
                                if has_key(l:entry, l:x)
                                  call vimtex#ui#echo([
                                        \ ['VimtexInfoValue', '  ' . l:x . ': '],
                                        \ ['Normal', remove(l:entry, l:x)]
                                        \])
                                endif
                              endfor
                            
                              for [l:key, l:val] in items(l:entry)
                                  call vimtex#ui#echo([
                                        \ ['VimtexInfoValue', '  ' . l:key . ': '],
                                        \ ['Normal', l:val]
                                        \])
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:actions.edit() abort dict " {{{1
                              execute 'edit' self.entry.vimtex_file
                              filetype detect
                            
                              call vimtex#pos#set_cursor(self.entry.vimtex_lnum, 0)
                              normal! zv
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:actions.open_pdf() abort dict " {{{1
                              let l:readable = filter(self.pdfs, {_, x -> filereadable(x)})
                              if empty(l:readable)
                                call vimtex#log#warning('Could not open PDF file!')
                                for l:file in self.pdfs
                                  call vimtex#log#info('Filename: ' . l:file)
                                endfor
                                return
                              endif
                            
                              let l:file = vimtex#ui#select(l:readable, {
                                    \ 'prompt': 'Open file:',
                                    \})
                              if empty(l:file) | return | endif
                            
                              call vimtex#jobs#start(
                                    \ g:vimtex_context_pdf_viewer
                                    \ . ' ' . vimtex#util#shellescape(l:file),
                                    \ {'detached': v:true})
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:actions.open_arxiv() abort dict " {{{1
                              let l:id = matchstr(self.entry.eprint, '\v^(arXiv:)?\zs.*')
                              call vimtex#util#www('https://arxiv.org/abs/' . l:id)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:actions.open_doi() abort dict " {{{1
                              call vimtex#util#www('http://dx.doi.org/' . self.entry.doi)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:actions.open_url() abort dict " {{{1
                              call vimtex#util#www(self.entry.url)
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/parser/fls.vim
Sourced 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#parser#fls#parse(file) abort " {{{1
                              if !filereadable(a:file)
                                return []
                              endif
                            
                              return readfile(a:file)
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/bib.vim
Sourced 1 time
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#bib#files() abort " {{{1
                              if has_key(b:vimtex.packages, 'biblatex')
                                let l:file = b:vimtex.compiler.get_file('bcf')
                                if filereadable(l:file)
                                  let l:bibs = map(
                                        \ filter(readfile(l:file), "v:val =~# 'bcf:datasource'"),
                                        \ {_, x -> matchstr(x, '<[^>]*>\zs[^<]*')})
                                  for l:f in filter(copy(l:bibs), {_, x -> x =~# '[*?{[]' })
                                    let l:bibs += glob(l:f, 0, 1)
                                  endfor
                                  if !empty(l:bibs) | return s:validate(l:bibs) | endif
                                endif
                              endif
                            
                              let l:file = b:vimtex.compiler.get_file('blg')
                              if filereadable(l:file)
                                let l:bibs = map(
                                      \ filter(readfile(l:file), 'v:val =~# ''^Database file #\d'''),
                                      \ {_, x -> matchstr(x, '#\d\+: \zs.*\ze\.bib$')})
                            
                                " Ignore '{name}-blx.bib' file (created by biblatex)
                                if has_key(b:vimtex.packages, 'biblatex')
                                  call filter(l:bibs, 'v:val !~# ''-blx$''')
                                endif
                            
                                " Ignore '{name}Notes.bib' file (created by revtex4)
                                if b:vimtex.documentclass =~# '^revtex4'
                                  call filter(l:bibs, 'v:val !~# ''.Notes$''')
                                endif
                            
                                if !empty(l:bibs) | return s:validate(l:bibs) | endif
                              endif
                            
                              return s:validate(s:files_manual())
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:validate(files) abort " {{{1
                              call filter(a:files, {_, x -> !empty(x)})
                              call map(a:files, {_, x -> substitute(x, '\%(\.bib\)\?$', '.bib', '')})
                              call map(a:files, {_, x -> filereadable(x) ? x : vimtex#kpsewhich#find(x)})
                              call filter(a:files, {_, x -> filereadable(x)})
                            
                              return a:files
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:files_manual() abort " {{{1
                              "
                              " Search for bibliography files by parsing the source code
                              " * Parse commands such as \bibliography{file1,file2.bib,...}
                              "
                            
                              let l:cache = vimtex#cache#open('bibfiles', {
                                    \ 'local': 1,
                                    \ 'default': {'files': [], 'ftime': -1}
                                    \})
                            
                              " Handle local file editing (e.g. subfiles package)
                              let l:id = get(get(b:, 'vimtex_local', {'main_id' : b:vimtex_id}), 'main_id')
                              let l:vimtex = vimtex#state#get(l:id)
                            
                              let l:bibfiles = []
                              for l:file in map(l:vimtex.get_sources(), 'l:vimtex.root . ''/'' . v:val')
                                let l:current = l:cache.get(l:file)
                            
                                let l:ftime = getftime(l:file)
                                if l:ftime > l:current.ftime
                                  let l:cache.modified = 1
                                  let l:current.ftime = l:ftime
                                  let l:current.files = []
                            
                                  for l:entry in map(
                                        \ filter(readfile(l:file), {_, x -> x =~# s:bib_re}),
                                        \ {_, x -> matchstr(x, s:bib_re)})
                                    " Interpolate the \jobname command
                                    let l:entry = substitute(l:entry, '\\jobname', b:vimtex.name, 'g')
                            
                                    " Assume comma separated list of files
                                    let l:files = split(l:entry, ',')
                            
                                    " But also add the unmodified entry for consideration, as the comma may
                                    " be part of the filename or part of a globbing expression.
                                    if len(l:files) > 1
                                      let l:files += [l:entry]
                                    endif
                            
                                    " Now attempt to apply globbing where applicable
                                    for l:exp in filter(copy(l:files), {_, x -> x =~# '[*?{[]'})
                                      try
                                        let l:globbed = glob(l:exp, 0, 1)
                                        let l:files += l:globbed
                                      catch /E220/
                                      endtry
                                    endfor
                            
                                    let l:current.files += l:files
                                  endfor
                                endif
                            
                                let l:bibfiles += l:current.files
                              endfor
                            
                              " Write cache to file
                              call l:cache.write()
                            
                              return uniq(l:bibfiles)
                            endfunction
                            
                            " }}}1
                            
    1              0.000008 let s:bib_re = g:vimtex#re#not_comment . '\\('
                                  \ . join(g:vimtex_bibliography_commands, '|')
                                  \ . ')\s*\{\zs.+\ze}'

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/cmd.vim
Sourced 1 time
Total time:   0.000418
 Self time:   0.000418

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#cmd#init_buffer() abort " {{{1
                              nnoremap <silent><buffer> <plug>(vimtex-cmd-delete)
                                    \ :<c-u>call <sid>operator_setup('delete')<bar>normal! g@l<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-cmd-change)
                                    \ :<c-u>call <sid>operator_setup('change')<bar>normal! g@l<cr>
                            
                              inoremap <silent><buffer> <plug>(vimtex-cmd-create)
                                    \ <c-r>=vimtex#cmd#create_insert()<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-cmd-create)
                                    \ :<c-u>call <sid>operator_setup('create')<bar>normal! g@l<cr>
                            
                              xnoremap <silent><buffer> <plug>(vimtex-cmd-create)
                                    \ :<c-u>call vimtex#cmd#create_visual()<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-cmd-toggle-star)
                                    \ :<c-u>call <sid>operator_setup('toggle_star')<bar>normal! g@l<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-cmd-toggle-frac)
                                    \ :<c-u>call <sid>operator_setup('toggle_frac')<bar>normal! g@l<cr>
                            
                              xnoremap <silent><buffer> <plug>(vimtex-cmd-toggle-frac)
                                    \ :<c-u>call vimtex#cmd#toggle_frac_visual()<cr>
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#cmd#change(new_name) abort " {{{1
                              let l:cmd = vimtex#cmd#get_current()
                              if empty(l:cmd) | return | endif
                            
                              let l:old_name = l:cmd.name
                              let l:lnum = l:cmd.pos_start.lnum
                              let l:cnum = l:cmd.pos_start.cnum
                            
                              " Get new command name
                              let l:new_name = substitute(a:new_name, '^\\', '', '')
                              if empty(l:new_name) | return | endif
                            
                              " Update current position
                              let l:save_pos = vimtex#pos#get_cursor()
                              if strlen(l:new_name) < strlen(l:old_name)
                                let l:col = searchpos('\\\k', 'bcnW')[1] + strlen(l:new_name)
                                if l:col < l:save_pos[2]
                                  let l:save_pos[2] = l:col
                                endif
                              endif
                            
                              " Perform the change
                              let l:line = getline(l:lnum)
                              call setline(l:lnum,
                                    \   strpart(l:line, 0, l:cnum)
                                    \ . l:new_name
                                    \ . strpart(l:line, l:cnum + strlen(l:old_name) - 1))
                            
                              " Restore cursor position
                              cal vimtex#pos#set_cursor(l:save_pos)
                            endfunction
                            
    1              0.000001 function! vimtex#cmd#delete(...) abort " {{{1
                              if a:0 > 0
                                let l:cmd = call('vimtex#cmd#get_at', a:000)
                              else
                                let l:cmd = vimtex#cmd#get_current()
                              endif
                              if empty(l:cmd) | return | endif
                            
                              " Save current position
                              let l:save_pos = vimtex#pos#get_cursor()
                              let l:lnum_cur = l:save_pos[1]
                              let l:cnum_cur = l:save_pos[2]
                            
                              " Remove closing bracket (if exactly one argument)
                              if len(l:cmd.args) == 1
                                let l:lnum = l:cmd.args[0].close.lnum
                                let l:cnum = l:cmd.args[0].close.cnum
                                let l:line = getline(l:lnum)
                                call setline(l:lnum,
                                      \   strpart(l:line, 0, l:cnum - 1)
                                      \ . strpart(l:line, l:cnum))
                            
                                let l:cnum2 = l:cmd.args[0].open.cnum
                              endif
                            
                              " Remove command (and possibly the opening bracket)
                              let l:lnum = l:cmd.pos_start.lnum
                              let l:cnum = l:cmd.pos_start.cnum
                              let l:cnum2 = get(l:, 'cnum2', l:cnum + strlen(l:cmd.name) - 1)
                              let l:line = getline(l:lnum)
                              call setline(l:lnum,
                                    \   strpart(l:line, 0, l:cnum - 1)
                                    \ . strpart(l:line, l:cnum2))
                            
                              " Restore appropriate cursor position
                              if l:lnum_cur == l:lnum
                                if l:cnum_cur > l:cnum2
                                  let l:save_pos[2] -= l:cnum2 - l:cnum + 1
                                else
                                  let l:save_pos[2] -= l:cnum_cur - l:cnum
                                endif
                              endif
                              cal vimtex#pos#set_cursor(l:save_pos)
                            endfunction
                            
    1              0.000001 function! vimtex#cmd#delete_all(...) abort " {{{1
                              if a:0 > 0
                                let l:cmd = call('vimtex#cmd#get_at', a:000)
                              else
                                let l:cmd = vimtex#cmd#get_current()
                              endif
                              if empty(l:cmd) | return | endif
                            
                              call vimtex#pos#set_cursor(l:cmd.pos_start)
                              normal! v
                              call vimtex#pos#set_cursor(l:cmd.pos_end)
                              normal! d
                            endfunction
                            
    1              0.000002 function! vimtex#cmd#create_insert() abort " {{{1
                              if mode() !=# 'i' | return | endif
                            
                              let l:re = '\v%(^|\A)\zs\a+(\*=)@>\a*\ze%(\A|$)'
                              let l:c0 = col('.') - 1
                            
                              let [l:l1, l:c1] = searchpos(l:re, 'bcn', line('.'))
                              let l:c1 -= 1
                              let l:line = getline(l:l1)
                              let l:match = matchstr(l:line, l:re, l:c1)
                              let l:c2 = l:c1 + strlen(l:match)
                            
                              if l:c0 > l:c2
                                call vimtex#log#warning('Could not create command')
                                return ''
                              endif
                            
                              let l:strpart1 = strpart(l:line, 0, l:c1)
                              let l:strpart2 = '\' . strpart(l:match, 0, l:c0 - l:c1) . '{'
                              let l:strpart3 = strpart(l:line, l:c0)
                              call setline(l:l1, l:strpart1 . l:strpart2 . l:strpart3)
                            
                              call vimtex#pos#set_cursor(l:l1, l:c2+3)
                              return ''
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#cmd#create(cmd, visualmode) abort " {{{1
                              if empty(a:cmd) | return | endif
                            
                              " Avoid autoindent (disable indentkeys)
                              let l:save_indentkeys = &l:indentkeys
                              setlocal indentkeys=
                            
                              if a:visualmode
                                let l:pos_start = getpos("'<")
                                let l:pos_end = getpos("'>")
                            
                                if visualmode() ==# ''
                                  normal! gvA}
                                  execute 'normal! gvI\' . a:cmd . '{'
                            
                                  let l:pos_end[2] += strlen(a:cmd) + 3
                                else
                                  normal! `>a}
                                  normal! `<
                                  execute 'normal! i\' . a:cmd . '{'
                            
                                  let l:pos_end[2] +=
                                        \ l:pos_end[1] == l:pos_start[1] ? strlen(a:cmd) + 3 : 1
                                endif
                            
                                call vimtex#pos#set_cursor(l:pos_end)
                              else
                                let l:pos = vimtex#pos#get_cursor()
                                let l:save_reg = getreg('"')
                                let l:pos[2] += strlen(a:cmd) + 2
                                execute 'normal! ciw\' . a:cmd . '{"}'
                                call setreg('"', l:save_reg)
                                call vimtex#pos#set_cursor(l:pos)
                              endif
                            
                              " Restore indentkeys setting
                              let &l:indentkeys = l:save_indentkeys
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#cmd#create_visual() abort " {{{1
                              let l:cmd = vimtex#ui#input({
                                    \ 'info': ['Create command: ', ['VimtexWarning', '(empty to cancel)']],
                                    \})
                              let l:cmd = substitute(l:cmd, '^\\', '', '')
                              call vimtex#cmd#create(l:cmd, 1)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#cmd#toggle_star() abort " {{{1
                              let l:cmd = vimtex#cmd#get_current()
                              if empty(l:cmd) | return | endif
                            
                              let l:old_name = l:cmd.name
                              let l:lnum = l:cmd.pos_start.lnum
                              let l:cnum = l:cmd.pos_start.cnum
                            
                              " Set new command name
                              if match(l:old_name, '\*$') == -1
                                let l:new_name = l:old_name.'*'
                              else
                                let l:new_name = strpart(l:old_name, 0, strlen(l:old_name)-1)
                              endif
                              let l:new_name = substitute(l:new_name, '^\\', '', '')
                              if empty(l:new_name) | return | endif
                            
                              " Update current position
                              let l:save_pos = vimtex#pos#get_cursor()
                              let l:save_pos[2] += strlen(l:new_name) - strlen(l:old_name) + 1
                            
                              " Perform the change
                              let l:line = getline(l:lnum)
                              call setline(l:lnum,
                                    \   strpart(l:line, 0, l:cnum)
                                    \ . l:new_name
                                    \ . strpart(l:line, l:cnum + strlen(l:old_name) - 1))
                            
                              " Restore cursor position
                              cal vimtex#pos#set_cursor(l:save_pos)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#cmd#toggle_frac() abort " {{{1
                              let l:frac = s:get_frac_cmd()
                              if empty(l:frac)
                                let l:frac = s:get_frac_inline()
                              endif
                              if empty(l:frac) | return | endif
                            
                              let l:lnum = line('.')
                              let l:line = getline(l:lnum)
                              call setline(l:lnum,
                                    \ strpart(l:line, 0, l:frac.col_start)
                                    \ . l:frac.text_toggled
                                    \ . strpart(l:line, l:frac.col_end+1))
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#cmd#toggle_frac_visual() abort " {{{1
                              let l:save_reg = getreg('a')
                              normal! gv"ay
                              let l:selected = substitute(getreg('a'), '\n\s*', ' ', '')
                              call setreg('a', l:save_reg)
                            
                              let l:frac = s:get_frac_inline_visual(l:selected)
                              if empty(l:frac)
                                let l:frac = s:get_frac_cmd_visual(l:selected)
                              endif
                            
                              if empty(l:frac) | return | endif
                            
                              let l:save_reg = getreg('a')
                              call setreg('a', l:frac.text_toggled)
                              normal! gv"ap
                              call setreg('a', l:save_reg)
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#cmd#parser_separator_check(separator_string) abort " {{{1
                              return a:separator_string =~# '\v^%(\n\s*)?$'
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 function! s:get_frac_toggled(origin, numerator, denominator) abort " {{{1
                              let l:target = get(g:vimtex_toggle_fractions, a:origin, 'INLINE')
                            
                              if l:target ==# 'INLINE'
                                let l:numerator = (a:numerator =~# '^\\\?\w*$')
                                      \ ? a:numerator
                                      \ : '(' . a:numerator . ')'
                            
                                let l:denominator = (a:denominator =~# '^\\\?\w*$')
                                      \ ? a:denominator
                                      \ : '(' . a:denominator . ')'
                            
                                return l:numerator . '/' . l:denominator
                              endif
                            
                              return printf('\%s{%s}{%s}', l:target, a:numerator, a:denominator)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_frac_cmd() abort " {{{1
                              let l:frac_cmds = map(filter(
                                    \ keys(g:vimtex_toggle_fractions), { _, x -> x !~# 'INLINE' }),
                                    \ { _, x -> '\' .. x })
                            
                              let l:save_pos = vimtex#pos#get_cursor()
                              while 1
                                let l:cmd = s:get_cmd('prev')
                                if empty(l:cmd) || l:cmd.pos_start.lnum < line('.')
                                  call vimtex#pos#set_cursor(l:save_pos)
                                  return {}
                                endif
                            
                                " Note: \dfrac and \cfrac are defined by amsmath and are common variants
                                if index(l:frac_cmds, l:cmd.name) >= 0
                                  break
                                endif
                            
                                call vimtex#pos#set_cursor(vimtex#pos#prev(l:cmd.pos_start))
                              endwhile
                              call vimtex#pos#set_cursor(l:save_pos)
                            
                              let l:frac = {
                                    \ 'type': 'cmd',
                                    \ 'origin': l:cmd.name[1:],
                                    \ 'col_start': l:cmd.pos_start.cnum - 1,
                                    \ 'col_end': l:cmd.pos_end.cnum - 1,
                                    \}
                            
                              if len(l:cmd.args) >= 2
                                let l:consume = []
                                let l:frac.numerator = l:cmd.args[0].text
                                let l:frac.denominator = l:cmd.args[1].text
                              elseif len(l:cmd.args) == 1
                                let l:consume = ['denominator']
                                let l:frac.numerator = l:cmd.args[0].text
                                let l:frac.denominator = ''
                              else
                                let l:consume = ['numerator', 'denominator']
                                let l:frac.numerator = ''
                                let l:frac.denominator = ''
                              endif
                            
                              " Handle unfinished cases
                              let l:line = getline('.')
                              let l:pos = l:frac.col_end + 1
                              for l:key in l:consume
                                let l:part = strpart(l:line, l:frac.col_end + 1)
                            
                                let l:blurp = matchstr(l:part, '^\s*{[^}]*}')
                                if !empty(l:blurp)
                                  let l:frac[l:key] = vimtex#util#trim(l:blurp)[1:-2]
                                  let l:frac.col_end += len(l:blurp)
                                  continue
                                endif
                            
                                let l:blurp = matchstr(l:part, '^\s*\w')
                                if !empty(l:blurp)
                                  let l:frac[l:key] = vimtex#util#trim(l:blurp)
                                  let l:frac.col_end += len(l:blurp)
                                endif
                              endfor
                            
                              " Abort if \frac region does not cover cursor
                              if l:frac.col_end < col('.') | return {} | endif
                            
                              let l:frac.text = strpart(getline('.'),
                                    \ l:frac.col_start, l:frac.col_end - l:frac.col_start + 1)
                              let l:frac.text_toggled = s:get_frac_toggled(
                                    \ l:frac.origin, l:frac.numerator, l:frac.denominator)
                            
                              return l:frac
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_frac_cmd_visual(selected) abort " {{{1
                              let l:frac_re = '\\\(' . join(filter(
                                    \ keys(g:vimtex_toggle_fractions),
                                    \ { _, x -> x !~# 'INLINE' }), '\|') . '\)'
                              let l:matches = matchlist(
                                    \ a:selected, '^\s*' . l:frac_re . '\s*{\(.*\)}\s*{\(.*\)}\s*$')
                              if empty(l:matches) | return {} | endif
                            
                              let l:frac = {
                                    \ 'type': 'cmd',
                                    \ 'origin': l:matches[1],
                                    \ 'text': a:selected,
                                    \ 'numerator': l:matches[2],
                                    \ 'denominator': l:matches[3],
                                    \}
                            
                              let l:frac.text_toggled = s:get_frac_toggled(
                                    \ l:frac.origin, l:frac.numerator, l:frac.denominator)
                            
                              return l:frac
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:get_frac_inline() abort " {{{1
                              let l:line = getline('.')
                              let l:col = col('.') - 1
                            
                              let l:pos_after = -1
                              let l:pos_before = -1
                              while 1
                                let l:pos_before = l:pos_after
                                let l:pos_after = match(l:line, '\/', l:pos_after+1)
                                if l:pos_after < 0 || l:pos_after >= l:col | break | endif
                              endwhile
                            
                              if l:pos_after == -1 && l:pos_before == -1
                                return {}
                              endif
                            
                              let l:positions = []
                              if l:pos_before > 0
                                let l:positions += [l:pos_before]
                              endif
                              if l:pos_after > 0
                                let l:positions += [l:pos_after]
                              endif
                            
                              for l:pos in l:positions
                                let l:frac = {'type': 'inline'}
                            
                                "
                                " Parse numerator
                                "
                                let l:before = strpart(l:line, 0, l:pos)
                                if l:before =~# ')\s*$'
                                  let l:pos_before = s:get_inline_limit(l:before, -1) - 1
                                  let l:parens = strpart(l:before, l:pos_before)
                                else
                                  let l:pos_before = match(l:before, '\s*$')
                                  let l:parens = ''
                                endif
                            
                                let l:before = strpart(l:line, 0, l:pos_before)
                                let l:atoms = matchstr(l:before, '\(\\(\)\?\zs[^-$(){} ]*$')
                                let l:pos_before = l:pos_before - strlen(l:atoms)
                                let l:frac.numerator = s:get_inline_trim(l:atoms . l:parens)
                                let l:frac.col_start = l:pos_before
                            
                                "
                                " Parse denominator
                                "
                                let l:after = strpart(l:line, l:pos+1)
                                let l:atoms = l:after =~# '^\s*[^$()} ]*\\)'
                                      \ ? matchstr(l:after, '^\s*[^$()} ]*\ze\\)')
                                      \ : matchstr(l:after, '^\s*[^$()} ]*')
                                let l:pos_after = l:pos + strlen(l:atoms)
                                let l:after = strpart(l:line, l:pos_after+1)
                                if l:after =~# '^('
                                  let l:index = s:get_inline_limit(l:after, 1)
                                  let l:pos_after = l:pos_after + l:index + 1
                                  let l:parens = strpart(l:after, 0, l:index+1)
                                else
                                  let l:parens = ''
                                endif
                                let l:frac.denominator = s:get_inline_trim(l:atoms . l:parens)
                                let l:frac.col_end = l:pos_after
                            
                                "
                                " Combine/Parse inline and frac expressions
                                "
                                let l:frac.origin = 'INLINE'
                                let l:frac.text = strpart(l:line,
                                      \ l:frac.col_start,
                                      \ l:frac.col_end - l:frac.col_start + 1)
                                let l:frac.text_toggled  = s:get_frac_toggled(
                                      \ l:frac.origin, l:frac.numerator, l:frac.denominator)
                            
                                "
                                " Accept result if the range contains the cursor column
                                "
                                if l:col >= l:frac.col_start && l:col <= l:frac.col_end
                                  return l:frac
                                endif
                              endfor
                            
                              return {}
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_frac_inline_visual(selected) abort " {{{1
                              let l:parts = split(a:selected, '/')
                              if len(l:parts) != 2 | return {} | endif
                            
                              let l:frac = {
                                    \ 'type': 'inline',
                                    \ 'origin': 'INLINE',
                                    \ 'text': a:selected,
                                    \ 'numerator': s:get_inline_trim(l:parts[0]),
                                    \ 'denominator': s:get_inline_trim(l:parts[1]),
                                    \}
                            
                              let l:frac.text_toggled = s:get_frac_toggled(
                                    \ l:frac.origin, l:frac.numerator, l:frac.denominator)
                            
                              return l:frac
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_inline_limit(str, dir) abort " {{{1
                              if a:dir > 0
                                let l:open = '('
                                let l:string = a:str
                              else
                                let l:open = ')'
                                let l:string = join(reverse(split(a:str, '\zs')), '')
                              endif
                            
                              let idx = -1
                              let depth = 0
                            
                              while idx < len(l:string)
                                let idx = match(l:string, '[()]', idx + 1)
                                if idx < 0
                                  let idx = len(l:string)
                                endif
                                if idx >= len(l:string) || l:string[idx] ==# l:open
                                  let depth += 1
                                else
                                  let depth -= 1
                                  if depth == 0
                                    return a:dir < 0 ? len(a:str) - idx : idx
                                  endif
                                endif
                              endwhile
                            
                              return -1
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_inline_trim(str) abort " {{{1
                              let l:str = vimtex#util#trim(a:str)
                              return substitute(l:str, '^(\(.*\))$', '\1', '')
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#cmd#get_next() abort " {{{1
                              return s:get_cmd('next')
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#cmd#get_prev() abort " {{{1
                              return s:get_cmd('prev')
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#cmd#get_current() abort " {{{1
                              let l:save_pos = vimtex#pos#get_cursor()
                              let l:pos_val_cursor = vimtex#pos#val(l:save_pos)
                            
                              let l:depth = 3
                              while l:depth > 0
                                let l:depth -= 1
                                let l:cmd = s:get_cmd('prev')
                                if empty(l:cmd) | break | endif
                            
                                let l:pos_val = vimtex#pos#val(l:cmd.pos_end)
                                if l:pos_val >= l:pos_val_cursor
                                  call vimtex#pos#set_cursor(l:save_pos)
                                  return l:cmd
                                else
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:cmd.pos_start))
                                endif
                              endwhile
                            
                              call vimtex#pos#set_cursor(l:save_pos)
                            
                              return {}
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#cmd#get_at(...) abort " {{{1
                              let l:pos_saved = vimtex#pos#get_cursor()
                              call call('vimtex#pos#set_cursor', a:000)
                              let l:cmd = vimtex#cmd#get_current()
                              call vimtex#pos#set_cursor(l:pos_saved)
                              return l:cmd
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:operator_setup(operator) abort " {{{1
                              let s:operator = a:operator
                              let &opfunc = s:snr() . 'operator_function'
                            
                              " Ask for user input if necessary/relevant
                              if s:operator ==# 'change'
                                let l:current = vimtex#cmd#get_current()
                                if empty(l:current) | return | endif
                            
                                let s:operator_cmd_name = substitute(vimtex#ui#input({
                                      \ 'info': ['Change command: ', ['VimtexWarning', l:current.name]],
                                      \}), '^\\', '', '')
                              elseif s:operator ==# 'create'
                                let s:operator_cmd_name = substitute(vimtex#ui#input({
                                      \ 'info': ['Create command: ', ['VimtexWarning', '(empty to cancel)']],
                                      \}), '^\\', '', '')
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:operator_function(_) abort " {{{1
                              let l:name = get(s:, 'operator_cmd_name', '')
                            
                              execute 'call vimtex#cmd#' . {
                                    \   'change': 'change(l:name)',
                                    \   'create': 'create(l:name, 0)',
                                    \   'delete': 'delete()',
                                    \   'toggle_star': 'toggle_star()',
                                    \   'toggle_frac': 'toggle_frac()',
                                    \ }[s:operator]
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:snr() abort " {{{1
                              return matchstr(expand('<sfile>'), '<SNR>\d\+_')
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:get_cmd(direction) abort " {{{1
                              let [lnum, cnum, match] = s:get_cmd_name(a:direction ==# 'next')
                              if lnum == 0 | return {} | endif
                            
                              let res = {
                                    \ 'name' : match,
                                    \ 'text' : '',
                                    \ 'pos_start' : { 'lnum' : lnum, 'cnum' : cnum },
                                    \ 'pos_end' : { 'lnum' : lnum, 'cnum' : cnum + strlen(match) - 1 },
                                    \ 'args' : [],
                                    \ 'opts' : [],
                                    \}
                            
                              " Environments always start with environment name and allows option
                              " afterwords
                              if res.name ==# '\begin'
                                let arg = s:get_cmd_part('{', res.pos_end)
                                if empty(arg) | return res | endif
                            
                                call add(res.args, arg)
                                let res.pos_end.lnum = arg.close.lnum
                                let res.pos_end.cnum = arg.close.cnum
                              endif
                            
                              " Get overlay specification
                              let res.overlay = s:get_cmd_overlay(res.pos_end.lnum, res.pos_end.cnum)
                              if !empty(res.overlay)
                                let res.pos_end.lnum = res.overlay.close.lnum
                                let res.pos_end.cnum = res.overlay.close.cnum
                              endif
                            
                              " Get options and arguments
                              while v:true
                                let opt = s:get_cmd_part('[', res.pos_end)
                                if !empty(opt)
                                  call add(res.opts, opt)
                                  let res.pos_end.lnum = opt.close.lnum
                                  let res.pos_end.cnum = opt.close.cnum
                                  continue
                                endif
                            
                                let arg = s:get_cmd_part('{', res.pos_end)
                                if !empty(arg)
                                  call add(res.args, arg)
                                  let res.pos_end.lnum = arg.close.lnum
                                  let res.pos_end.cnum = arg.close.cnum
                                  continue
                                endif
                            
                                break
                              endwhile
                            
                              " Include entire cmd text
                              let res.text = s:text_between(res.pos_start, res.pos_end, 1)
                            
                              return res
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_cmd_name(next) abort " {{{1
                              let [l:lnum, l:cnum] = searchpos(
                                    \ '\v\\%(\a+\*?|[,:;!])',
                                    \ a:next ? 'nW' : 'cbnW')
                              let l:match = matchstr(getline(l:lnum), '^\v\\%([,:;!]|\a*\*?)', l:cnum-1)
                              return [l:lnum, l:cnum, l:match]
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_cmd_part(part, start_pos) abort " {{{1
                              let l:save_pos = vimtex#pos#get_cursor()
                              call vimtex#pos#set_cursor(a:start_pos)
                              let l:open = vimtex#delim#get_next('delim_tex', 'open')
                              call vimtex#pos#set_cursor(l:save_pos)
                            
                              " Ensure that the next delimiter is found and is of the right type
                              if empty(l:open) || l:open.match !=# a:part | return {} | endif
                            
                              " Ensure that the delimiter is the next non-whitespace character according to
                              " a configurable rule
                              if ! call(g:vimtex_parser_cmd_separator_check, [
                                    \ s:text_between(a:start_pos, l:open)
                                    \])
                                return {}
                              endif
                            
                              let l:close = vimtex#delim#get_matching(l:open)
                              if empty(l:close)
                                return {}
                              endif
                            
                              return {
                                    \ 'open' : l:open,
                                    \ 'close' : l:close,
                                    \ 'text' : s:text_between(l:open, l:close),
                                    \}
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_cmd_overlay(lnum, cnum) abort " {{{1
                              let l:match = matchstr(getline(a:lnum), '^\s*<[^>]*>', a:cnum)
                            
                              return empty(l:match)
                                    \ ? {}
                                    \ : {
                                    \    'open' : {'lnum' : a:lnum, 'cnum' : a:cnum + 1},
                                    \    'close' : {'lnum' : a:lnum, 'cnum' : a:cnum + strlen(l:match)},
                                    \    'text' : l:match
                                    \   }
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:text_between(p1, p2, ...) abort " {{{1
                              let [l1, c1] = [a:p1.lnum, a:p1.cnum - (a:0 > 0)]
                              let [l2, c2] = [a:p2.lnum, a:p2.cnum - (a:0 <= 0)]
                            
                              let lines = getline(l1, l2)
                              if !empty(lines)
                                let lines[0] = strpart(lines[0], c1)
                                let lines[-1] = strpart(lines[-1], 0,
                                      \ l1 == l2 ? c2 - c1 : c2)
                              endif
                              return join(lines, "\n")
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/complete.vim
Sourced 1 time
Total time:   0.000630
 Self time:   0.000630

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#complete#init_buffer() abort " {{{1
                              if !g:vimtex_complete_enabled | return | endif
                            
                              if !has_key(b:vimtex, 'complete')
                                let b:vimtex.complete = {}
                              endif
                            
                              for l:completer in s:completers
                                if has_key(l:completer, 'init')
                                  call l:completer.init()
                                endif
                              endfor
                            
                              setlocal omnifunc=vimtex#complete#omnifunc
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#complete#omnifunc(findstart, base) abort " {{{1
                              if a:findstart
                                if exists('s:completer') | unlet s:completer | endif
                            
                                let l:pos  = col('.') - 1
                                let l:line = getline('.')[:l:pos-1]
                                for l:completer in s:completers
                                  if !get(l:completer, 'enabled', 1) | continue | endif
                            
                                  for l:pattern in l:completer.patterns
                                    if l:line =~# l:pattern
                                      let s:completer = l:completer
                                      while l:pos > 0
                                        if l:line[l:pos - 1] =~# '{\|,\|\[\|\\'
                                              \ || l:line[l:pos-2:l:pos-1] ==# ', '
                                          let s:completer.context = matchstr(l:line,
                                                \ get(s:completer, 're_context', '\S*$'))
                                          return l:pos
                                        else
                                          let l:pos -= 1
                                        endif
                                      endwhile
                                      return -2
                                    endif
                                  endfor
                                endfor
                                return -3
                              elseif !exists('s:completer')
                                return []
                              endif
                            
                              return g:vimtex_complete_close_braces && get(s:completer, 'inside_braces', 1)
                                    \ ? s:close_braces(s:completer.complete(a:base))
                                    \ : s:completer.complete(a:base)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#complete#complete(type, input, context) abort " {{{1
                              try
                                let s:completer = s:completer_{a:type}
                                let s:completer.context = a:context
                                return s:completer.complete(a:input)
                              catch /E121/
                                return []
                              endtry
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Completers
                            "
                            " {{{1 Bibtex
                            
    1              0.000018 let s:completer_bib = {
                                  \ 'patterns' : [
                                  \   '\v\\%(\a*cite|Cite)\a*\*?%(\s*\[[^]]*\]){0,2}\s*\{[^}]*$',
                                  \   '\v\\%(\a*cites|Cites)%(\s*\([^)]*\)){0,2}'
                                  \     . '%(%(\s*\[[^]]*\]){0,2}\s*\{[^}]*\})*'
                                  \     . '%(\s*\[[^]]*\]){0,2}\s*\{[^}]*$',
                                  \   '\v\\bibentry\s*\{[^}]*$',
                                  \   '\v\\%(text|block)cquote\*?%(\s*\[[^]]*\]){0,2}\{[^}]*$',
                                  \   '\v\\%(for|hy)\w+cquote\*?\{[^}]*\}%(\s*\[[^]]*\]){0,2}\{[^}]*$',
                                  \   '\v\\defbibentryset\{[^}]*\}\{[^}]*$',
                                  \  ],
                                  \ 'initialized' : 0,
                                  \}
                            
    1              0.000002 function! s:completer_bib.init() dict abort " {{{2
                              if self.initialized | return | endif
                              let self.initialized = 1
                            
                              let self.patterns += g:vimtex_complete_bib.custom_patterns
                            endfunction
                            
    1              0.000002 function! s:completer_bib.complete(regex) dict abort " {{{2
                              let self.candidates = self.gather_candidates()
                            
                              if g:vimtex_complete_bib.simple
                                call s:filter(self.candidates, a:regex)
                              else
                                call s:filter_with_options(self.candidates, a:regex, {
                                      \ 'anchor': 0,
                                      \ 'filter_key': 'mstr',
                                      \})
                              endif
                            
                              return self.candidates
                            endfunction
                            
    1              0.000002 function! s:completer_bib.gather_candidates() dict abort " {{{2
                              let l:entries = []
                            
                              let l:cache = vimtex#cache#open('bibcomplete', {
                                    \ 'local': 1,
                                    \ 'default': {'result': [], 'ftime': -1},
                                    \ 'validate': {'options': deepcopy(g:vimtex_complete_bib)}
                                    \})
                            
                              "
                              " Find data from external bib files
                              "
                            
                              " Note: bibtex seems to require that we are in the project root
                              call vimtex#paths#pushd(b:vimtex.root)
                              for l:file in vimtex#bib#files()
                                let l:current = l:cache.get(l:file)
                                let l:ftime = getftime(l:file)
                                if l:ftime > l:current.ftime
                                  let l:current.ftime = l:ftime
                                  let l:current.result = map(
                                        \ vimtex#parser#bib(l:file),
                                        \ {_, x -> s:bib_to_candidate(x)})
                                  let l:cache.modified = 1
                                endif
                                let l:entries += l:current.result
                              endfor
                            
                              call vimtex#paths#popd()
                            
                              "
                              " Find data from 'thebibliography' environments
                              "
                              let l:ftime = b:vimtex.getftime()
                              if l:ftime > 0
                                let l:current = l:cache.get(sha256(b:vimtex.tex))
                            
                                if l:ftime > l:current.ftime
                                  let l:current.ftime = l:ftime
                                  let l:current.result = []
                            
                                  let l:lines = vimtex#parser#tex(b:vimtex.tex, {'detailed' : 0})
                                  if match(l:lines, '\C\\begin{thebibliography}') >= 0
                                    call filter(l:lines, 'v:val =~# ''\C\\bibitem''')
                            
                                    for l:line in l:lines
                                      let l:matches = matchlist(l:line, '\\bibitem\(\[[^]]\]\)\?{\([^}]*\)')
                                      if len(l:matches) > 1
                                        call add(l:current.result, s:bib_to_candidate({
                                              \ 'key': l:matches[2],
                                              \ 'type': 'thebibliography',
                                              \ 'author': '',
                                              \ 'year': '',
                                              \ 'title': l:matches[2],
                                              \ }))
                                      endif
                                    endfor
                                  endif
                                endif
                            
                                let l:entries += l:current.result
                              endif
                            
                              " Write cache to file
                              call l:cache.write()
                            
                              return l:entries
                            endfunction
                            
                            " }}}2
                            
    1              0.000002 function! s:bib_to_candidate(entry) abort " {{{2
                              let l:auth = substitute(get(a:entry, 'author', 'Unknown'), '\~', ' ', 'g')
                            
                              let l:substitutes = {
                                    \ '@author_all' : g:vimtex_complete_bib.auth_len > 0
                                    \     ? strcharpart(l:auth, 0, g:vimtex_complete_bib.auth_len)
                                    \     : l:auth,
                                    \ '@author_short' : substitute(l:auth, ',.*\ze', ' et al.', ''),
                                    \ '@key' : a:entry['key'],
                                    \ '@title' : get(a:entry, 'title', 'No title'),
                                    \ '@type' : empty(a:entry['type']) ? '-' : a:entry['type'],
                                    \ '@year' : get(a:entry, 'year', get(a:entry, 'date', '?')),
                                    \}
                            
                              let l:cand = {'word': a:entry['key']}
                            
                              " Create match and menu strings
                              let l:cand.mstr = copy(g:vimtex_complete_bib.match_str_fmt)
                              let l:cand.menu = copy(g:vimtex_complete_bib.menu_fmt)
                              let l:cand.info = copy(g:vimtex_complete_bib.info_fmt)
                              for [l:key, l:val] in items(l:substitutes)
                                let l:val = escape(l:val, '&')
                                let l:cand.mstr = substitute(l:cand.mstr, l:key, l:val, '')
                                let l:cand.menu = substitute(l:cand.menu, l:key, l:val, '')
                                let l:cand.info = substitute(l:cand.info, l:key, l:val, '')
                              endfor
                              if empty(l:cand.menu)
                                unlet l:cand.menu
                              endif
                              if empty(l:cand.info)
                                unlet l:cand.info
                              endif
                            
                              " Create abbreviation string (if necessary)
                              if !empty(g:vimtex_complete_bib.abbr_fmt)
                                let l:cand.abbr = copy(g:vimtex_complete_bib.abbr_fmt)
                                for [l:key, l:val] in items(l:substitutes)
                                  let l:cand.abbr = substitute(l:cand.abbr, l:key, escape(l:val, '&'), '')
                                endfor
                              endif
                            
                              return l:cand
                            endfunction
                            
                            " }}}2
                            
                            " }}}1
                            " {{{1 Labels
                            
    1              0.000011 let s:completer_ref = {
                                  \ 'patterns' : [
                                  \   '\v\\v?%(auto|eq|[cC]?%(page)?|labelc)?ref%(\s*\{[^}]*|range\s*\{[^,{}]*%(\}\{)?)$',
                                  \   '\\hyperref\s*\[[^]]*$',
                                  \   '\\subref\*\?{[^}]*$',
                                  \   '\\nameref{[^}]*$',
                                  \ ],
                                  \ 're_context' : '\\\w*{[^}]*$',
                                  \ 'initialized' : 0,
                                  \}
                            
    1              0.000002 function! s:completer_ref.init() dict abort " {{{2
                              if self.initialized | return | endif
                              let self.initialized = 1
                            
                              " Add custom patterns
                              let self.patterns += g:vimtex_complete_ref.custom_patterns
                            endfunction
                            
    1              0.000002 function! s:completer_ref.complete(regex) dict abort " {{{2
                              let l:candidates = self.get_matches(a:regex)
                            
                              if self.context =~# '\\eqref'
                                    \ && !empty(filter(copy(l:candidates), 'v:val.word =~# ''^eq:'''))
                                call filter(l:candidates, 'v:val.word =~# ''^eq:''')
                              endif
                            
                              return l:candidates
                            endfunction
                            
    1              0.000002 function! s:completer_ref.get_matches(regex) dict abort " {{{2
                              let l:labels = vimtex#parser#auxiliary#labels()
                            
                              " Match number
                              let l:matches = filter(copy(l:labels), {_, x -> x.menu =~# a:regex})
                              if !empty(l:matches) | return l:matches | endif
                            
                              " Match label
                              let l:matches = filter(copy(l:labels), {_, x -> x.word =~# a:regex})
                              if !empty(l:matches) | return l:matches | endif
                            
                              " Match label and number
                              let l:regex_split = split(a:regex)
                              if len(l:regex_split) > 1
                                let l:base = l:regex_split[0]
                                let l:number = escape(join(l:regex_split[1:], ' '), '.')
                                let l:matches = filter(copy(l:labels),
                                      \ {_, x -> x.word =~# l:base && x.menu =~# l:number})
                              endif
                            
                              return l:matches
                            endfunction
                            
                            " }}}1
                            " {{{1 Commands
                            
    1              0.000007 let s:completer_cmd = {
                                  \ 'patterns' : [g:vimtex#re#not_bslash . '\\\a*$'],
                                  \ 'inside_braces' : 0,
                                  \}
                            
    1              0.000002 function! s:completer_cmd.complete(regex) dict abort " {{{2
                              let l:candidates = self.gather_candidates()
                              let l:mode = vimtex#syntax#in_mathzone() ? 'm' : 'n'
                            
                              call s:filter(l:candidates, a:regex)
                              call filter(l:candidates, 'l:mode =~# v:val.mode')
                            
                              return l:candidates
                            endfunction
                            
    1              0.000002 function! s:completer_cmd.gather_candidates() dict abort " {{{2
                              let l:candidates = s:load_from_document('cmd')
                              let l:candidates += self.gather_candidates_from_lets()
                              for l:pkg in s:get_packages()
                                let l:candidates += s:load_from_package(l:pkg, 'cmd')
                              endfor
                              let l:candidates += self.gather_candidates_from_glossary_keys()
                            
                              return vimtex#util#uniq_unsorted(l:candidates)
                            endfunction
                            
    1              0.000002 function! s:completer_cmd.gather_candidates_from_glossary_keys() dict abort " {{{2
                              if !has_key(b:vimtex.packages, 'glossaries') | return [] | endif
                            
                              let l:preamble = vimtex#parser#preamble(b:vimtex.tex)
                              call map(l:preamble, {_, x -> substitute(x, '\s*%.*', '', 'g')})
                              let l:glskeys = split(join(l:preamble, "\n"), '\n\s*\\glsaddkey\*\?')[1:]
                              call map(l:glskeys, {_, x -> substitute(x, '\n\s*', '', 'g')})
                              call map(l:glskeys, 'vimtex#util#tex2tree(v:val)[2:6]')
                            
                              let l:candidates = map(vimtex#util#flatten(l:glskeys), {_, x -> {
                                    \ 'word' : x[1:],
                                    \ 'mode' : '.',
                                    \ 'kind' : '[cmd: glossaries]',
                                    \}})
                            
                              return l:candidates
                            endfunction
                            
    1              0.000002 function! s:completer_cmd.gather_candidates_from_lets() dict abort " {{{2
                              let l:preamble = vimtex#parser#preamble(b:vimtex.tex)
                            
                              let l:lets = filter(copy(l:preamble), 'v:val =~# ''\\let\>''')
                              let l:defs = filter(copy(l:preamble), 'v:val =~# ''\\def\>''')
                              let l:candidates = map(l:lets, {_, x -> {
                                    \ 'word': matchstr(x, '\\let[^\\]*\\\zs\w*'),
                                    \ 'mode': '.',
                                    \ 'kind': '[cmd: \let]',
                                    \}})
                                    \ + map(l:defs, {_, x -> {
                                    \ 'word': matchstr(x, '\\def[^\\]*\\\zs\w*'),
                                    \ 'mode': '.',
                                    \ 'kind': '[cmd: \def]',
                                    \}})
                            
                              return l:candidates
                            endfunction
                            
                            " }}}1
                            " {{{1 Environments
                            
    1              0.000004 let s:completer_env = {
                                  \ 'patterns' : ['\v\\%(begin|end)%(\s*\[[^]]*\])?\s*\{[^}]*$'],
                                  \}
                            
    1              0.000002 function! s:completer_env.complete(regex) dict abort " {{{2
                              if self.context =~# '^\\end\>'
                                " When completing \end{, search for an unmatched \begin{...}
                                let l:matching_env = ''
                                let l:save_pos = vimtex#pos#get_cursor()
                                let l:pos_val_cursor = vimtex#pos#val(l:save_pos)
                            
                                let l:lnum = l:save_pos[1] + 1
                                while l:lnum > 1
                                  let l:open  = vimtex#delim#get_prev('env_tex', 'open')
                                  if empty(l:open) || get(l:open, 'name', '') ==# 'document'
                                    break
                                  endif
                            
                                  let l:close = vimtex#delim#get_matching(l:open)
                                  if empty(l:close.match)
                                    let l:matching_env = l:close.name . (l:close.starred ? '*' : '')
                                    break
                                  endif
                            
                                  let l:pos_val_try = vimtex#pos#val(l:close) + strlen(l:close.match)
                                  if l:pos_val_try > l:pos_val_cursor
                                    break
                                  else
                                    let l:lnum = l:open.lnum
                                    call vimtex#pos#set_cursor(vimtex#pos#prev(l:open))
                                  endif
                                endwhile
                            
                                call vimtex#pos#set_cursor(l:save_pos)
                            
                                if !empty(l:matching_env) && l:matching_env =~# a:regex
                                  return [{
                                        \ 'word': l:matching_env,
                                        \ 'kind': '[env: matching]',
                                        \}]
                                endif
                              endif
                            
                              return s:filter(copy(self.gather_candidates()), a:regex)
                            endfunction
                            
                            " }}}2
    1              0.000002 function! s:completer_env.gather_candidates() dict abort " {{{2
                              let l:candidates = s:load_from_document('env')
                              for l:pkg in s:get_packages()
                                let l:candidates += s:load_from_package(l:pkg, 'env')
                              endfor
                            
                              return vimtex#util#uniq_unsorted(l:candidates)
                            endfunction
                            
                            " }}}2
                            " }}}1
                            " {{{1 Filenames (\includegraphics)
                            
    1              0.000012 let s:completer_img = {
                                  \ 'patterns' : ['\v\\includegraphics\*?%(\s*\[[^]]*\]){0,2}\s*\{[^}]*$'],
                                  \ 'ext_re' : '\v\.%('
                                  \   . join(['png', 'jpg', 'eps', 'pdf', 'pgf', 'tikz'], '|')
                                  \   . ')$',
                                  \}
                            
    1              0.000003 function! s:completer_img.complete(regex) dict abort " {{{2
                              return s:filter(self.gather_candidates(), a:regex)
                            endfunction
                            
    1              0.000001 function! s:completer_img.gather_candidates() dict abort " {{{2
                              let l:added_files = []
                              let l:generated_pdf = b:vimtex.compiler.get_file('pdf')
                            
                              let l:candidates = []
                              for l:path in b:vimtex.graphicspath + [b:vimtex.root]
                                let l:files = globpath(l:path, '**/*.*', 1, 1)
                            
                                call filter(l:files,
                                      \ {_, x ->    x =~? self.ext_re
                                      \          && x !=# l:generated_pdf
                                      \          && index(l:added_files, x) < 0})
                            
                                let l:added_files += l:files
                                let l:candidates += map(l:files, {_, x -> {
                                        \ 'abbr': vimtex#paths#shorten_relative(x),
                                        \ 'word': vimtex#paths#relative(x, l:path),
                                        \ 'kind': '[graphics]',
                                        \}})
                              endfor
                            
                              return l:candidates
                            endfunction
                            
                            " }}}1
                            " {{{1 Filenames (\input, \include, and \subfile)
                            
    1              0.000006 let s:completer_inc = {
                                  \ 'patterns' : [
                                  \   g:vimtex#re#tex_input . '[^}]*$',
                                  \   '\v\\includeonly\s*\{[^}]*$',
                                  \ ],
                                  \}
                            
    1              0.000002 function! s:completer_inc.complete(regex) dict abort " {{{2
                              let self.candidates = globpath(b:vimtex.root, '**/*.tex', 0, 1)
                            
                              " Add .tikz files if appropriate
                              if has_key(b:vimtex.packages, 'tikz') && self.context !~# '\\subfile'
                                call extend(self.candidates,
                                      \ globpath(b:vimtex.root, '**/*.tikz', 0, 1))
                              endif
                            
                              let self.candidates = map(self.candidates,
                                    \ 'strpart(v:val, len(b:vimtex.root)+1)')
                              call s:filter(self.candidates, a:regex)
                            
                              if self.context =~# '\\include'
                                let self.candidates = map(self.candidates, {_, x -> {
                                      \ 'word': fnamemodify(x, ':r'),
                                      \ 'kind': '[include]',
                                      \}})
                              else
                                let self.candidates = map(self.candidates, {_, x -> {
                                      \ 'word': x,
                                      \ 'kind': '[input]',
                                      \}})
                              endif
                            
                              return self.candidates
                            endfunction
                            
                            " }}}1
                            " {{{1 Filenames (\includepdf)
                            
    1              0.000004 let s:completer_pdf = {
                                  \ 'patterns' : ['\v\\includepdf%(\s*\[[^]]*\])?\s*\{[^}]*$'],
                                  \}
                            
    1              0.000002 function! s:completer_pdf.complete(regex) dict abort " {{{2
                              let self.candidates = globpath(b:vimtex.root, '**/*.pdf', 0, 1)
                              let self.candidates = map(self.candidates,
                                    \ 'strpart(v:val, len(b:vimtex.root)+1)')
                              call s:filter(self.candidates, a:regex)
                              let self.candidates = map(self.candidates, {_, x -> {
                                    \ 'word': x,
                                    \ 'kind': '[includepdf]',
                                    \}})
                              return self.candidates
                            endfunction
                            
                            " }}}1
                            " {{{1 Filenames (\includestandalone)
                            
    1              0.000004 let s:completer_sta = {
                                  \ 'patterns' : ['\v\\includestandalone%(\s*\[[^]]*\])?\s*\{[^}]*$'],
                                  \}
                            
    1              0.000002 function! s:completer_sta.complete(regex) dict abort " {{{2
                              let self.candidates = substitute(
                                    \ globpath(b:vimtex.root, '**/*.tex'), '\.tex', '', 'g')
                              let self.candidates = split(self.candidates, '\n')
                              let self.candidates = map(self.candidates,
                                    \ 'strpart(v:val, len(b:vimtex.root)+1)')
                              call s:filter(self.candidates, a:regex)
                              let self.candidates = map(self.candidates, {_, x -> {
                                    \ 'word': x,
                                    \ 'kind': '[includestandalone]',
                                    \}})
                              return self.candidates
                            endfunction
                            
                            " }}}1
                            " {{{1 Glossary (\gls +++)
                            
    1              0.000015 let s:completer_gls = {
                                  \ 'patterns' : [
                                  \   '\v\\([cpdr]?(gls|Gls|GLS)|acr|Acr|ACR)\a*\s*\{[^}]*$',
                                  \   '\v\\(ac|Ac|AC)\s*\{[^}]*$',
                                  \ ],
                                  \ 'key' : {
                                  \   'newglossaryentry' : ' [gls]',
                                  \   'longnewglossaryentry' : ' [gls]',
                                  \   'newacronym' : ' [acr]',
                                  \   'newabbreviation' : ' [abbr]',
                                  \   'glsxtrnewsymbol' : ' [symbol]',
                                  \ },
                                  \}
                            
    1              0.000002 function! s:completer_gls.init() dict abort " {{{2
                              if !has_key(b:vimtex.packages, 'glossaries-extra') | return | endif
                            
                              " Detect stuff like this:
                              "  \GlsXtrLoadResources[src=glossary.bib]
                              "  \GlsXtrLoadResources[src={glossary.bib}, selection={all}]
                              "  \GlsXtrLoadResources[selection={all},src={glossary.bib}]
                              "  \GlsXtrLoadResources[
                              "    src={glossary.bib},
                              "    selection={all},
                              "  ]
                            
                              let l:do_search = 0
                              for l:line in vimtex#parser#preamble(b:vimtex.tex)
                                if line =~# '^\s*\\GlsXtrLoadResources\s*\['
                                  let l:do_search = 1
                                  let l:line = matchstr(l:line, '^\s*\\GlsXtrLoadResources\s*\[\zs.*')
                                endif
                                if !l:do_search | continue | endif
                            
                                let l:matches = split(l:line, '[=,]')
                                if empty(l:matches) | continue | endif
                            
                                while !empty(l:matches)
                                  let l:key = vimtex#util#trim(remove(l:matches, 0))
                                  if l:key ==# 'src'
                                    let l:value = vimtex#util#trim(remove(l:matches, 0))
                                    let l:value = substitute(l:value, '^{', '', '')
                                    let l:value = substitute(l:value, '[]}]\s*', '', 'g')
                                    let b:vimtex.complete.glsbib = l:value
                                    break
                                  endif
                                endwhile
                              endfor
                            endfunction
                            
    1              0.000002 function! s:completer_gls.complete(regex) dict abort " {{{2
                              return s:filter(
                                    \ self.parse_glsentries() + self.parse_glsbib(), a:regex)
                            endfunction
                            
    1              0.000001 function! s:completer_gls.parse_glsentries() dict abort " {{{2
                              let l:candidates = []
                            
                              let l:re_commands = '\v\\(' . join(keys(self.key), '|') . ')'
                              let l:re_matcher = l:re_commands . '\s*%(\[.*\])=\s*\{([^{}]*)'
                            
                              for l:line in filter(
                                    \ vimtex#parser#tex(b:vimtex.tex, {'detailed' : 0}),
                                    \ 'v:val =~# l:re_commands')
                                let l:matches = matchlist(l:line, l:re_matcher)
                                call add(l:candidates, {
                                      \ 'word' : l:matches[2],
                                      \ 'menu' : self.key[l:matches[1]],
                                      \})
                              endfor
                            
                              return l:candidates
                            endfunction
                            
    1              0.000002 function! s:completer_gls.parse_glsbib() dict abort " {{{2
                              let l:filename = get(b:vimtex.complete, 'glsbib', '')
                              if empty(l:filename) | return [] | endif
                            
                              let l:candidates = []
                              for l:entry in vimtex#parser#bib(l:filename, {'backend': 'vim'})
                                call add(l:candidates, {
                                      \ 'word': l:entry.key,
                                      \ 'menu': get(l:entry, 'name', '--'),
                                      \})
                              endfor
                            
                              return l:candidates
                            endfunction
                            
                            " }}}1
                            " {{{1 Packages (\usepackage)
                            
    1              0.000007 let s:completer_pck = {
                                  \ 'patterns' : [
                                  \   '\v\\%(usepackage|RequirePackage)%(\s*\[[^]]*\])?\s*\{[^}]*$',
                                  \   '\v\\PassOptionsToPackage\s*\{[^}]*\}\s*\{[^}]*$',
                                  \ ],
                                  \ 'candidates' : [],
                                  \}
                            
    1              0.000002 function! s:completer_pck.complete(regex) dict abort " {{{2
                              return s:filter(self.gather_candidates(), a:regex)
                            endfunction
                            
    1              0.000002 function! s:completer_pck.gather_candidates() dict abort " {{{2
                              if empty(self.candidates)
                                let self.candidates = map(s:get_texmf_candidates('sty'), {_, x -> {
                                      \ 'word': x,
                                      \ 'kind': '[package]',
                                      \}})
                              endif
                            
                              return copy(self.candidates)
                            endfunction
                            
                            " }}}1
                            " {{{1 Documentclasses (\documentclass)
                            
    1              0.000007 let s:completer_doc = {
                                  \ 'patterns' : [
                                  \   '\v\\documentclass%(\s*\[[^]]*\])?\s*\{[^}]*$',
                                  \   '\v\\PassOptionsToClass\s*\{[^}]*\}\s*\{[^}]*$',
                                  \ ],
                                  \ 'candidates' : [],
                                  \}
                            
    1              0.000002 function! s:completer_doc.complete(regex) dict abort " {{{2
                              return s:filter(self.gather_candidates(), a:regex)
                            endfunction
                            
    1              0.000001 function! s:completer_doc.gather_candidates() dict abort " {{{2
                              if empty(self.candidates)
                                let self.candidates = map(s:get_texmf_candidates('cls'), {_, x -> {
                                      \ 'word' : x,
                                      \ 'kind' : '[documentclass]',
                                      \}})
                              endif
                            
                              return copy(self.candidates)
                            endfunction
                            
                            " }}}1
                            " {{{1 Bibliographystyles (\bibliographystyle)
                            
    1              0.000005 let s:completer_bst = {
                                  \ 'patterns' : ['\v\\bibliographystyle\s*\{[^}]*$'],
                                  \ 'candidates' : [],
                                  \}
                            
    1              0.000002 function! s:completer_bst.complete(regex) dict abort " {{{2
                              return s:filter(self.gather_candidates(), a:regex)
                            endfunction
                            
    1              0.000002 function! s:completer_bst.gather_candidates() dict abort " {{{2
                              if empty(self.candidates)
                                let self.candidates = map(s:get_texmf_candidates('bst'), {_, x -> {
                                      \ 'word' : x,
                                      \ 'kind' : '[bst files]',
                                      \}})
                              endif
                            
                              return copy(self.candidates)
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Functions to parse candidates from packages
                            "
    1              0.000002 function! s:get_packages() abort " {{{1
                              let l:packages = [
                                    \   'default',
                                    \   'class-' . get(b:vimtex, 'documentclass', ''),
                                    \  ] + keys(b:vimtex.packages)
                            
                              call vimtex#paths#pushd(s:complete_dir)
                            
                              let l:missing = filter(copy(l:packages), '!filereadable(v:val)')
                              call filter(l:packages, 'filereadable(v:val)')
                            
                              " Parse include statements in complete files
                              let l:queue = copy(l:packages)
                              while !empty(l:queue)
                                let l:current = remove(l:queue, 0)
                                let l:includes = filter(readfile(l:current), 'v:val =~# ''^\#\s*include:''')
                                if empty(l:includes) | continue | endif
                            
                                call map(l:includes, {_, x -> matchstr(x, 'include:\s*\zs.*\ze\s*$')})
                                let l:missing += filter(copy(l:includes),
                                      \ {_, x -> !filereadable(x) && index(l:missing, x) < 0})
                                call filter(l:includes,
                                      \ {_, x -> filereadable(x) && index(l:packages, x) < 0})
                            
                                let l:packages += l:includes
                                let l:queue += l:includes
                              endwhile
                            
                              call vimtex#paths#popd()
                            
                              return l:packages + l:missing
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:load_from_package(pkg, type) abort " {{{1
                              let s:pkg_cache = get(s:, 'pkg_cache',
                                    \ vimtex#cache#open('pkgcomplete', {'default': {}}))
                              let l:current = s:pkg_cache.get(a:pkg)
                            
                              let l:pkg_file = s:complete_dir . '/' . a:pkg
                              if filereadable(l:pkg_file)
                                if !has_key(l:current, 'candidates')
                                  let s:pkg_cache.modified = 1
                                  let l:current.candidates
                                        \ = s:_load_candidates_from_complete_file(a:pkg, l:pkg_file)
                                endif
                              else
                                if !has_key(l:current, 'candidates')
                                  let s:pkg_cache.modified = 1
                                  let l:current.candidates = {'cmd': [], 'env': []}
                                endif
                            
                                let l:filename = a:pkg =~# '^class-'
                                      \ ? vimtex#kpsewhich#find(a:pkg[6:] . '.cls')
                                      \ : vimtex#kpsewhich#find(a:pkg . '.sty')
                            
                                let l:ftime = getftime(l:filename)
                                if l:ftime > get(l:current, 'ftime', -1)
                                  let s:pkg_cache.modified = 1
                                  let l:current.ftime = l:ftime
                                  let l:current.candidates = s:_load_candidates_from_source(
                                        \ readfile(l:filename), a:pkg)
                                endif
                              endif
                            
                              " Write cache to file
                              call s:pkg_cache.write()
                            
                              return copy(l:current.candidates[a:type])
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:load_from_document(type) abort " {{{1
                              let s:pkg_cache = get(s:, 'pkg_cache',
                                    \ vimtex#cache#open('pkgcomplete', {'default': {}}))
                            
                              let l:ftime = b:vimtex.getftime()
                              if l:ftime < 0 | return [] | endif
                            
                              let l:current = s:pkg_cache.get(sha256(b:vimtex.tex))
                              if l:ftime > get(l:current, 'ftime', -1)
                                let l:current.ftime = l:ftime
                                let l:current.candidates = s:_load_candidates_from_source(
                                    \ vimtex#parser#tex(b:vimtex.tex, {'detailed' : 0}),
                                    \ 'local')
                            
                                " Write cache to file
                                let s:pkg_cache.modified = 1
                                call s:pkg_cache.write()
                              endif
                            
                              return copy(l:current.candidates[a:type])
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:_load_candidates_from_complete_file(pkg, pkgfile) abort " {{{1
                              let l:result = {'cmd': [], 'env': []}
                              let l:lines = readfile(a:pkgfile)
                            
                              let l:candidates = filter(copy(l:lines), 'v:val =~# ''^\a''')
                              call map(l:candidates, 'split(v:val)')
                              call map(l:candidates, {_, x -> {
                                    \ 'word': x[0],
                                    \ 'mode': '.',
                                    \ 'kind': '[cmd: ' . a:pkg . '] ',
                                    \ 'menu': get(x, 1, ''),
                                    \}})
                              let l:result.cmd += l:candidates
                            
                              let l:candidates = filter(l:lines, 'v:val =~# ''^\\begin{''')
                              call map(l:candidates, {_, x -> {
                                    \ 'word': substitute(x, '^\\begin{\|}$', '', 'g'),
                                    \ 'mode': '.',
                                    \ 'kind': '[env: ' . a:pkg . '] ',
                                    \}})
                              let l:result.env += l:candidates
                            
                              return l:result
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:_load_candidates_from_source(lines, pkg) abort " {{{1
                              return {
                                    \ 'cmd':
                                    \   s:gather_candidates_from_newcommands(
                                    \     copy(a:lines), 'cmd: ' . a:pkg),
                                    \ 'env':
                                    \   s:gather_candidates_from_newenvironments(
                                    \     a:lines, 'env: ' . a:pkg)
                                    \}
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:gather_candidates_from_newcommands(lines, label) abort " {{{1
                              " Arguments:
                              "   a:lines   Lines of TeX that may contain \newcommands (or some variant,
                              "             e.g. as provided by xparse and standard declaration)
                              "   a:label   Label to use in the menu
                            
                              let l:re = '\v\\%(%(provide|renew|new)command'
                                    \ . '|%(New|Declare|Provide|Renew)%(Expandable)?DocumentCommand'
                                    \ . '|DeclarePairedDelimiter)'
                              let l:re_match = l:re . '\*?%(\{\\?\zs[^}]*|\\\zs\w+)'
                            
                              return map(filter(a:lines, 'v:val =~# l:re'), {_, x -> {
                                    \ 'word': matchstr(x, l:re_match),
                                    \ 'mode': '.',
                                    \ 'kind': '[' . a:label . ']',
                                    \}})
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:gather_candidates_from_newenvironments(lines, label) abort " {{{1
                              " Arguments:
                              "   a:lines   Lines of TeX that may contain \newenvironments (or some
                              "             variant, e.g. as provided by xparse and standard declaration)
                              "   a:label   Label to use in the menu
                            
                              let l:re = '\v\\((renew|new)environment'
                                    \ . '|(New|Renew|Provide|Declare)DocumentEnvironment)'
                              let l:re_match = l:re . '\*?\{\\?\zs[^}]*'
                            
                              return map(filter(a:lines, 'v:val =~# l:re'), {_, x -> {
                                    \ 'word': matchstr(x, l:re_match),
                                    \ 'mode': '.',
                                    \ 'kind': '[' . a:label . ']',
                                    \}})
                            endfunction
                            
                            " }}}1
                            
                            
                            "
                            " Utility functions
                            "
    1              0.000002 function! s:filter(input, regex) abort " {{{1
                              if empty(a:input) | return a:input | endif
                            
                              let l:ignore_case = g:vimtex_complete_ignore_case
                                    \ && (!g:vimtex_complete_smart_case || a:regex !~# '\u')
                            
                              if type(a:input[0]) == v:t_dict
                                let l:Filter = l:ignore_case
                                      \ ? {_, x -> x.word =~? '^' . a:regex}
                                      \ : {_, x -> x.word =~# '^' . a:regex}
                              else
                                let l:Filter = l:ignore_case
                                      \ ? {_, x -> x =~? '^' . a:regex}
                                      \ : {_, x -> x =~# '^' . a:regex}
                              endif
                            
                              return filter(a:input, l:Filter)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:filter_with_options(input, regex, opts) abort " {{{1
                              if empty(a:input) | return a:input | endif
                            
                              let l:regex = (get(a:opts, 'anchor', 1) ? '^' : '') . a:regex
                            
                              let l:ignore_case = g:vimtex_complete_ignore_case
                                    \ && (!g:vimtex_complete_smart_case || a:regex !~# '\u')
                            
                              if type(a:input[0]) == v:t_dict
                                let l:key = get(a:opts, 'filter_key', 'word')
                                let l:Filter = l:ignore_case
                                      \ ? {_, x -> x[l:key] =~? l:regex}
                                      \ : {_, x -> x[l:key] =~# l:regex}
                              else
                                let l:Filter = l:ignore_case
                                      \ ? {_, x -> x =~? l:regex}
                                      \ : {_, x -> x =~# l:regex}
                              endif
                            
                              return filter(a:input, l:Filter)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_texmf_candidates(filetype) abort " {{{1
                              let l:candidates = []
                            
                              let l:texmfhome = $TEXMFHOME
                              if empty(l:texmfhome)
                                let l:texmfhome = get(vimtex#kpsewhich#run('--var-value TEXMFHOME'), 0, '')
                              endif
                            
                              " Add locally installed candidates first
                              if !empty(l:texmfhome)
                                let l:candidates += glob(l:texmfhome . '/**/*.' . a:filetype, 0, 1)
                                call map(l:candidates, "fnamemodify(v:val, ':t:r')")
                              endif
                            
                              " Then add globally available candidates (based on ls-R files)
                              for l:file in vimtex#kpsewhich#run('--all ls-R')
                                let l:candidates += map(filter(readfile(l:file),
                                      \   {_, x -> x =~# '\.' . a:filetype}),
                                      \ "fnamemodify(v:val, ':r')")
                              endfor
                            
                              return l:candidates
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:close_braces(candidates) abort " {{{1
                              if strpart(getline('.'), col('.') - 1) !~# '^\s*[,}]'
                                for l:cand in a:candidates
                                  if !has_key(l:cand, 'abbr')
                                    let l:cand.abbr = l:cand.word
                                  endif
                                  let l:cand.word = substitute(l:cand.word, '}*$', '}', '')
                                endfor
                              endif
                            
                              return a:candidates
                            endfunction
                            
                            " }}}1
                            
                            
                            "
                            " Initialize module
                            "
    1              0.000050 let s:completers = map(
                                  \ filter(items(s:), 'v:val[0] =~# ''^completer_'''),
                                  \ 'v:val[1]')
                            
    1              0.000005 let s:complete_dir = expand('<sfile>:r') . '/'

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/debug.vim
Sourced 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#debug#stacktrace(...) abort " {{{1
                              " This function builds on Luc Hermite's answer on Stack Exchange:
                              " http://vi.stackexchange.com/a/6024/21
                            
                              " Get stack and exception
                              if empty(v:throwpoint)
                                try
                                  throw 'dummy'
                                catch
                                  let l:stack = reverse(split(v:throwpoint, '\.\.'))[1:]
                                  let l:exception = 'Manual stacktrace'
                                endtry
                              else
                                let l:stack = reverse(split(v:throwpoint, '\.\.'))
                                let l:exception = v:exception
                              endif
                            
                              " Build the quickfix entries
                              let l:qflist = []
                              let l:files = {}
                              for l:func in l:stack
                                try
                                  let [l:name, l:offset] = (l:func =~# '\S\+\[\d')
                                        \ ? matchlist(l:func, '\(\S\+\)\[\(\d\+\)\]')[1:2]
                                        \ : matchlist(l:func, '\(\S\+\), line \(\d\+\)')[1:2]
                                catch
                                  let l:name = l:func
                                  let l:offset = 0
                                endtry
                            
                                if l:name =~# '\v(\<SNR\>|^)\d+_'
                                  let l:sid = matchstr(l:name, '\v(\<SNR\>|^)\zs\d+\ze_')
                                  let l:name  = substitute(l:name, '\v(\<SNR\>|^)\d+_', 's:', '')
                                  let l:filename = substitute(
                                        \ vimtex#util#command('scriptnames')[l:sid-1],
                                        \ '^\s*\d\+:\s*', '', '')
                                else
                                  let l:func_name = l:name =~# '^\d\+$' ? '{' . l:name . '}' : l:name
                                  let l:func_lines = vimtex#util#command('verbose function ' . l:func_name)
                                  if len(l:func_lines) > 1
                                    let l:filename = matchstr(
                                          \ l:func_lines[1],
                                          \ v:lang[0:1] ==# 'en'
                                          \   ? 'Last set from \zs.*\.vim' : '\f\+\.vim')
                                  else
                                    let l:filename = 'NOFILE'
                                  endif
                                endif
                            
                                let l:filename = fnamemodify(l:filename, ':p')
                                if filereadable(l:filename)
                                  if !has_key(l:files, l:filename)
                                    let l:files[l:filename] = reverse(readfile(l:filename))
                                  endif
                            
                                  if l:name =~# '^\d\+$'
                                    let l:lnum = 0
                                    let l:output = vimtex#util#command('function {' . l:name . '}')
                                    let l:text = substitute(
                                          \ matchstr(l:output, '^\s*' . l:offset),
                                          \ '^\d\+\s*', '', '')
                                  else
                                    let l:lnum = l:offset + len(l:files[l:filename])
                                          \ - match(l:files[l:filename], '^\s*fu\%[nction]!\=\s\+' . l:name .'(')
                                    let l:lnum_rev = len(l:files[l:filename]) - l:lnum
                                    let l:text = substitute(l:files[l:filename][l:lnum_rev], '^\s*', '', '')
                                  endif
                                else
                                  let l:filename = ''
                                  let l:lnum = 0
                                  let l:text = ''
                                endif
                            
                                call add(l:qflist, {
                                      \ 'filename': l:filename,
                                      \ 'function': l:name,
                                      \ 'lnum': l:lnum,
                                      \ 'text': len(l:qflist) == 0 ? l:exception : l:text,
                                      \ 'nr': len(l:qflist),
                                      \})
                              endfor
                            
                              " Fill in empty filenames
                              let l:prev_filename = '_'
                              call reverse(l:qflist)
                              for l:entry in l:qflist
                                if empty(l:entry.filename)
                                  let l:entry.filename = l:prev_filename
                                endif
                                let l:prev_filename = l:entry.filename
                              endfor
                              call reverse(l:qflist)
                            
                              if a:0 > 0
                                call setqflist(l:qflist)
                                execute 'copen' len(l:qflist) + 2
                                wincmd p
                              endif
                            
                              return l:qflist
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim
Sourced 1 time
Total time:   0.001590
 Self time:   0.000628

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#delim#init_buffer() abort " {{{1
                              nnoremap <silent><buffer> <plug>(vimtex-delim-toggle-modifier)
                                    \ :<c-u>call <sid>operator_setup('toggle_modifier_next')
                                    \ <bar> normal! <c-r>=v:count ? v:count : ''<cr>g@l<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-delim-toggle-modifier-reverse)
                                    \ :<c-u>call <sid>operator_setup('toggle_modifier_prev')
                                    \ <bar> normal! <c-r>=v:count ? v:count : ''<cr>g@l<cr>
                            
                              xnoremap <silent><buffer> <plug>(vimtex-delim-toggle-modifier)
                                    \ :<c-u>call vimtex#delim#toggle_modifier_visual()<cr>
                            
                              xnoremap <silent><buffer> <plug>(vimtex-delim-toggle-modifier-reverse)
                                    \ :<c-u>call vimtex#delim#toggle_modifier_visual({'dir': -1})<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-delim-change-math)
                                    \ :<c-u>call <sid>operator_setup('change')<bar>normal! g@l<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-delim-delete)
                                    \ :<c-u>call <sid>operator_setup('delete')<bar>normal! g@l<cr>
                            
                              inoremap <silent><buffer><expr> <plug>(vimtex-delim-close)
                                    \ vimtex#delim#close()
                            
                              nnoremap <silent><buffer> <plug>(vimtex-delim-add-modifiers)
                                    \ :<c-u>call vimtex#delim#add_modifiers()<cr>
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#delim#close() abort " {{{1
                              let l:save_pos = vimtex#pos#get_cursor()
                              let l:indent = g:vimtex_indent_enabled ? "\<c-f>" : ''
                              let l:posval_cursor = vimtex#pos#val(l:save_pos)
                              let l:posval_current = l:posval_cursor
                              let l:posval_last = l:posval_cursor + 1
                            
                              while l:posval_current < l:posval_last
                                let l:open  = vimtex#delim#get_prev('all', 'open',
                                      \ { 'syn_exclude' : 'texComment' })
                                if empty(l:open) || get(l:open, 'name', '') ==# 'document'
                                  break
                                endif
                            
                                let l:close = vimtex#delim#get_matching(l:open)
                                if empty(l:close.match)
                                  call vimtex#pos#set_cursor(l:save_pos)
                                  return l:open.corr . l:indent
                                endif
                            
                                let l:posval_last = l:posval_current
                                let l:posval_current = vimtex#pos#val(l:open)
                                let l:posval_try = vimtex#pos#val(l:close) + strlen(l:close.match)
                                if l:posval_current != l:posval_cursor
                                      \ && l:posval_try > l:posval_cursor
                                  call vimtex#pos#set_cursor(l:save_pos)
                                  return l:open.corr . l:indent
                                endif
                            
                                call vimtex#pos#set_cursor(vimtex#pos#prev(l:open))
                              endwhile
                            
                              call vimtex#pos#set_cursor(l:save_pos)
                              return ''
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#delim#toggle_modifier(...) abort " {{{1
                              let l:args = a:0 > 0 ? a:1 : {}
                              call extend(l:args, {
                                  \ 'count': v:count1,
                                  \ 'dir': 1,
                                  \ 'repeat': 1,
                                  \ 'openclose': [],
                                  \ }, 'keep')
                            
                              let [l:open, l:close] = !empty(l:args.openclose)
                                    \ ? l:args.openclose
                                    \ : vimtex#delim#get_surrounding('delim_modq_math')
                              if empty(l:open) | return | endif
                            
                              let l:direction = l:args.dir < 0 ? -l:args.count : l:args.count
                            
                              let newmods = ['', '']
                              let modlist = [['', '']] + get(g:, 'vimtex_delim_toggle_mod_list',
                                    \ [['\left', '\right']])
                              let n = len(modlist)
                              for i in range(n)
                                let j = (i + l:direction) % n
                                if l:open.mod ==# modlist[i][0]
                                  let newmods = modlist[j]
                                  break
                                endif
                              endfor
                            
                              " Possibly shift right delimiter position
                              let l:cnum = l:close.cnum
                              let l:shift = len(newmods[0]) - len(l:open.mod)
                              if l:open.lnum == l:close.lnum
                                let l:cnum += l:shift
                              endif
                            
                              " Calculate new position
                              let l:pos = vimtex#pos#get_cursor()
                              let l:do_adjust_right = l:pos[2] >= l:close.cnum + len(l:close.mod)
                              if l:pos[1] == l:open.lnum && l:pos[2] > l:open.cnum
                                if l:pos[2] > l:open.cnum + len(l:open.mod)
                                  let l:pos[2] += l:shift
                                elseif l:shift < 0
                                  let l:pos[2] = l:open.cnum
                                endif
                              endif
                              if l:pos[1] == l:close.lnum && l:pos[2] >= l:cnum
                                if l:do_adjust_right
                                  let l:pos[2] += len(newmods[1]) - len(l:close.mod)
                                else
                                  let l:pos[2] = l:cnum
                                endif
                              endif
                            
                              " Change current text
                              let line = getline(l:open.lnum)
                              let line = strpart(line, 0, l:open.cnum - 1)
                                    \ . newmods[0]
                                    \ . strpart(line, l:open.cnum + len(l:open.mod) - 1)
                              call setline(l:open.lnum, line)
                            
                              let line = getline(l:close.lnum)
                              let line = strpart(line, 0, l:cnum - 1)
                                    \ . newmods[1]
                                    \ . strpart(line, l:cnum + len(l:close.mod) - 1)
                              call setline(l:close.lnum, line)
                            
                              call vimtex#pos#set_cursor(l:pos)
                            
                              return newmods
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#delim#toggle_modifier_visual(...) abort " {{{1
                              let l:args = a:0 > 0 ? a:1 : {}
                              call extend(l:args, {
                                  \ 'count': v:count1,
                                  \ 'dir': 1,
                                  \ 'reselect': 1,
                                  \ }, 'keep')
                            
                              let l:save_pos = vimtex#pos#get_cursor()
                              let l:start_pos = getpos("'<")
                              let l:end_pos = getpos("'>")
                              let l:end_pos_val = vimtex#pos#val(l:end_pos) + 1000
                              let l:cur_pos = l:start_pos
                            
                              "
                              " Check if selection is swapped
                              "
                              let l:end_pos[1] += 1
                              call setpos("'>", l:end_pos)
                              let l:end_pos[1] -= 1
                              normal! gv
                              let l:swapped = l:start_pos != getpos("'<")
                            
                              "
                              " First we generate a stack of all delimiters that should be toggled
                              "
                              let l:stack = []
                              while vimtex#pos#val(l:cur_pos) < l:end_pos_val
                                call vimtex#pos#set_cursor(l:cur_pos)
                                let l:open = vimtex#delim#get_next('delim_modq_math', 'open')
                                if empty(l:open) | break | endif
                            
                                if vimtex#pos#val(l:open) >= l:end_pos_val
                                  break
                                endif
                            
                                let l:close = vimtex#delim#get_matching(l:open)
                                if !empty(get(l:close, 'match'))
                            
                                  if l:end_pos_val >= vimtex#pos#val(l:close) + strlen(l:close.match) - 1
                                    let l:newmods = vimtex#delim#toggle_modifier({
                                          \ 'repeat': 0,
                                          \ 'count': l:args.count,
                                          \ 'dir': l:args.dir,
                                          \ 'openclose': [l:open, l:close],
                                          \ })
                            
                                    let l:col_diff  = (l:open.lnum == l:end_pos[1])
                                          \ ? strlen(newmods[0]) - strlen(l:open.mod) : 0
                                    let l:col_diff += (l:close.lnum == l:end_pos[1])
                                          \ ? strlen(newmods[1]) - strlen(l:close.mod) : 0
                            
                                    if l:col_diff != 0
                                      let l:end_pos[2] += l:col_diff
                                      let l:end_pos_val += l:col_diff
                                    endif
                                  endif
                                endif
                            
                                let l:cur_pos = vimtex#pos#next(l:open)
                              endwhile
                            
                              "
                              " Finally we return to original position and reselect the region
                              "
                              call setpos(l:swapped? "'>" : "'<", l:start_pos)
                              call setpos(l:swapped? "'<" : "'>", l:end_pos)
                              call vimtex#pos#set_cursor(l:save_pos)
                              if l:args.reselect
                                normal! gv
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#delim#add_modifiers() abort " {{{1
                              " Save cursor position
                              let l:cursor = vimtex#pos#get_cursor()
                            
                              " Use syntax highlights to detect region math region
                              let l:ww = &whichwrap
                              set whichwrap=h
                              while vimtex#syntax#in_mathzone()
                                normal! h
                                if vimtex#pos#get_cursor()[1:2] == [1, 1] | break | endif
                              endwhile
                              let &whichwrap = l:ww
                              let l:startval = vimtex#pos#val(vimtex#pos#get_cursor())
                            
                              let l:undostore = v:true
                              call vimtex#pos#set_cursor(l:cursor)
                            
                              while v:true
                                let [l:open, l:close] = vimtex#delim#get_surrounding('delim_modq_math')
                                if empty(l:open) || vimtex#pos#val(l:open) <= l:startval
                                  break
                                endif
                            
                                call vimtex#pos#set_cursor(vimtex#pos#prev(l:open))
                                if !empty(l:open.mod) | continue | endif
                            
                                if l:undostore
                                  let l:undostore = v:false
                                  call vimtex#pos#set_cursor(l:cursor)
                                  call vimtex#util#undostore()
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:open))
                                endif
                            
                                " Add close modifier
                                let line = getline(l:close.lnum)
                                let line = strpart(line, 0, l:close.cnum - 1)
                                      \ .  '\right' . strpart(line, l:close.cnum - 1)
                                call setline(l:close.lnum, line)
                            
                                " Add open modifier
                                let line = getline(l:open.lnum)
                                let line = strpart(line, 0, l:open.cnum - 1)
                                      \ . '\left' . strpart(line, l:open.cnum - 1)
                                call setline(l:open.lnum, line)
                            
                                " Adjust cursor position
                                let l:cursor[2] += 5
                              endwhile
                            
                              call vimtex#pos#set_cursor(l:cursor)
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#delim#change(...) abort " {{{1
                              let [l:open, l:close] = vimtex#delim#get_surrounding('delim_math')
                              if empty(l:open) | return | endif
                            
                              if a:0 > 0
                                let l:new_delim = a:1
                              else
                                let l:name = get(l:open, 'name', l:open.is_open
                                      \ ? l:open.match . ' ... ' . l:open.corr
                                      \ : l:open.match . ' ... ' . l:open.corr)
                            
                                let l:new_delim = vimtex#ui#input({
                                      \ 'info': [
                                      \   'Change surrounding delimiter: ',
                                      \   ['VimtexWarning', l:name]
                                      \ ],
                                      \ 'completion': 'customlist,vimtex#delim#change_input_complete',
                                      \})
                              endif
                            
                              if empty(l:new_delim) | return | endif
                              call vimtex#delim#change_with_args(l:open, l:close, l:new_delim)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#delim#change_with_args(open, close, new) abort " {{{1
                              "
                              " Set target environment
                              "
                              if a:new ==# ''
                                let [l:beg, l:end] = ['', '']
                              elseif index(['{', '}'], a:new) >= 0
                                let [l:beg, l:end] = ['{', '}']
                              else
                                let l:side = a:new =~# g:vimtex#delim#re.delim_math.close
                                let l:index = index(map(
                                      \   copy(g:vimtex#delim#lists.delim_math.name),
                                      \   {_, x -> x[l:side]}),
                                      \ a:new)
                                if l:index >= 0
                                  let [l:beg, l:end] = g:vimtex#delim#lists.delim_math.name[l:index]
                                else
                                  let [l:beg, l:end] = [a:new, a:new]
                                endif
                              endif
                            
                              let l:line = getline(a:open.lnum)
                              call setline(a:open.lnum,
                                    \   strpart(l:line, 0, a:open.cnum-1)
                                    \ . l:beg
                                    \ . strpart(l:line, a:open.cnum + len(a:open.match) - 1))
                            
                              let l:c1 = a:close.cnum
                              let l:c2 = a:close.cnum + len(a:close.match) - 1
                              if a:open.lnum == a:close.lnum
                                let n = len(l:beg) - len(a:open.match)
                                let l:c1 += n
                                let l:c2 += n
                                let pos = vimtex#pos#get_cursor()
                                if pos[2] > a:open.cnum + len(a:open.match) - 1
                                  let pos[2] += n
                                  call vimtex#pos#set_cursor(pos)
                                endif
                              endif
                            
                              let l:line = getline(a:close.lnum)
                              call setline(a:close.lnum,
                                    \ strpart(l:line, 0, l:c1-1) . l:end . strpart(l:line, l:c2))
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#delim#change_input_complete(lead, cmdline, pos) abort " {{{1
                              let l:all = deepcopy(g:vimtex#delim#lists.delim_all.name)
                              let l:open = map(copy(l:all), 'v:val[0]')
                              let l:close = map(copy(l:all), 'v:val[1]')
                            
                              let l:lead_re = escape(a:lead, '\$[]')
                              return filter(l:open + l:close, {_, x -> v:val =~# '^' . l:lead_re})
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#delim#delete() abort " {{{1
                              let [l:open, l:close] = vimtex#delim#get_surrounding('delim_modq_math')
                              if empty(l:open) | return | endif
                            
                              call vimtex#delim#change_with_args(l:open, l:close, '')
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#delim#get_next(type, side, ...) abort " {{{1
                              return s:get_delim(extend({
                                    \ 'direction' : 'next',
                                    \ 'type' : a:type,
                                    \ 'side' : a:side,
                                    \}, get(a:, '1', {})))
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#delim#get_prev(type, side, ...) abort " {{{1
                              return s:get_delim(extend({
                                    \ 'direction' : 'prev',
                                    \ 'type' : a:type,
                                    \ 'side' : a:side,
                                    \}, get(a:, '1', {})))
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#delim#get_current(type, side, ...) abort " {{{1
                              return s:get_delim(extend({
                                    \ 'direction' : 'current',
                                    \ 'type' : a:type,
                                    \ 'side' : a:side,
                                    \}, get(a:, '1', {})))
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#delim#get_matching(delim) abort " {{{1
                              if empty(a:delim) || !has_key(a:delim, 'lnum') | return {} | endif
                            
                              " Get the matching position
                              let l:save_pos = vimtex#pos#get_cursor()
                              call vimtex#pos#set_cursor(a:delim)
                              let [l:match, l:lnum, l:cnum] = a:delim.get_matching()
                              call vimtex#pos#set_cursor(l:save_pos)
                            
                              " Create the match result
                              let l:matching = deepcopy(a:delim)
                              let l:matching.lnum = l:lnum
                              let l:matching.cnum = l:cnum
                              let l:matching.match = l:match
                              let l:matching.corr  = a:delim.match
                              let l:matching.side = a:delim.is_open ? 'close' : 'open'
                              let l:matching.is_open = !a:delim.is_open
                              let l:matching.re.corr = a:delim.re.this
                              let l:matching.re.this = a:delim.re.corr
                            
                              if l:matching.type ==# 'delim'
                                let l:matching.corr_delim = a:delim.delim
                                let l:matching.corr_mod = a:delim.mod
                                let l:matching.delim = a:delim.corr_delim
                                let l:matching.mod = a:delim.corr_mod
                              elseif l:matching.type ==# 'env' && has_key(l:matching, 'name')
                                if l:matching.is_open
                                  let l:matching.env_cmd = vimtex#cmd#get_at(l:lnum, l:cnum)
                                else
                                  unlet l:matching.env_cmd
                                endif
                                let l:matching.name = matchstr(l:match, '{\zs\k*\ze\*\?}')
                              endif
                            
                              return l:matching
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#delim#get_surrounding(type) abort " {{{1
                              let l:save_pos = vimtex#pos#get_cursor()
                              let l:pos_val_cursor = vimtex#pos#val(l:save_pos)
                              let l:pos_val_last = l:pos_val_cursor
                              let l:pos_val_open = l:pos_val_cursor - 1
                            
                              " Avoid long iterations
                              let l:count = 0
                              let l:max_tries = get({
                                    \ 'env_tex': 100,
                                    \ 'env_math': 3,
                                    \ 'env_all': 100,
                                    \} , a:type, 100)
                            
                              while l:pos_val_open < l:pos_val_last && l:count < l:max_tries
                                let l:count += 1
                                let l:open = vimtex#delim#get_prev(a:type, 'open')
                                if empty(l:open) | break | endif
                            
                                let l:close = vimtex#delim#get_matching(l:open)
                                let l:pos_val_try = vimtex#pos#val(l:close) + strlen(l:close.match) - 1
                                if l:pos_val_try >= l:pos_val_cursor
                                  call vimtex#pos#set_cursor(l:save_pos)
                                  return [l:open, l:close]
                                else
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:open))
                                  let l:pos_val_last = l:pos_val_open
                                  let l:pos_val_open = vimtex#pos#val(l:open)
                                endif
                              endwhile
                            
                              call vimtex#pos#set_cursor(l:save_pos)
                              return [{}, {}]
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:operator_setup(operator) abort " {{{1
                              let &opfunc = s:snr() . 'operator_function'
                            
                              let s:operator = a:operator
                            
                              " Ask for user input if necessary/relevant
                              if s:operator ==# 'change'
                                let [l:open, l:close] = vimtex#delim#get_surrounding('delim_math')
                                if empty(l:open) | return | endif
                            
                                let l:name = get(l:open, 'name', l:open.is_open
                                      \ ? l:open.match . ' ... ' . l:open.corr
                                      \ : l:open.match . ' ... ' . l:open.corr)
                            
                                let s:operator_delim = vimtex#ui#input({
                                      \ 'info': [
                                      \   'Change surrounding delimiter: ',
                                      \   ['VimtexWarning', l:name]
                                      \ ],
                                      \ 'completion': 'customlist,vimtex#delim#change_input_complete',
                                      \})
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:operator_function(_) abort " {{{1
                              let l:delim = get(s:, 'operator_delim', '')
                            
                              execute 'call vimtex#delim#' . {
                                    \ 'change': 'change(l:delim)',
                                    \ 'delete': 'delete()',
                                    \ 'toggle_modifier_next': 'toggle_modifier()',
                                    \ 'toggle_modifier_prev': "toggle_modifier({'dir': -1})",
                                    \}[s:operator]
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:snr() abort " {{{1
                              return matchstr(expand('<sfile>'), '<SNR>\d\+_')
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:get_delim(opts) abort " {{{1
                              " Arguments:
                              "   opts = {
                              "     'direction'   :  next
                              "                      prev
                              "                      current
                              "     'type'        :  env_tex
                              "                      env_math
                              "                      env_all
                              "                      delim_tex
                              "                      delim_math
                              "                      delim_modq_math (possibly modified math delimiter)
                              "                      delim_mod_math  (modified math delimiter)
                              "                      delim_all
                              "                      all
                              "     'side'        :  open
                              "                      close
                              "                      both
                              "     'syn_exclude' :  Don't match in given syntax
                              "  }
                              "
                              " Returns:
                              "   delim = {
                              "     type    : env | delim
                              "     side    : open | close
                              "     name    : name of environment [only for type env]
                              "     lnum    : number
                              "     cnum    : number
                              "     match   : unparsed matched delimiter
                              "     corr    : corresponding delimiter
                              "     re : {
                              "       open  : regexp for the opening part
                              "       close : regexp for the closing part
                              "     }
                              "     remove  : method to remove the delimiter
                              "   }
                              "
                              let l:save_pos = vimtex#pos#get_cursor()
                              let l:re = g:vimtex#delim#re[a:opts.type][a:opts.side]
                              while 1
                                let [l:lnum, l:cnum] = a:opts.direction ==# 'next'
                                      \ ? searchpos(l:re, 'cnW', line('.') + g:vimtex_delim_stopline)
                                      \ : a:opts.direction ==# 'prev'
                                      \   ? searchpos(l:re, 'bcnW', max([line('.') - g:vimtex_delim_stopline, 1]))
                                      \   : searchpos(l:re, 'bcnW', line('.'))
                                if l:lnum == 0 | break | endif
                            
                                if has_key(a:opts, 'syn_exclude')
                                      \ && vimtex#syntax#in(a:opts.syn_exclude, l:lnum, l:cnum)
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:lnum, l:cnum))
                                  continue
                                endif
                            
                                break
                              endwhile
                              call vimtex#pos#set_cursor(l:save_pos)
                            
                              let l:match = matchstr(getline(l:lnum), '^' . l:re, l:cnum-1)
                            
                              if a:opts.direction ==# 'current'
                                    \ && l:cnum + strlen(l:match) + (mode() ==# 'i' ? 1 : 0) <= col('.')
                                let l:match = ''
                                let l:lnum = 0
                                let l:cnum = 0
                              endif
                            
                              for l:parser in s:parsers
                                if l:parser.detect(l:match)
                                  return l:parser.parse({
                                        \ 'lnum' : l:lnum,
                                        \ 'cnum' : l:cnum,
                                        \ 'match' : l:match,
                                        \ 'remove' : function('s:delim_remove'),
                                        \}, a:opts)
                                endif
                              endfor
                            
                              return {}
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:delim_remove() dict abort " {{{1
                              let l:line = getline(self.lnum)
                              let l:l1 = strpart(l:line, 0, self.cnum-1)
                              let l:l2 = strpart(l:line, self.cnum + strlen(self.match) - 1)
                            
                              if self.side ==# 'close'
                                let l:l1 = substitute(l:l1, '\s\+$', '', '')
                                if empty(l:l1)
                                  let l:l2 = substitute(l:l2, '^\s\+', '', '')
                                endif
                              else
                                let l:l2 = substitute(l:l2, '^\s\+', '', '')
                                if empty(l:l2)
                                  let l:l1 = substitute(l:l1, '\s\+$', '', '')
                                endif
                              endif
                            
                              call setline(self.lnum, l:l1 . l:l2)
                            endfunction
                            
                            " }}}1
                            
    1              0.000008 let s:parser_env = {
                                  \ 'type': 'env',
                                  \ 're': {
                                  \   'open' : '\m\\begin\s*{[^}]*}',
                                  \   'close' : '\m\\end\s*{[^}]*}',
                                  \ },
                                  \}
    1              0.000002 function! s:parser_env.detect(match) dict abort " {{{1
                              return a:match =~# '^\\\%(begin\|end\)\>'
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parser_env.parse(ctx, ...) dict abort " {{{1
                              let result = extend(deepcopy(self), a:ctx, 'keep')
                              unlet result.detect
                              unlet result.parse
                            
                              let result.name = matchstr(a:ctx.match, '{\zs[^}*]*\ze\*\?}')
                              let result.starred = match(a:ctx.match, '\*}$') > 0
                              let result.side = a:ctx.match =~# '\\begin' ? 'open' : 'close'
                              let result.is_open = result.side ==# 'open'
                            
                              let result.gms_flags = result.is_open ? 'nW' : 'bnW'
                              let result.gms_stopline = result.is_open
                                    \ ? line('.') + g:vimtex_delim_stopline
                                    \ : max([1, line('.') - g:vimtex_delim_stopline])
                            
                              if result.is_open
                                let result.env_cmd = vimtex#cmd#get_at(a:ctx.lnum, a:ctx.cnum)
                              endif
                            
                              let result.corr = result.is_open
                                    \ ? substitute(a:ctx.match, 'begin', 'end', '')
                                    \ : substitute(a:ctx.match, 'end', 'begin', '')
                            
                              let result.re.this = result.is_open ? result.re.open  : result.re.close
                              let result.re.corr = result.is_open ? result.re.close : result.re.open
                            
                              return result
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parser_env.get_matching() dict abort " {{{1
                              try
                                let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close,
                                      \ self.gms_flags, '', 0, s:get_timeout())
                              catch /E118/
                                let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close,
                                      \ self.gms_flags, '', self.gms_stopline)
                              endtry
                            
                              let match = matchstr(getline(lnum), '^' . self.re.corr, cnum-1)
                              return [match, lnum, cnum]
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 let s:parser_tex = {
                                  \ 'type': 'env',
                                  \}
    1              0.000002 function! s:parser_tex.detect(x) dict abort " {{{1
                              return a:x =~# '^\$\$\?' && !vimtex#syntax#in('texComment')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parser_tex.parse(ctx, opts) dict abort " {{{1
                              "
                              " TeX shorthand are these
                              "
                              "   $ ... $   (inline math)
                              "   $$ ... $$ (displayed equations)
                              "
                              " The notation does not provide the delimiter side directly, which provides
                              " a slight problem. However, we can utilize the syntax information to parse
                              " the side.
                              "
                              let result = extend(deepcopy(self), a:ctx, 'keep')
                              unlet result.detect
                              unlet result.parse
                            
                              let result.corr = a:ctx.match
                              let result.re = {
                                    \ 'this'  : '\m' . escape(a:ctx.match, '$'),
                                    \ 'corr'  : '\m' . escape(a:ctx.match, '$'),
                                    \ 'open'  : '\m' . escape(a:ctx.match, '$'),
                                    \ 'close' : '\m' . escape(a:ctx.match, '$'),
                                    \}
                              let result.side = vimtex#syntax#in(
                                    \   (a:ctx.match ==# '$' ? 'texMathZoneTI' : 'texMathZoneTD'),
                                    \   a:ctx.lnum, a:ctx.cnum+1)
                                    \ ? 'open' : 'close'
                              let result.is_open = result.side ==# 'open'
                              let result.gms_flags = result.is_open ? 'nW' : 'bnW'
                              let result.gms_stopline = result.is_open
                                    \ ? line('.') + g:vimtex_delim_stopline
                                    \ : max([1, line('.') - g:vimtex_delim_stopline])
                            
                              if (a:opts.side !=# 'both') && (a:opts.side !=# result.side)
                                "
                                " The current match ($ or $$) is not the correct side, so we must
                                " continue the search recursively. We do this by changing the cursor
                                " position, since the function searchpos relies on the current cursor
                                " position.
                                "
                                let l:save_pos = vimtex#pos#get_cursor()
                            
                                " Move the cursor
                                call vimtex#pos#set_cursor(a:opts.direction ==# 'next'
                                      \ ? vimtex#pos#next(a:ctx.lnum, a:ctx.cnum)
                                      \ : vimtex#pos#prev(a:ctx.lnum, a:ctx.cnum))
                            
                                " Get new result
                                let result = s:get_delim(a:opts)
                            
                                " Restore the cursor
                                call vimtex#pos#set_cursor(l:save_pos)
                              endif
                            
                              return result
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parser_tex.get_matching() dict abort " {{{1
                              let [lnum, cnum] = searchpos(self.re.corr, self.gms_flags, self.gms_stopline)
                            
                              let match = matchstr(getline(lnum), '^' . self.re.corr, cnum-1)
                              return [match, lnum, cnum]
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 let s:parser_latex = {
                                  \ 'type': 'env',
                                  \}
    1              0.000002 function! s:parser_latex.detect(match) dict abort " {{{1
                              return a:match =~# '^\\\%((\|)\|\[\|\]\)'
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parser_latex.parse(ctx, ...) dict abort " {{{1
                              let result = extend(deepcopy(self), a:ctx, 'keep')
                              unlet result.detect
                              unlet result.parse
                            
                              let result.side = a:ctx.match =~# '\\(\|\\\[' ? 'open' : 'close'
                              let result.is_open = result.side ==# 'open'
                              let result.gms_flags = result.is_open ? 'nW' : 'bnW'
                              let result.gms_stopline = result.is_open
                                    \ ? line('.') + g:vimtex_delim_stopline
                                    \ : max([1, line('.') - g:vimtex_delim_stopline])
                            
                              let result.corr = result.is_open
                                    \ ? substitute(substitute(a:ctx.match, '\[', ']', ''), '(', ')', '')
                                    \ : substitute(substitute(a:ctx.match, '\]', '[', ''), ')', '(', '')
                            
                              let result.re = {
                                    \ 'open'  : g:vimtex#re#not_bslash
                                    \   . (a:ctx.match =~# '\\(\|\\)' ? '\m\\(' : '\m\\\['),
                                    \ 'close' : g:vimtex#re#not_bslash
                                    \   . (a:ctx.match =~# '\\(\|\\)' ? '\m\\)' : '\m\\\]'),
                                    \}
                            
                              let result.re.this = result.is_open ? result.re.open  : result.re.close
                              let result.re.corr = result.is_open ? result.re.close : result.re.open
                            
                              return result
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parser_latex.get_matching() dict abort " {{{1
                              let [lnum, cnum] = searchpos(self.re.corr, self.gms_flags, self.gms_stopline)
                            
                              let match = matchstr(getline(lnum), '^' . self.re.corr, cnum-1)
                              return [match, lnum, cnum]
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 let s:parser_delim_unmatched = {
                                  \ 'type': 'delim',
                                  \}
    1              0.000002 function! s:parser_delim_unmatched.detect(match) dict abort " {{{1
                              return a:match =~# '^\\\%(left\|right\)\s*\.'
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parser_delim_unmatched.parse(ctx, ...) dict abort " {{{1
                              let result = extend(deepcopy(self), a:ctx, 'keep')
                              unlet result.detect
                              unlet result.parse
                            
                              let result.side =
                                    \ a:ctx.match =~# g:vimtex#delim#re.delim_all.open ? 'open' : 'close'
                              let result.is_open = result.side ==# 'open'
                              let result.gms_flags = result.is_open ? 'nW' : 'bnW'
                              let result.gms_stopline = result.is_open
                                    \ ? line('.') + g:vimtex_delim_stopline
                                    \ : max([1, line('.') - g:vimtex_delim_stopline])
                              let result.delim = '.'
                              let result.corr_delim = '.'
                            
                              " Find corresponding delimiter and the regexps
                              if result.is_open
                                let result.mod = '\left'
                                let result.corr_mod = '\right'
                                let result.corr = '\right.'
                                let re1 = '\\left\s*\.'
                                let re2 = s:get_re_for_delim('\right', 1, 'mods')
                                      \  . '\s*' . s:get_re_for_delim('.', 0)
                              else
                                let result.mod = '\right'
                                let result.corr_mod = '\left'
                                let result.corr = '\left.'
                                let re1 = '\\right\s*\.'
                                let re2 = s:get_re_for_delim('\left', 0, 'mods')
                                      \  . '\s*' . s:get_re_for_delim('.', 0)
                              endif
                            
                              let result.re = {
                                    \ 'this'  : re1,
                                    \ 'corr'  : re2,
                                    \ 'open'  : result.is_open ? re1 : re2,
                                    \ 'close' : result.is_open ? re2 : re1,
                                    \}
                            
                              return result
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parser_delim_unmatched.get_matching() dict abort " {{{1
                              let tries = 0
                              let misses = []
                              while 1
                                try
                                  let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close,
                                        \ self.gms_flags,
                                        \ 'index(misses, [line("."), col(".")]) >= 0',
                                        \ 0, s:get_timeout())
                                catch /E118/
                                  let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close,
                                        \ self.gms_flags,
                                        \ 'index(misses, [line("."), col(".")]) >= 0',
                                        \ self.gms_stopline)
                                endtry
                                let match = matchstr(getline(lnum), '^' . self.re.corr, cnum-1)
                                if lnum == 0 | break | endif
                            
                                let cand = vimtex#delim#get_matching(s:parser_delim.parse({
                                      \ 'lnum' : lnum,
                                      \ 'cnum' : cnum,
                                      \ 'match' : match,
                                      \}))
                            
                                if !empty(cand) && [self.lnum, self.cnum] == [cand.lnum, cand.cnum]
                                  return [match, lnum, cnum]
                                else
                                  let misses += [[lnum, cnum]]
                                  let tries += 1
                                  if tries == 10 | break | endif
                                endif
                              endwhile
                            
                              return ['', 0, 0]
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 let s:parser_delim = {
                                  \ 'type': 'delim',
                                  \}
    1              0.000002 function! s:parser_delim.detect(match) dict abort " {{{1
                              return a:match =~# '^' . g:vimtex#delim#re.delim_all.both
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parser_delim.parse(ctx, ...) dict abort " {{{1
                              let result = extend(deepcopy(self), a:ctx, 'keep')
                              unlet result.detect
                              unlet result.parse
                            
                              let result.side =
                                    \ a:ctx.match =~# g:vimtex#delim#re.delim_all.open ? 'open' : 'close'
                              let result.is_open = result.side ==# 'open'
                              let result.gms_flags = result.is_open ? 'nW' : 'bnW'
                              let result.gms_stopline = result.is_open
                                    \ ? line('.') + g:vimtex_delim_stopline
                                    \ : max([1, line('.') - g:vimtex_delim_stopline])
                            
                              " Find corresponding delimiter and the regexps
                              if a:ctx.match =~# '^' . g:vimtex#delim#re.mods.both
                                let m1 = matchstr(a:ctx.match, '^' . g:vimtex#delim#re.mods.both)
                                let d1 = substitute(strpart(a:ctx.match, len(m1)), '^\s*', '', '')
                                let s1 = !result.is_open
                                let re1 = s:get_re_for_delim(m1, s1, 'mods')
                                      \  . '\s*' . s:get_re_for_delim(d1, s1, 'delim_math')
                            
                                let m2 = s:get_corr_delimiter(m1, 'mods')
                                let d2 = s:get_corr_delimiter(d1, 'delim_math')
                                let s2 = result.is_open
                                let re2 = s:get_re_for_delim(m2, s2, 'mods') . '\s*'
                                      \ . (m1 =~# '\\\%(left\|right\)'
                                      \   ? '\%(' . s:get_re_for_delim(d2, s2, 'delim_math') . '\|\.\)'
                                      \   : s:get_re_for_delim(d2, s2, 'delim_math'))
                              else
                                let d1 = a:ctx.match
                                let m1 = ''
                                let re1 = s:get_re_for_delim(a:ctx.match, !result.is_open)
                            
                                let d2 = s:get_corr_delimiter(a:ctx.match)
                                let m2 = ''
                                let re2 = s:get_re_for_delim(d2, result.is_open)
                              endif
                            
                              let result.delim = d1
                              let result.mod = m1
                              let result.corr = m2 . d2
                              let result.corr_delim = d2
                              let result.corr_mod = m2
                              let result.re = {
                                    \ 'this'  : re1,
                                    \ 'corr'  : re2,
                                    \ 'open'  : result.is_open ? re1 : re2,
                                    \ 'close' : result.is_open ? re2 : re1,
                                    \}
                            
                              return result
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:parser_delim.get_matching() dict abort " {{{1
                              try
                                let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close,
                                      \ self.gms_flags,
                                      \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "comment"',
                                      \ 0, s:get_timeout())
                              catch /E118/
                                let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close,
                                      \ self.gms_flags,
                                      \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "comment"',
                                      \ self.gms_stopline)
                              endtry
                            
                              let match = matchstr(getline(lnum), '^' . self.re.corr, cnum-1)
                              return [match, lnum, cnum]
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:get_timeout() abort " {{{1
                              return (empty(v:insertmode) ? mode() : v:insertmode) ==# 'i'
                                    \ ? g:vimtex_delim_insert_timeout
                                    \ : g:vimtex_delim_timeout
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_re_for_delim(delim, side, ...) abort " {{{1
                              let l:type = a:0 > 0 ? a:1 : 'delim_all'
                            
                              " First check for unmatched math delimiter
                              if a:delim ==# '.'
                                return g:vimtex#delim#re.delim_math[a:side ? 'open' : 'close']
                              endif
                            
                              " Next check normal delimiters
                              let l:index = index(map(
                                    \   copy(g:vimtex#delim#lists[l:type].name),
                                    \   {_, x -> x[a:side]}),
                                    \ a:delim)
                              return l:index >= 0
                                    \ ? g:vimtex#delim#lists[l:type].re[l:index][a:side]
                                    \ : ''
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_corr_delimiter(delim, ...) abort " {{{1
                              let l:type = a:0 > 0 ? a:1 : 'delim_all'
                            
                              for l:pair in g:vimtex#delim#lists[l:type].name
                                if a:delim ==# l:pair[0]
                                  return l:pair[1]
                                elseif a:delim ==# l:pair[1]
                                  return l:pair[0]
                                endif
                              endfor
                            endfunction
                            
                            " }}}1
                            
                            " Initialize list of delim type parsers
    1              0.000006 let s:parsers = [
                                  \ s:parser_env,
                                  \ s:parser_tex,
                                  \ s:parser_latex,
                                  \ s:parser_delim_unmatched,
                                  \ s:parser_delim,
                                  \]
                            
                            
    1              0.000002 function! s:init_delim_lists() abort " {{{1
                              " Define the default value
                              let l:lists = {
                                    \ 'env_tex' : {
                                    \   'name' : [['begin', 'end']],
                                    \   're' : [['\\begin\s*{[^}]*}', '\\end\s*{[^}]*}']],
                                    \ },
                                    \ 'env_math' : {
                                    \   'name' : [
                                    \     ['\(', '\)'],
                                    \     ['\[', '\]'],
                                    \     ['$$', '$$'],
                                    \     ['$', '$'],
                                    \   ],
                                    \   're' : [
                                    \     ['\\(', '\\)'],
                                    \     ['\\\@<!\\\[', '\\\]'],
                                    \     ['\$\$', '\$\$'],
                                    \     ['\$', '\$'],
                                    \   ],
                                    \ },
                                    \ 'delim_tex' : {
                                    \   'name' : [
                                    \     ['[', ']'],
                                    \     ['{', '}'],
                                    \   ],
                                    \   're' : [
                                    \     ['\[', '\]'],
                                    \     ['\\\@<!{', '\\\@<!}'],
                                    \   ]
                                    \ },
                                    \ 'delim_math' : {
                                    \   'name' : [
                                    \     ['(', ')'],
                                    \     ['[', ']'],
                                    \     ['\{', '\}'],
                                    \     ['\langle', '\rangle'],
                                    \     ['\lbrace', '\rbrace'],
                                    \     ['\lvert', '\rvert'],
                                    \     ['\lVert', '\rVert'],
                                    \     ['\lfloor', '\rfloor'],
                                    \     ['\lceil', '\rceil'],
                                    \     ['\ulcorner', '\urcorner'],
                                    \   ]
                                    \ },
                                    \ 'mods' : {
                                    \   'name' : [
                                    \     ['\left', '\right'],
                                    \     ['\bigl', '\bigr'],
                                    \     ['\Bigl', '\Bigr'],
                                    \     ['\biggl', '\biggr'],
                                    \     ['\Biggl', '\Biggr'],
                                    \     ['\big', '\big'],
                                    \     ['\Big', '\Big'],
                                    \     ['\bigg', '\bigg'],
                                    \     ['\Bigg', '\Bigg'],
                                    \   ],
                                    \   're' : [
                                    \     ['\\left', '\\right'],
                                    \     ['\\bigl', '\\bigr'],
                                    \     ['\\Bigl', '\\Bigr'],
                                    \     ['\\biggl', '\\biggr'],
                                    \     ['\\Biggl', '\\Biggr'],
                                    \     ['\\big\>', '\\big\>'],
                                    \     ['\\Big\>', '\\Big\>'],
                                    \     ['\\bigg\>', '\\bigg\>'],
                                    \     ['\\Bigg\>', '\\Bigg\>'],
                                    \   ]
                                    \ },
                                    \}
                            
                              " Get user defined lists
                              call extend(l:lists, get(g:, 'vimtex_delim_list', {}))
                            
                              " Generate corresponding regexes if necessary
                              for l:type in values(l:lists)
                                if !has_key(l:type, 're') && has_key(l:type, 'name')
                                  let l:type.re = map(deepcopy(l:type.name),
                                        \ {i1, x -> map(x, {i2, y -> escape(y, '\$[]')})})
                                endif
                              endfor
                            
                              " Generate combined lists
                              let l:lists.env_all = {}
                              let l:lists.delim_all = {}
                              let l:lists.all = {}
                              for k in ['name', 're']
                                let l:lists.env_all[k] = l:lists.env_tex[k] + l:lists.env_math[k]
                                let l:lists.delim_all[k] = l:lists.delim_math[k] + l:lists.delim_tex[k]
                                let l:lists.all[k] = l:lists.env_all[k] + l:lists.delim_all[k]
                              endfor
                            
                              return l:lists
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:init_delim_regexes() abort " {{{1
                              let l:re = {}
                              let l:re.env_all = {}
                              let l:re.delim_all = {}
                              let l:re.all = {}
                            
                              let l:re.env_tex = s:init_delim_regexes_generator('env_tex')
                              let l:re.env_math = s:init_delim_regexes_generator('env_math')
                              let l:re.delim_tex = s:init_delim_regexes_generator('delim_tex')
                              let l:re.delim_math = s:init_delim_regexes_generator('delim_math')
                              let l:re.mods = s:init_delim_regexes_generator('mods')
                            
                              let l:o = join(map(copy(g:vimtex#delim#lists.delim_math.re), 'v:val[0]'), '\|')
                              let l:c = join(map(copy(g:vimtex#delim#lists.delim_math.re), 'v:val[1]'), '\|')
                            
                              "
                              " Matches modified math delimiters
                              "
                              let l:re.delim_mod_math = {
                                    \ 'open' : '\%(\%(' . l:re.mods.open . '\)\)\s*\\\@<!\%('
                                    \   . l:o . '\)\|\\left\s*\.',
                                    \ 'close' : '\%(\%(' . l:re.mods.close . '\)\)\s*\\\@<!\%('
                                    \   . l:c . '\)\|\\right\s*\.',
                                    \ 'both' : '\%(\%(' . l:re.mods.both . '\)\)\s*\\\@<!\%('
                                    \   . l:o . '\|' . l:c . '\)\|\\\%(left\|right\)\s*\.',
                                    \}
                            
                              "
                              " Matches possibly modified math delimiters
                              "
                              let l:re.delim_modq_math = {
                                    \ 'open' : '\%(\%(' . l:re.mods.open . '\)\s*\)\?\\\@<!\%('
                                    \   . l:o . '\)\|\\left\s*\.',
                                    \ 'close' : '\%(\%(' . l:re.mods.close . '\)\s*\)\?\\\@<!\%('
                                    \   . l:c . '\)\|\\right\s*\.',
                                    \ 'both' : '\%(\%(' . l:re.mods.both . '\)\s*\)\?\\\@<!\%('
                                    \   . l:o . '\|' . l:c . '\)\|\\\%(left\|right\)\s*\.',
                                    \}
                            
                              for k in ['open', 'close', 'both']
                                let l:re.env_all[k] = l:re.env_tex[k] . '\|' . l:re.env_math[k]
                                let l:re.delim_all[k] = l:re.delim_modq_math[k] . '\|' . l:re.delim_tex[k]
                                let l:re.all[k] = l:re.env_all[k] . '\|' . l:re.delim_all[k]
                              endfor
                            
                              "
                              " Be explicit about regex mode (set magic mode)
                              "
                              for l:type in values(l:re)
                                for l:side in ['open', 'close', 'both']
                                  let l:type[l:side] = '\m' . l:type[l:side]
                                endfor
                              endfor
                            
                              return l:re
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:init_delim_regexes_generator(list_name) abort " {{{1
                              let l:list = g:vimtex#delim#lists[a:list_name]
                              let l:open = join(map(copy(l:list.re), 'v:val[0]'), '\|')
                              let l:close = join(map(copy(l:list.re), 'v:val[1]'), '\|')
                            
                              return {
                                    \ 'open' : '\\\@<!\%(' . l:open . '\)',
                                    \ 'close' : '\\\@<!\%(' . l:close . '\)',
                                    \ 'both' : '\\\@<!\%(' . l:open . '\|' . l:close . '\)'
                                    \}
                            endfunction
                            
                              " }}}1
                            
                            " Initialize lists of delimiter pairs and regexes
    1   0.000462   0.000007 let g:vimtex#delim#lists = s:init_delim_lists()
    1   0.000514   0.000008 let g:vimtex#delim#re = s:init_delim_regexes()

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/doc.vim
Sourced 1 time
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#doc#init_buffer() abort " {{{1
                              command! -buffer -nargs=? VimtexDocPackage call vimtex#doc#package(<q-args>)
                            
                              nnoremap <buffer> <plug>(vimtex-doc-package) :VimtexDocPackage<cr>
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#doc#get_context(...) abort " {{{1
                              let l:word = a:0 > 0 ? a:1 : ''
                              let l:context = empty(l:word)
                                    \ ? s:packages_get_from_cursor()
                                    \ : {
                                    \     'type': 'word',
                                    \     'candidates': [l:word],
                                    \   }
                              if empty(l:context) | return {} | endif
                            
                              call s:packages_remove_invalid(l:context)
                            
                              return l:context
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#doc#package(word) abort " {{{1
                              let l:context = vimtex#doc#get_context(a:word)
                              if empty(l:context) | return | endif
                            
                              for l:handler in g:vimtex_doc_handlers
                                try
                                  if call(l:handler, [l:context]) | return | endif
                                catch /E117/
                                endtry
                              endfor
                            
                              call s:packages_open(l:context)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#doc#make_selection(context) abort " {{{1
                              if has_key(a:context, 'selected') | return | endif
                            
                              if len(a:context.candidates) == 0
                                if exists('a:context.name')
                                  echohl ErrorMsg
                                  echo 'Sorry, no doc for ' . a:context.name
                                  echohl NONE
                                endif
                                let a:context.selected = ''
                                return
                              endif
                            
                              if len(a:context.candidates) == 1
                                if !g:vimtex_doc_confirm_single || vimtex#ui#confirm([
                                      \ 'Open documentation for ' . a:context.type . ': ',
                                      \ ['VimtexSuccess', a:context.candidates[0]],
                                      \ '?'
                                      \])
                                  let a:context.selected = a:context.candidates[0]
                                else
                                  let a:context.selected = ''
                                endif
                            
                                return
                              endif
                            
                              let a:context.selected = vimtex#ui#select(a:context.candidates, {
                                    \ 'prompt': 'Multiple candidates detected, please select one:',
                                    \})
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:packages_get_from_cursor() abort " {{{1
                              let l:cmd = vimtex#cmd#get_current()
                              if empty(l:cmd) | return {} | endif
                            
                              if l:cmd.name ==# '\usepackage' || l:cmd.name ==# '\RequirePackage'
                                return s:packages_from_usepackage(l:cmd)
                              elseif l:cmd.name ==# '\documentclass'
                                return s:packages_from_documentclass(l:cmd)
                              elseif l:cmd.name =~# '\v\\%(begin|end)$'
                                return s:packages_from_environment(l:cmd)
                              elseif l:cmd.name ==# '\usetikzlibrary'
                                return s:packages_from_usetikzlibrary(l:cmd)
                              else
                                return s:packages_from_command(strpart(l:cmd.name, 1))
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:packages_from_usepackage(cmd) abort " {{{1
                              try
                                " Gather and clean up candidate list
                                let l:candidates = substitute(a:cmd.args[0].text, '%.\{-}\n', '', 'g')
                                let l:candidates = substitute(l:candidates, '\s*', '', 'g')
                                let l:candidates = split(l:candidates, ',')
                            
                                let l:context = {
                                      \ 'type': 'usepackage',
                                      \ 'candidates': l:candidates,
                                      \}
                            
                                let l:cword = expand('<cword>')
                                if len(l:context.candidates) > 1
                                      \ && index(l:context.candidates, l:cword) >= 0
                                  let l:context.selected = l:cword
                                endif
                            
                                return l:context
                              catch
                                call vimtex#log#warning('Could not parse the package from \usepackage!')
                                return {}
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:packages_from_documentclass(cmd) abort " {{{1
                              try
                                return {
                                      \ 'type': 'documentclass',
                                      \ 'candidates': [a:cmd.args[0].text],
                                      \}
                              catch
                                call vimtex#log#warning('Could not parse the package from \documentclass!')
                                return {}
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:packages_from_environment(cmd) abort " {{{1
                              try
                                let l:env = a:cmd.args[0].text
                              catch
                                call vimtex#log#warning('Could not parse the environment name!')
                                return {}
                              endtry
                            
                              return s:packages_from_command('\begin{' . l:env . '}')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:packages_from_command(cmd) abort " {{{1
                              let l:packages = [
                                    \ 'default',
                                    \ 'class-' . get(b:vimtex, 'documentclass', ''),
                                    \] + keys(b:vimtex.packages)
                              call filter(l:packages, 'filereadable(s:complete_dir . v:val)')
                            
                              let l:queue = copy(l:packages)
                              while !empty(l:queue)
                                let l:current = remove(l:queue, 0)
                                let l:includes = filter(readfile(s:complete_dir . l:current),
                                      \ 'v:val =~# ''^\#\s*include:''')
                                if empty(l:includes) | continue | endif
                            
                                call map(l:includes, {_, x -> matchstr(x, 'include:\s*\zs.*\ze\s*$')})
                                call filter(l:includes, 'filereadable(s:complete_dir . v:val)')
                                call filter(l:includes, 'index(l:packages, v:val) < 0')
                            
                                let l:packages += l:includes
                                let l:queue += l:includes
                              endwhile
                            
                              let l:candidates = []
                              for l:package in l:packages
                                let l:cmds = filter(
                                      \ readfile(s:complete_dir . l:package),
                                      \ {_, x -> x ==# a:cmd})
                                if empty(l:cmds) | continue | endif
                            
                                if l:package ==# 'default'
                                  call extend(l:candidates, ['latex2e', 'lshort'])
                                else
                                  call add(l:candidates, substitute(l:package, '^class-', '', ''))
                                endif
                              endfor
                            
                              return {
                                    \ 'type': 'command',
                                    \ 'name': a:cmd,
                                    \ 'candidates': l:candidates,
                                    \}
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:packages_from_usetikzlibrary(cmd) abort " {{{1
                              try
                                " Gather and filter candidates
                                let l:candidates = a:cmd.args[0].text
                                let l:candidates = substitute(l:candidates, '\s*', '', 'g')
                                let l:candidates = split(l:candidates, ',')
                                let l:candidates_paths = map(l:candidates, { _, x -> [x,
                                      \ vimtex#kpsewhich#find('tikzlibrary' . x . '.code.tex')]})
                                let l:candidates = filter(l:candidates_paths,
                                      \ { _, x -> !empty(x[1]) && x[1] !~# 'pgf.*tikz.libraries' })
                                let l:candidates = map(l:candidates, { _, x -> x[0] })
                            
                                " Include tikz package itself
                                call insert(l:candidates, 'tikz', 0)
                            
                                let l:context = {
                                      \ 'type': 'tikzlibrary',
                                      \ 'candidates': l:candidates,
                                      \}
                            
                                " Check selected
                                let l:cword = expand('<cword>')
                                if len(l:context.candidates) > 1
                                      \ && index(l:context.candidates, l:cword) >= 0
                                  let l:context.selected = l:cword
                                endif
                            
                                return l:context
                              catch /'testting/
                                call vimtex#log#warning('Could not parse the package from \usetikzlibrary!')
                                return {}
                              endtry
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:packages_remove_invalid(context) abort " {{{1
                              if a:context.type !=# 'tikzlibrary'
                                let l:invalid_packages = filter(copy(a:context.candidates), {_, x ->
                                      \    empty(vimtex#kpsewhich#find(x . '.sty'))
                                      \ && empty(vimtex#kpsewhich#find(x . '.cls'))})
                              else
                                let l:invalid_packages = []
                              endif
                            
                              call filter(l:invalid_packages, "index(['latex2e', 'lshort'], v:val) < 0")
                            
                              " Warn about invalid candidates
                              if !empty(l:invalid_packages)
                                if len(l:invalid_packages) == 1
                                  call vimtex#log#warning(
                                        \ 'Package not recognized: ' . l:invalid_packages[0])
                                else
                                  call vimtex#log#warning(
                                        \ 'Packages not recognized:',
                                        \ map(copy(l:invalid_packages), "'- ' . v:val"))
                                endif
                              endif
                            
                              " Remove invalid candidates
                              call filter(a:context.candidates, 'index(l:invalid_packages, v:val) < 0')
                            
                              " Reset the selection if the selected candidate is not valid
                              if has_key(a:context, 'selected')
                                    \ && index(a:context.candidates, a:context.selected) < 0
                                unlet a:context.selected
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:packages_open(context) abort " {{{1
                              call vimtex#doc#make_selection(a:context)
                              if empty(a:context.selected) | return 0 | endif
                            
                              call vimtex#util#www('http://texdoc.net/pkg/' . a:context.selected)
                              redraw!
                            endfunction
                            
                            " }}}1
                            
    1              0.000006 let s:complete_dir = expand('<sfile>:h') . '/complete/'

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/env.vim
Sourced 1 time
Total time:   0.000256
 Self time:   0.000256

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#env#init_buffer() abort " {{{1
                              nnoremap <silent><buffer> <plug>(vimtex-env-change)
                                    \ :<c-u>call <sid>operator_setup('change', 'normal')<bar>normal! g@l<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-env-change-math)
                                    \ :<c-u>call <sid>operator_setup('change', 'math')<bar>normal! g@l<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-env-delete)
                                    \ :<c-u>call <sid>operator_setup('delete', 'normal')<bar>normal! g@l<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-env-delete-math)
                                    \ :<c-u>call <sid>operator_setup('delete', 'math')<bar>normal! g@l<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-env-toggle-star)
                                    \ :<c-u>call <sid>operator_setup('toggle_star', '')<bar>normal! g@l<cr>
                            
                              nnoremap <silent><buffer> <plug>(vimtex-env-toggle-math)
                                    \ :<c-u>call <sid>operator_setup('toggle_math', '')<bar>normal! g@l<cr>
                            
                              nnoremap <silent><buffer><expr> <plug>(vimtex-env-surround-operator)
                                    \ vimtex#env#surround_opfunc('operator')
                              nmap     <silent><buffer>       <plug>(vimtex-env-surround-line)
                                    \ <plug>(vimtex-env-surround-operator)_
                              xnoremap <silent><buffer>       <plug>(vimtex-env-surround-visual)
                                    \ :<c-u>call vimtex#env#surround_opfunc('visual')<cr>
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#env#get_surrounding(type) abort " {{{1
                              " Get surrounding environment delimiters.
                              "
                              " This works similar to vimtex#delim#get_surrounding, except specialized for
                              " environments. For normal environments it is equivalent to
                              " vimtex#delim#get_surrounding('env_tex'). For math environments it combines
                              " the 'env_math' delimiter type with normal known math environments.
                            
                              if a:type ==# 'normal'
                                return vimtex#delim#get_surrounding('env_tex')
                              endif
                            
                              if a:type !=# 'math'
                                call vimtex#log#error('Wrong argument!')
                                return [{}, {}]
                              endif
                            
                              " First check for special math env delimiters
                              let [l:open, l:close] = vimtex#delim#get_surrounding('env_math')
                              if !empty(l:open) | return [l:open, l:close] | endif
                            
                              " Next check for standard math environments (only works for 1 level depth)
                              let [l:open, l:close] = vimtex#delim#get_surrounding('env_tex')
                              if !empty(l:open) &&
                                    \ index(s:math_envs, substitute(l:open.name, '\*$', '', '')) >= 0
                                return [l:open, l:close]
                              endif
                            
                              return [{}, {}]
                            endfunction
                            
    1              0.000009 let s:math_envs = [
                                  \ 'align',
                                  \ 'alignat',
                                  \ 'displaymath',
                                  \ 'eqnarray',
                                  \ 'equation',
                                  \ 'flalign',
                                  \ 'gather',
                                  \ 'math',
                                  \ 'mathpar',
                                  \ 'multline',
                                  \ 'xalignat',
                                  \ 'xxalignat',
                                  \]
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#env#get_inner() abort " {{{1
                              let [l:open, l:close] = vimtex#env#get_surrounding('normal')
                            
                              return empty(l:open) || l:open.name ==# 'document'
                                    \ ? {}
                                    \ : {'name': l:open.name, 'open': l:open, 'close': l:close}
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#env#get_outer() abort " {{{1
                              let l:save_pos = vimtex#pos#get_cursor()
                              let l:current = {}
                            
                              while v:true
                                let l:env = vimtex#env#get_inner()
                                if empty(l:env)
                                  call vimtex#pos#set_cursor(l:save_pos)
                                  return l:current
                                endif
                            
                                let l:current = l:env
                                call vimtex#pos#set_cursor(vimtex#pos#prev(l:env.open))
                              endwhile
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#env#get_all() abort " {{{1
                              let l:save_pos = vimtex#pos#get_cursor()
                              let l:stack = []
                            
                              while v:true
                                let l:env = vimtex#env#get_inner()
                                if empty(l:env)
                                  call vimtex#pos#set_cursor(l:save_pos)
                                  return l:stack
                                endif
                            
                                call add(l:stack, l:env)
                                call vimtex#pos#set_cursor(vimtex#pos#prev(l:env.open))
                              endwhile
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#env#change_surrounding(type, new) abort " {{{1
                              let [l:open, l:close] = vimtex#env#get_surrounding(a:type)
                              if empty(l:open) | return | endif
                            
                              return vimtex#env#change(l:open, l:close, a:new)
                            endfunction
                            
    1              0.000002 function! vimtex#env#change(open, close, new) abort " {{{1
                              let l:new = get({
                                    \ '$': ['$', '$'],
                                    \ '\(': ['\\(', '\\)'],
                                    \ '$$': ['$$', '$$'],
                                    \ '\[': ['\[', '\]'],
                                    \}, a:new, ['\begin{' . a:new . '}', '\end{' . a:new . '}'])
                            
                              if index(['$', '\('], a:new) >= 0
                                return vimtex#env#change_to_inline_math(a:open, a:close, l:new)
                              endif
                            
                              return index(['$', '\('], a:open.match) >= 0
                                    \ ? vimtex#env#change_to_indented(a:open, a:close, l:new)
                                    \ : vimtex#env#change_in_place(a:open, a:close, l:new)
                            endfunction
                            
    1              0.000002 function! vimtex#env#change_to_inline_math(open, close, new) abort " {{{1
                              let [l:before, l:after] = s:get_line_split(a:close)
                              if l:before . l:after =~# '^\s*$'
                                let l:line = substitute(getline(a:close.lnum - 1), '\s*$', a:new[1], '')
                                call setline(a:close.lnum - 1, l:line)
                                execute a:close.lnum . 'delete _'
                                if !empty(vimtex#util#trim(getline(a:close.lnum)))
                                  execute (a:close.lnum - 1) . 'join'
                                endif
                              elseif l:before =~# '^\s*$'
                                let l:line = substitute(getline(a:close.lnum - 1), '\s*$', a:new[1], '')
                                let l:line .= substitute(l:after, '^\s*', ' ', '')
                                call setline(a:close.lnum - 1, l:line)
                                execute a:close.lnum . 'delete _'
                              else
                                let l:line = substitute(l:before, '\s*$', a:new[1], '') . l:after
                                call setline(a:close.lnum, l:line)
                              endif
                            
                              let [l:before, l:after] = s:get_line_split(a:open)
                              if l:before . l:after =~# '^\s*$'
                                execute a:open.lnum . 'delete _'
                                let l:after = substitute(getline(a:open.lnum), '^\s*', a:new[0], '')
                                let l:prev_line = getline(a:open.lnum - 1)
                                if l:prev_line =~# '^\s*$'
                                  call setline(a:open.lnum, matchstr(l:before, '^\s*') . l:after)
                                  call vimtex#pos#set_cursor([a:open.lnum, a:open.cnum])
                                else
                                  let l:before = substitute(l:prev_line, '\s*$', ' ', '')
                                  call setline(a:open.lnum - 1, l:before . l:after)
                                  execute a:open.lnum . 'delete _'
                                  call vimtex#pos#set_cursor([a:open.lnum - 1, strlen(l:before)+1])
                                endif
                              elseif l:after =~# '^\s*$'
                                let l:line = l:before
                                let l:line .= substitute(getline(a:open.lnum + 1), '^\s*', a:new[0], '')
                                call setline(a:open.lnum, l:line)
                                execute (a:open.lnum + 1) . 'delete _'
                                call vimtex#pos#set_cursor([a:open.lnum, a:open.cnum])
                              else
                                let l:line = l:before
                                let l:line .= substitute(l:after, '^\s*', a:new[0], '')
                                call setline(a:open.lnum, l:line)
                                call vimtex#pos#set_cursor([a:open.lnum, a:open.cnum])
                              endif
                            endfunction
                            
    1              0.000002 function! vimtex#env#change_to_indented(open, close, new) abort " {{{1
                              let l:cursor = vimtex#pos#get_cursor()
                              let l:nlines = a:close.lnum - a:open.lnum - 1 + 3
                            
                              " Adjust cursor column position (1)
                              if l:cursor[1] == a:open.lnum
                                let l:cursor[2] -= a:open.cnum - indent(a:open.lnum) - &shiftwidth
                              else
                                " Must be adjusted after indents are applied
                                let l:cur_indent = indent(l:cursor[1])
                              endif
                            
                              let [l:before, l:after] = s:get_line_split(a:close)
                              let l:before = substitute(l:before, '\s*$', '', '')
                              let l:after = substitute(l:after, '^\s*', '', '')
                              if !empty(l:before)
                                call setline(a:close.lnum, l:before)
                                call append(a:close.lnum, a:new[1])
                              else
                                call setline(a:close.lnum, a:new[1])
                              endif
                              if !empty(l:after)
                                call append(a:close.lnum + !empty(l:before), l:after)
                                let l:nlines += 1
                              endif
                            
                              let [l:before, l:after] = s:get_line_split(a:open)
                              let l:before = substitute(l:before, '\s*$', '', '')
                              let l:after = substitute(l:after, '^\s*', '', '')
                              if !empty(l:before)
                                call setline(a:open.lnum, l:before)
                                call append(a:open.lnum, a:new[0])
                                call vimtex#pos#set_cursor(a:open.lnum+1, 1)
                                let l:cursor[1] += 1
                              else
                                call setline(a:open.lnum, a:new[0])
                                call vimtex#pos#set_cursor(a:open.lnum, 1)
                              endif
                              if !empty(l:after)
                                call append(a:open.lnum + !empty(l:before), l:after)
                                let l:cursor[1] += 1
                              endif
                            
                              " Indent the lines
                              silent execute printf('normal! =%dj', l:nlines)
                            
                              " Adjust cursor column position (2)
                              if exists('l:cur_indent')
                                let l:cursor[2] -= l:cur_indent - indent(l:cursor[1])
                              endif
                            
                              call vimtex#pos#set_cursor(l:cursor)
                            endfunction
                            
                            " }}}1
    1              0.000003 function! vimtex#env#change_in_place(open, close, new) abort " {{{1
                              let [l:before, l:after] = s:get_line_split(a:close)
                              call setline(a:close.lnum, l:before . a:new[1] . l:after)
                            
                              let [l:before, l:after] = s:get_line_split(a:open)
                              call setline(a:open.lnum, l:before . a:new[0] . l:after)
                            
                              if a:open.lnum == a:close.lnum
                                let l:pos = vimtex#pos#get_cursor()
                                if l:pos[2] > a:open.cnum + len(a:open.match) - 1
                                  let l:pos[2] += len(a:new[0]) - len(a:open.match)
                                  call vimtex#pos#set_cursor(l:pos)
                                endif
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#env#surround(l1, l2, name) abort " {{{1
                              if a:l1 < 1 || a:l2 < a:l1 || empty(a:name)
                                return
                              endif
                            
                              let l:pos = vimtex#pos#get_cursor()
                              let l:pos[1] += l:pos[1] > a:l2
                              let l:pos[1] += l:pos[1] >= a:l1
                            
                              call append(a:l2, printf('\end{%s}', a:name))
                              call append(a:l1-1, printf('\begin{%s}', a:name))
                            
                              silent execute printf("normal! %dG%d==", a:l1, a:l2 - a:l1 + 3)
                            
                              call vimtex#pos#set_cursor(l:pos)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#env#surround_opfunc(type) abort " {{{1
                              if a:type ==# 'operator'
                                set opfunc=vimtex#env#surround_opfunc
                                return 'g@'
                              elseif a:type ==# 'visual'
                                let l:lnum1 = getpos("'<")[1]
                                let l:lnum2 = getpos("'>")[1]
                              else
                                let l:lnum1 = getpos("'[")[1]
                                let l:lnum2 = getpos("']")[1]
                              endif
                            
                              let l:name = vimtex#ui#input({
                                    \ 'prompt': 'Surround with environment: ',
                                    \})
                            
                              call vimtex#env#surround(l:lnum1, l:lnum2, l:name)
                              normal! zv
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#env#delete(type) abort " {{{1
                              let [l:open, l:close] = vimtex#env#get_surrounding(a:type)
                              if empty(l:open) | return | endif
                            
                              if a:type ==# 'normal'
                                call vimtex#cmd#delete_all(l:close)
                                call vimtex#cmd#delete_all(l:open)
                              else
                                call l:close.remove()
                                call l:open.remove()
                              endif
                            
                              if getline(l:close.lnum) =~# '^\s*$'
                                execute l:close.lnum . 'd _'
                              endif
                            
                              if getline(l:open.lnum) =~# '^\s*$'
                                execute l:open.lnum . 'd _'
                              endif
                            endfunction
                            
    1              0.000001 function! vimtex#env#toggle_star() abort " {{{1
                              let [l:open, l:close] = vimtex#env#get_surrounding('normal')
                              if empty(l:open)
                                    \ || l:open.name ==# 'document' | return | endif
                            
                              call vimtex#env#change(l:open, l:close,
                                    \ l:open.starred ? l:open.name : l:open.name . '*')
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#env#toggle_math() abort " {{{1
                              let [l:open, l:close] = vimtex#env#get_surrounding('math')
                              if empty(l:open) | return | endif
                            
                              let l:current = get(l:open, 'name', l:open.match)
                              let l:target = get(g:vimtex_env_toggle_math_map, l:current, '$')
                            
                              call vimtex#env#change(l:open, l:close, l:target)
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#env#is_inside(env) abort " {{{1
                              let l:re_start = '\\begin\s*{' . a:env . '\*\?}'
                              let l:re_end = '\\end\s*{' . a:env . '\*\?}'
                              try
                                return searchpairpos(l:re_start, '', l:re_end, 'bnW', '', 0, 100)
                              catch /E118/
                                let l:stopline = max([line('.') - 500, 1])
                                return searchpairpos(l:re_start, '', l:re_end, 'bnW', '', l:stopline)
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#env#input_complete(lead, cmdline, pos) abort " {{{1
                              let l:cands = map(vimtex#complete#complete('env', '', '\begin'), 'v:val.word')
                            
                              " Never include document and remove current env (place it first)
                              call filter(l:cands, { _, x -> index(['document', s:env_name], v:val) < 0 })
                            
                              " Always include current env and displaymath
                              let l:cands = [s:env_name] + l:cands + ['\[']
                            
                              return filter(l:cands, {_, x -> x =~# '^' . a:lead})
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:get_line_split(delim) abort " {{{1
                              let l:line = getline(a:delim.lnum)
                            
                              let l:before = strpart(l:line, 0, a:delim.cnum - 1)
                              let l:after = strpart(l:line, a:delim.cnum + len(a:delim.match) - 1)
                            
                              return [l:before, l:after]
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:operator_setup(operator, type) abort " {{{1
                              let &opfunc = s:snr() . 'operator_function'
                            
                              let s:operator_abort = 0
                              let s:operator = a:operator
                              let s:operator_type = a:type
                            
                              " Ask for user input if necessary/relevant
                              if s:operator ==# 'change'
                                let l:new_env = s:change_prompt(s:operator_type)
                                if empty(l:new_env)
                                  let s:operator_abort = 1
                                  return
                                endif
                            
                                let s:operator_name = l:new_env
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:operator_function(_) abort " {{{1
                              if get(s:, 'operator_abort', 0) | return | endif
                            
                              let l:type = get(s:, 'operator_type', '')
                              let l:name = get(s:, 'operator_name', '')
                            
                              execute 'call vimtex#env#' . {
                                    \   'change': 'change_surrounding(l:type, l:name)',
                                    \   'delete': 'delete(l:type)',
                                    \   'toggle_star': 'toggle_star()',
                                    \   'toggle_math': 'toggle_math()',
                                    \ }[s:operator]
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:change_prompt(type) abort " {{{1
                              let [l:open, l:close] = vimtex#env#get_surrounding(a:type)
                              if empty(l:open) | return | endif
                            
                              if g:vimtex_env_change_autofill
                                let l:name = get(l:open, 'name', l:open.match)
                                let s:env_name = l:name
                                return vimtex#ui#input({
                                      \ 'prompt': 'Change surrounding environment: ',
                                      \ 'default': l:name,
                                      \ 'completion': 'customlist,vimtex#env#input_complete',
                                      \})
                              else
                                let l:name = get(l:open, 'name', l:open.is_open
                                      \ ? l:open.match . ' ... ' . l:open.corr
                                      \ : l:open.match . ' ... ' . l:open.corr)
                                let s:env_name = l:name
                                return vimtex#ui#input({
                                      \ 'info':
                                      \   ['Change surrounding environment: ', ['VimtexWarning', l:name]],
                                      \ 'completion': 'customlist,vimtex#env#input_complete',
                                      \})
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! s:snr() abort " {{{1
                              return matchstr(expand('<sfile>'), '<SNR>\d\+_')
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/format.vim
Sourced 1 time
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#format#init_buffer() abort " {{{1
                              if !g:vimtex_format_enabled | return | endif
                            
                              setlocal formatexpr=vimtex#format#formatexpr()
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#format#formatexpr() abort " {{{1
                              if mode() =~# '[iR]' | return -1 | endif
                            
                              " Temporary disable folds and save view
                              let l:save_view = winsaveview()
                              let l:foldenable = &l:foldenable
                              setlocal nofoldenable
                            
                              let l:top = v:lnum
                              let l:bottom = v:lnum + v:count - 1
                              let l:lines_old = getline(l:top, l:bottom)
                              let l:tries = 5
                              let s:textwidth = &l:textwidth == 0 ? 79 : &l:textwidth
                            
                              call vimtex#util#undostore()
                            
                              " Main formatting algorithm
                              while l:tries > 0
                                " Format the range of lines
                                let l:bottom = s:format(l:top, l:bottom)
                            
                                " Ensure proper indentation
                                if l:top < l:bottom
                                  silent! execute printf('normal! %sG=%sG', l:top+1, l:bottom)
                                endif
                            
                                " Check if any lines have changed
                                let l:lines_new = getline(l:top, l:bottom)
                                let l:index = s:compare_lines(l:lines_new, l:lines_old)
                                let l:top += l:index
                                if l:top > l:bottom | break | endif
                                let l:lines_old = l:lines_new[l:index : -1]
                                let l:tries -= 1
                              endwhile
                            
                              " Restore fold and view
                              let &l:foldenable = l:foldenable
                              call winrestview(l:save_view)
                            
                              " Set cursor at appropriate position
                              execute 'normal!' l:bottom . 'G^'
                            
                              " Don't change the text if the formatting algorithm failed
                              if l:tries == 0
                                silent! undo
                                call vimtex#log#warning('Formatting of selected text failed!')
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:format(top, bottom) abort " {{{1
                              let l:bottom = a:bottom
                              let l:mark = a:bottom
                              for l:current in range(a:bottom, a:top, -1)
                                let l:line = getline(l:current)
                            
                                if vimtex#syntax#in_mathzone(l:current, 1)
                                      \ && vimtex#syntax#in_mathzone(l:current, col([l:current, '$']))
                                  let l:mark = l:current - 1
                                  continue
                                endif
                            
                                " Skip all lines with comments
                                if l:line =~# '\v%(^|[^\\])\%'
                                  if l:current < l:mark
                                    let l:bottom += s:format_build_lines(l:current+1, l:mark)
                                  endif
                                  let l:mark = l:current - 1
                                  continue
                                endif
                            
                                " Handle long lines
                                if strdisplaywidth(l:line) > s:textwidth
                                  let l:bottom += s:format_build_lines(l:current, l:mark)
                                  let l:mark = l:current-1
                                endif
                            
                                if l:line =~# g:vimtex_format_border_end
                                  if l:current < l:mark
                                    let l:bottom += s:format_build_lines(l:current+1, l:mark)
                                  endif
                                  let l:mark = l:current
                                endif
                            
                                if l:line =~# g:vimtex_format_border_begin
                                  if l:current < l:mark
                                    let l:bottom += s:format_build_lines(l:current, l:mark)
                                  endif
                                  let l:mark = l:current-1
                                endif
                            
                                if l:line =~# '^\s*$'
                                  let l:bottom += s:format_build_lines(l:current+1, l:mark)
                                  let l:mark = l:current-1
                                endif
                              endfor
                            
                              if a:top <= l:mark
                                let l:bottom += s:format_build_lines(a:top, l:mark)
                              endif
                            
                              return l:bottom
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:format_build_lines(start, end) abort " {{{1
                              "
                              " Get the desired text to format as a list of words, but preserve the ending
                              " line spaces
                              "
                              let l:text = join(map(getline(a:start, a:end),
                                    \ {_, x -> substitute(x, '^\s*', '', '')}))
                              let l:spaces = matchstr(l:text, '\s*$')
                              let l:words = split(l:text, ' ')
                              if empty(l:words) | return 0 | endif
                            
                              "
                              " Add the words in properly indented and formatted lines
                              "
                              let l:lnum = a:start-1
                              let l:current = s:get_indents(indent(a:start))
                              for l:word in l:words
                                if strdisplaywidth(l:word) + strdisplaywidth(l:current) > s:textwidth
                                  call append(l:lnum, substitute(l:current, '\s$', '', ''))
                                  let l:lnum += 1
                                  let l:current = s:get_indents(VimtexIndent(a:start))
                                endif
                                let l:current .= l:word . ' '
                              endfor
                              if l:current !~# '^\s*$'
                                call append(l:lnum, substitute(l:current, '\s$', '', ''))
                                let l:lnum += 1
                              endif
                            
                              "
                              " Append the ending line spaces
                              "
                              if !empty(l:spaces)
                                call setline(l:lnum, getline(l:lnum) . l:spaces)
                              endif
                            
                              "
                              " Remove old text
                              "
                              silent! execute printf('%s;+%s delete', l:lnum+1, a:end-a:start)
                            
                              "
                              " Return the difference between number of lines of old and new text
                              "
                              return l:lnum - a:end
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:compare_lines(new, old) abort " {{{1
                              let l:min_length = min([len(a:new), len(a:old)])
                              for l:i in range(l:min_length)
                                if a:new[l:i] !=# a:old[l:i]
                                  return l:i
                                endif
                              endfor
                              return l:min_length
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_indents(number) abort " {{{1
                              return !&l:expandtab && &l:shiftwidth == &l:tabstop
                                    \ ? repeat("\t", a:number/&l:tabstop)
                                    \ : repeat(' ', a:number)
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/fzf.vim
Sourced 1 time
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#fzf#run(...) abort " {{{1
                              " Arguments: Two optional arguments
                              "
                              " First argument: ToC filter (default: 'ctli')
                              "   This may be used to select certain entry types according to the different
                              "   "layers" of vimtex-toc:
                              "     c:  content: This is the main part and the "real" ToC
                              "     t:  todo: This shows TODOs from comments and `\todo{...}` commands
                              "     l:  label: This shows `\label{...}` commands
                              "     i:  include: This shows included files
                              "
                              " Second argument: Custom options for fzf
                              "   It should be an object containing the parameters passed to fzf#run().
                            
                              " Note: The '--with-nth 3..' option hides the first two words from the fzf
                              "       window. These words are the file name and line number and are used by
                              "       the sink.
                              "
                              " Note: Using '#####' as delimiter allows spaces in the file path, while
                              "       keeping the visuals in fzf window unaffected.
                              let l:opts = extend({
                                  \ 'source': <sid>parse_toc(a:0 == 0 ? 'ctli' : a:1),
                                  \ 'sink': function('vimtex#fzf#open_selection'),
                                  \ 'options': '--ansi --with-nth 3.. --delimiter "#####"',
                                  \}, a:0 > 1 ? a:2 : {})
                            
                              call fzf#run(l:opts)
                            endfunction
                            
                            " }}}1
                            " {{{1 function! vimtex#fzf#open_selection(sel) abort
    1              0.000003 if !exists('*vimtex#fzf#open_selection')
    1              0.000002   function! vimtex#fzf#open_selection(sel) abort
                                let [l:line, l:file; _] = split(a:sel, '#####')
                            
                                if expand('%:p') == l:file
                                  execute 'normal! ' . l:line . 'gg'
                                else
                                  execute printf('edit +%s %s', l:line, l:file)
                                endif
                              endfunction
    1              0.000001 endif
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:parse_toc(filter) abort " {{{1
                              " Parsing is mostly adapted from the Denite source
                              " (see rplugin/python3/denite/source/vimtex.py)
                              python3 << EOF
                            import vim
                            import json
                            
                            def format_number(n):
                              if not n or not type(n) is dict or not 'chapter' in n:
                                  return ''
                            
                              num = [str(n[k]) for k in [
                                     'chapter',
                                     'section',
                                     'subsection',
                                     'subsubsection',
                                     'subsubsubsection'] if n[k] != '0']
                            
                              if n['appendix'] != '0':
                                 num[0] = chr(int(num[0]) + 64)
                            
                              return '.'.join(num)
                            
                            def colorize(e):
                              try:
                                from colorama import Fore, Style
                                color = {'content' : Fore.WHITE,
                                         'include' : Fore.BLUE,
                                         'label' : Fore.GREEN,
                                         'todo' : Fore.RED}[e['type']]
                                return f"{color}{e['title']:65}{Style.RESET_ALL}"
                              except ModuleNotFoundError:
                                import os
                                if os.name  == 'nt':
                                  # Colour support on Windows requires Colorama
                                  return f"{e['title']:65}"
                                else:
                                  color = {'content' : "\u001b[37m",
                                           'include' : "\u001b[34m",
                                           'label' : "\u001b[32m",
                                           'todo' : "\u001b[31m"}[e['type']]
                                  return f"{color}{e['title']:65}\u001b[0m"
                            
                            def create_candidate(e, depth):
                              number = format_number(dict(e['number']))
                              return (
                                f"{e.get('line', 0)}#####{e['file']}#####{colorize(e)} {number}"
                              )
                            
                            entries = vim.eval('vimtex#parser#toc()')
                            depth = max([int(e['level']) for e in entries])
                            filter = vim.eval("a:filter")
                            candidates = [create_candidate(e, depth)
                                          for e in entries if e['type'][0] in filter]
                            
                            # json.dumps will convert single quotes to double quotes
                            # so that vim understands the ansi escape sequences
                            vim.command(f"let candidates = {json.dumps(candidates)}")
                            EOF
                            
                              return candidates
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/imaps.vim
Sourced 1 time
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#imaps#init_buffer() abort " {{{1
                              if !g:vimtex_imaps_enabled | return | endif
                            
                              " Store mappings in buffer
                              if !exists('b:vimtex_imaps')
                                let b:vimtex_imaps = []
                              endif
                            
                              "
                              " Create imaps
                              "
                              let l:maps = g:vimtex_imaps_list
                              for l:disable in g:vimtex_imaps_disabled
                                let l:maps = filter(l:maps, {_, x -> x.lhs !=# l:disable})
                              endfor
                              for l:map in l:maps + get(s:, 'custom_maps', [])
                                call s:create_map(l:map)
                              endfor
                            
                              "
                              " Add mappings and commands
                              "
                              command! -buffer  VimtexImapsList            call vimtex#imaps#list()
                              nnoremap <buffer> <plug>(vimtex-imaps-list) :call vimtex#imaps#list()<cr>
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#imaps#add_map(map) abort " {{{1
                              let s:custom_maps = get(s:, 'custom_maps', []) + [a:map]
                            
                              if exists('b:vimtex_imaps')
                                call s:create_map(a:map)
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#imaps#list() abort " {{{1
                              let l:maps = b:vimtex_imaps
                            
                              silent new VimTeX\ imaps
                            
                              for l:map in l:maps
                                call append('$', printf('%5S  ->  %-30S %S',
                                      \ get(l:map, 'leader', g:vimtex_imaps_leader) . l:map.lhs,
                                      \ l:map.rhs,
                                      \ get(l:map, 'wrapper', 'vimtex#imaps#wrap_math')))
                              endfor
                              0delete _
                            
                              nnoremap <silent><buffer><nowait> q     :bwipeout<cr>
                              nnoremap <silent><buffer><nowait> <esc> :bwipeout<cr>
                            
                              setlocal bufhidden=wipe
                              setlocal buftype=nofile
                              setlocal concealcursor=nvic
                              setlocal conceallevel=0
                              setlocal cursorline
                              setlocal nobuflisted
                              setlocal nolist
                              setlocal nospell
                              setlocal noswapfile
                              setlocal nowrap
                              setlocal nonumber
                              setlocal norelativenumber
                              setlocal nomodifiable
                            
                              syntax match VimtexImapsLhs     /^.*\ze->/ nextgroup=VimtexImapsArrow
                              syntax match VimtexImapsArrow   /->/       contained nextgroup=VimtexImapsRhs
                              syntax match VimtexImapsRhs     /\s*\S*/   contained nextgroup=VimtexImapsWrapper
                              syntax match VimtexImapsWrapper /.*/       contained
                            endfunction
                            
                            " }}}1
                            
                            "
                            " The imap generator
                            "
    1              0.000002 function! s:create_map(map) abort " {{{1
                              if index(b:vimtex_imaps, a:map) >= 0 | return | endif
                              let l:map = deepcopy(a:map)
                            
                              let l:leader = get(l:map, 'leader', g:vimtex_imaps_leader)
                              if l:leader !=# '' && !hasmapto(l:leader, 'i')
                                silent execute 'inoremap <silent><buffer><nowait>' l:leader . l:leader l:leader
                              endif
                              let l:lhs = l:leader . l:map.lhs
                            
                              let l:wrapper = get(l:map, 'wrapper', 'vimtex#imaps#wrap_math')
                              if ! exists('*' . l:wrapper)
                                echoerr 'VimTeX error: imaps wrapper does not exist!'
                                echoerr '              ' . l:wrapper
                                return
                              endif
                            
                              " Some wrappers use a context which must be made available to the wrapper
                              " function at run time.
                              if has_key(l:map, 'context')
                                execute 'let l:key = "' . escape(l:lhs, '<') . '"'
                                let l:key .= l:map.rhs
                                if !exists('b:vimtex_context')
                                  let b:vimtex_context = {}
                                endif
                                let b:vimtex_context[l:key] = l:map.context
                              endif
                            
                              " The rhs may be evaluated before being passed to wrapper, unless expr is
                              " disabled (which it is by default)
                              if !get(l:map, 'expr')
                                let l:map.rhs = string(l:map.rhs)
                              endif
                            
                              silent execute 'inoremap <silent><buffer><nowait><expr>' l:lhs
                                    \ l:wrapper . '("' . escape(l:lhs, '\') . '", ' . l:map.rhs . ')'
                            
                              let b:vimtex_imaps += [l:map]
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Wrappers
                            "
    1              0.000002 function! vimtex#imaps#wrap_trivial(lhs, rhs) abort " {{{1
                              return a:rhs
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#imaps#wrap_math(lhs, rhs) abort " {{{1
                              return vimtex#syntax#in_mathzone() ? a:rhs : a:lhs
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#imaps#wrap_environment(lhs, rhs) abort " {{{1
                              let l:return = a:lhs
                              let l:cursor = vimtex#pos#val(vimtex#pos#get_cursor())
                              let l:value = 0
                            
                              for l:context in b:vimtex_context[a:lhs . a:rhs]
                                if type(l:context) == v:t_string
                                  let l:envs = [l:context]
                                  let l:rhs = a:rhs
                                elseif type(l:context) == v:t_dict
                                  let l:envs = l:context.envs
                                  let l:rhs = l:context.rhs
                                endif
                            
                                for l:env in l:envs
                                  let l:candidate_value = vimtex#pos#val(vimtex#env#is_inside(l:env))
                                  if l:candidate_value > l:value
                                    let l:value = l:candidate_value
                                    let l:return = l:rhs
                                  endif
                                endfor
                            
                                unlet l:context
                              endfor
                            
                              return l:return
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Special rhs styles
                            "
    1              0.000002 function! vimtex#imaps#style_math(command) " {{{1
                              return vimtex#syntax#in_mathzone()
                                    \ ? '\' . a:command . '{' . nr2char(getchar()) . '}'
                                    \ : ''
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/include.vim
Sourced 1 time
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#include#expr() abort " {{{1
                              call s:visited.timeout()
                              let l:fname = substitute(v:fname, '^\s*\|\s*$', '', 'g')
                            
                              " Check if v:fname matches exactly
                              if filereadable(l:fname)
                                return s:visited.check(l:fname)
                              endif
                            
                              " Parse \include or \input style lines
                              let l:file = s:parse_input(l:fname, 'tex')
                              for l:candidate in [l:file, l:file . '.tex']
                                if filereadable(l:candidate)
                                  return s:visited.check(l:candidate)
                                endif
                              endfor
                            
                              " Parse \bibliography or \addbibresource
                              let l:candidate = s:parse_input(l:fname, 'bib')
                              if filereadable(l:candidate)
                                return s:visited.check(l:candidate)
                              endif
                            
                              " Check if v:fname matches in $TEXINPUTS
                              let l:candidate = s:search_candidates_texinputs(l:fname)
                              if !empty(l:candidate)
                                return s:visited.check(l:candidate)
                              endif
                            
                              " Search for file with kpsewhich
                              if g:vimtex_include_search_enabled
                                " Parse package or documentclass commands
                                let l:fname = s:parse_package_documentclass(l:fname)
                            
                                let l:candidate = s:search_candidates_kpsewhich(l:fname)
                                if !empty(l:candidate)
                                  return s:visited.check(l:candidate)
                                endif
                              endif
                            
                              return s:visited.check(l:fname)
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000003 function! s:parse_input(fname, type) abort " {{{1
                              let [l:lnum, l:cnum] = searchpos(g:vimtex#re#{a:type}_input, 'bcn', line('.'))
                              if l:lnum == 0 | return a:fname | endif
                            
                              let l:cmd = vimtex#cmd#get_at(l:lnum, l:cnum)
                              if empty(l:cmd) | return a:fname | endif
                            
                              let l:file = join(
                                    \ map(get(l:cmd, 'args', [{}]), {_, x -> get(x, 'text', '')}),
                                    \ '')
                              let l:file = substitute(l:file, '^\s*"\|"\s*$', '', 'g')
                              let l:file = substitute(l:file, '\\space', '', 'g')
                            
                              if l:file[-3:] !=# a:type
                                let l:file .= '.' . a:type
                              endif
                            
                              return l:file
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parse_package_documentclass(fname) abort " {{{1
                              let [l:lnum, l:cnum] = searchpos(s:re_cmds, 'bcn', line('.'))
                              if l:lnum == 0 | return a:fname | endif
                            
                              let l:cmd = vimtex#cmd#get_at(l:lnum, l:cnum)
                              if empty(l:cmd) | return a:fname | endif
                            
                              let l:args = get(l:cmd, 'args', [{}])
                              if l:cmd.name =~# 'PassOptionsTo'
                                let l:result = l:args[1].text
                              else
                                let l:result = l:args[0].text
                              endif
                            
                              return vimtex#util#trim(l:result)
                            endfunction
                            
    1              0.000011 let s:re_cmds = '\v\s*\\%(' . join([
                                  \ 'documentclass',
                                  \ 'LoadClass',
                                  \ 'usepackage',
                                  \ 'RequirePackage',
                                  \ 'PassOptionsToClass',
                                  \ 'PassOptionsToPackage'
                                  \], '|') . ')'
                            
                            " }}}1
                            
    1              0.000002 function! s:search_candidates_texinputs(fname) abort " {{{1
                              for l:suffix in [''] + split(&l:suffixesadd, ',')
                                let l:candidates = glob(b:vimtex.root . '/**/'
                                      \ . fnameescape(a:fname) . l:suffix, 0, 1)
                                if !empty(l:candidates)
                                  return l:candidates[0]
                                endif
                              endfor
                            
                              return ''
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:search_candidates_kpsewhich(fname) abort " {{{1
                              " Split input list on commas, and if applicable, ensure that the entry that
                              " the cursor is on is placed first in the queue
                              let l:files = split(a:fname, '\s*,\s*')
                              let l:current = expand('<cword>')
                              let l:index = index(l:files, l:current)
                              if l:index >= 0
                                call remove(l:files, l:index)
                                let l:files = [l:current] + l:files
                              endif
                            
                              " Add file extensions to create the final list of candidate files
                              let l:candidates = []
                              for l:file in l:files
                                if !empty(fnamemodify(l:file, ':e'))
                                  call add(l:candidates, l:file)
                                else
                                  call extend(l:candidates, map(split(&l:suffixesadd, ','), 'l:file . v:val'))
                                endif
                              endfor
                            
                              for l:file in l:candidates
                                let l:candidate = get(vimtex#kpsewhich#run(fnameescape(l:file)), 0, '')
                                if !empty(l:candidate) && filereadable(l:candidate) | return l:candidate | endif
                              endfor
                            
                              return ''
                            endfunction
                            
                            " }}}1
                            
    1              0.000004 let s:visited = {
                                  \ 'time' : 0,
                                  \ 'list' : [],
                                  \}
    1              0.000002 function! s:visited.timeout() abort dict " {{{1
                              if localtime() - self.time > 1
                                let self.time = localtime()
                                let self.list = [expand('%:p')]
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:visited.check(fname) abort dict " {{{1
                              if index(self.list, fnamemodify(a:fname, ':p')) < 0
                                call add(self.list, fnamemodify(a:fname, ':p'))
                                return a:fname
                              endif
                            
                              return ''
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/info.vim
Sourced 1 time
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#info#init_buffer() abort " {{{1
                              command! -buffer -bang VimtexInfo call vimtex#info#open(<q-bang> == '!')
                            
                              nnoremap <buffer> <plug>(vimtex-info)      :VimtexInfo<cr>
                              nnoremap <buffer> <plug>(vimtex-info-full) :VimtexInfo!<cr>
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#info#open(global) abort " {{{1
                              let s:info.global = a:global
                              call vimtex#scratch#new(s:info)
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000005 let s:info = {
                                  \ 'name' : 'VimtexInfo',
                                  \ 'global' : 0,
                                  \}
    1              0.000002 function! s:info.print_content() abort dict " {{{1
                              for l:line in self.gather_system_info()
                                call append('$', l:line)
                              endfor
                              call append('$', '')
                              for l:line in self.gather_state_info()
                                call append('$', l:line)
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:info.gather_system_info() abort dict " {{{1
                              let l:lines = [
                                    \ 'System info:',
                                    \ '  OS: ' . s:get_os_info(),
                                    \ '  Vim version: ' . s:get_vim_info(),
                                    \]
                            
                              if has('clientserver') || has('nvim')
                                call add(l:lines, '  Has clientserver: true')
                                call add(l:lines, '  Servername: '
                                      \ . (empty(v:servername) ? 'undefined (vim started without --servername)' : v:servername))
                              else
                                call add(l:lines, '  Has clientserver: false')
                              endif
                            
                              return l:lines
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:info.gather_state_info() abort dict " {{{1
                              if self.global
                                let l:lines = []
                                for l:data in vimtex#state#list_all()
                                  let l:lines += s:get_info(l:data)
                                  let l:lines += ['']
                                endfor
                                call remove(l:lines, -1)
                              else
                                let l:lines = s:get_info(b:vimtex)
                              endif
                            
                              return l:lines
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:info.syntax() abort dict " {{{1
                              syntax match VimtexInfoOther /.*/
                              syntax match VimtexInfoKey /^.\{-}:/ nextgroup=VimtexInfoValue
                              syntax match VimtexInfoValue /.*/ contained
                              syntax match VimtexInfoTitle /VimTeX project:/ nextgroup=VimtexInfoValue
                              syntax match VimtexInfoTitle /System info/
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Functions to parse the VimTeX state data
                            "
    1              0.000002 function! s:get_info(item, ...) abort " {{{1
                              if empty(a:item) | return [] | endif
                              let l:indent = a:0 > 0 ? a:1 : 0
                            
                              if type(a:item) == v:t_dict
                                return s:parse_dict(a:item, l:indent)
                              endif
                            
                              if type(a:item) == v:t_list
                                let l:entries = []
                                for [l:title, l:Value] in a:item
                                  if type(l:Value) == v:t_dict
                                    call extend(l:entries, s:parse_dict(l:Value, l:indent, l:title))
                                  elseif type(l:Value) == v:t_list
                                    call extend(l:entries, s:parse_list(l:Value, l:indent, l:title))
                                  else
                                    call add(l:entries,
                                          \ repeat('  ', l:indent) . printf('%s: %s', l:title, l:Value))
                                  endif
                                  unlet l:Value
                                endfor
                                return l:entries
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parse_dict(dict, indent, ...) abort " {{{1
                              if empty(a:dict) | return [] | endif
                              let l:dict = a:dict
                              let l:indent = a:indent
                              let l:entries = []
                            
                              if a:0 > 0
                                let l:title = a:1
                                let l:name = ''
                                if has_key(a:dict, 'name')
                                  let l:dict = deepcopy(a:dict)
                                  let l:name = remove(l:dict, 'name')
                                endif
                                call add(l:entries,
                                      \ repeat('  ', l:indent) . printf('%s: %s', l:title, l:name))
                                let l:indent += 1
                              endif
                            
                              let l:items = has_key(l:dict, '__pprint')
                                    \ ? l:dict.__pprint() : items(l:dict)
                            
                              return extend(l:entries, s:get_info(l:items, l:indent))
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:parse_list(list, indent, title) abort " {{{1
                              if empty(a:list) | return [] | endif
                            
                              let l:entries = []
                              let l:indent = repeat('  ', a:indent)
                              if type(a:list[0]) == v:t_list
                                let l:name = ''
                                let l:index = 0
                            
                                " l:entry[0] == title
                                " l:entry[1] == value
                                for l:entry in a:list
                                  if l:entry[0] ==# 'name'
                                    let l:name = l:entry[1]
                                    break
                                  endif
                                  let l:index += 1
                                endfor
                            
                                if empty(l:name)
                                  let l:list = a:list
                                else
                                  let l:list = deepcopy(a:list)
                                  call remove(l:list, l:index)
                                endif
                            
                                call add(l:entries, l:indent . printf('%s: %s', a:title, l:name))
                                call extend(l:entries, s:get_info(l:list, a:indent+1))
                              else
                                call add(l:entries, l:indent . printf('%s:', a:title))
                                for l:value in a:list
                                  call add(l:entries, l:indent . printf('  %s', l:value))
                                endfor
                              endif
                            
                              return l:entries
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Other utility functions
                            "
    1              0.000001 function! s:get_os_info() abort " {{{1
                              let l:os = vimtex#util#get_os()
                            
                              if l:os ==# 'linux'
                                let l:result = executable('lsb_release')
                                    \ ? vimtex#jobs#cached('lsb_release -d')[0][12:]
                                    \ : vimtex#jobs#cached('uname -sr')[0]
                                return substitute(l:result, '^\s*', '', '')
                              elseif l:os ==# 'mac'
                                if executable('sw_vers')
                                  let l:name = vimtex#jobs#cached('sw_vers -productName')[0]
                                  let l:version = vimtex#jobs#cached('sw_vers -productVersion')[0]
                                  let l:build = vimtex#jobs#cached('sw_vers -buildVersion')[0]
                                  return l:name . ' ' . l:version . ' (' . l:build . ')'
                                else
                                  return 'MacOS/i[Pad]OS'
                                endif
                              else
                                let l:win_info = vimtex#jobs#cached('systeminfo')
                            
                                try
                                  let l:name = vimtex#util#trim(matchstr(l:win_info[1], ':\s*\zs.*'))
                                  let l:version = vimtex#util#trim(matchstr(l:win_info[2], ':\s*\zs.*'))
                                  return l:name . ' (' . l:version . ')'
                                catch
                                  return 'Windows (' . string(l:win_info) . ')'
                                endtry
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:get_vim_info() abort " {{{1
                              let l:info = vimtex#util#command('version')
                            
                              if has('nvim')
                                return l:info[0]
                              else
                                let l:version = 'VIM ' . strpart(l:info[0], 18, 3) . ' ('
                                let l:index = 2 - (l:info[1] =~# ':\s*\d')
                                let l:version .= matchstr(l:info[l:index], ':\s*\zs.*') . ')'
                                return l:version
                              endif
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/kpsewhich.vim
Sourced 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#kpsewhich#find(file) abort " {{{1
                              let l:cache = vimtex#cache#open('kpsewhich', {'default': []})
                            
                              let l:root = exists('b:vimtex.root') ? b:vimtex.root : getcwd()
                              let l:current = l:cache.get(a:file)
                            
                              " Check cache for result
                              try
                                for [l:result, l:result_root] in l:current
                                  if empty(l:result_root) || l:result_root ==# l:root
                                    return l:result
                                  endif
                                endfor
                              catch
                                call vimtex#log#error(
                                      \ 'Invalid kpsewhich cache!',
                                      \ 'Please clear with ":VimtexClearCache kpsewhich"'
                                      \)
                                return ''
                              endtry
                            
                              " Perform search -> [result, result_root]
                              let l:result = get(vimtex#kpsewhich#run(fnameescape(a:file)), 0, '')
                              if !vimtex#paths#is_abs(l:result)
                                let l:result = empty(l:result) ? '' : simplify(l:root . '/' . l:result)
                                call add(l:current, [l:result, l:root])
                              else
                                call add(l:current, [l:result, ''])
                              endif
                            
                              " Write cache to file
                              let l:cache.modified = 1
                              call l:cache.write()
                            
                              return l:result
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#kpsewhich#run(args) abort " {{{1
                              " kpsewhich should be run at the project root directory
                              if exists('b:vimtex.root')
                                call vimtex#paths#pushd(b:vimtex.root)
                              endif
                              let l:output = vimtex#jobs#capture('kpsewhich ' . a:args)
                              if exists('b:vimtex.root')
                                call vimtex#paths#popd()
                              endif
                            
                              " Remove warning lines from output
                              call filter(l:output, {_, x -> stridx(x, 'kpsewhich: warning: ') == -1})
                            
                              return l:output
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/log.vim
Sourced 1 time
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#log#init_buffer() abort " {{{1
                              command! -buffer -bang VimtexLog call vimtex#log#open()
                            
                              nnoremap <buffer> <plug>(vimtex-log) :VimtexLog<cr>
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#log#info(...) abort " {{{1
                              call s:logger.add(a:000, 'info')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#log#warning(...) abort " {{{1
                              call s:logger.add(a:000, 'warning')
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#log#error(...) abort " {{{1
                              call s:logger.add(a:000, 'error')
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#log#get() abort " {{{1
                              return s:logger.entries
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#log#open() abort " {{{1
                              call vimtex#scratch#new(s:logger)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#log#toggle_verbose() abort " {{{1
                              let s:logger.verbose = !s:logger.verbose
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#log#set_silent() abort " {{{1
                              let s:logger.verbose_old = get(s:logger, 'verbose_old', s:logger.verbose)
                              let s:logger.verbose = 0
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#log#set_silent_restore() abort " {{{1
                              let s:logger.verbose = get(s:logger, 'verbose_old', s:logger.verbose)
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000027 let s:logger = {
                                  \ 'name': 'VimtexMessageLog',
                                  \ 'entries': [],
                                  \ 'type_to_highlight': {
                                  \   'info': 'VimtexInfo',
                                  \   'warning': 'VimtexWarning',
                                  \   'error': 'VimtexError',
                                  \ },
                                  \ 'type_to_level': {
                                  \   'info': 1,
                                  \   'warning': 2,
                                  \   'error': 3,
                                  \ },
                                  \ 'verbose': get(get(s:, 'logger', {}), 'verbose',
                                  \                get(g:, 'vimtex_log_verbose', 1)),
                                  \}
    1              0.000002 function! s:logger.add(msg_arg, type) abort dict " {{{1
                              let l:msg_list = []
                              for l:msg in a:msg_arg
                                if type(l:msg) == v:t_string
                                  call add(l:msg_list, l:msg)
                                elseif type(l:msg) == v:t_list
                                  call extend(l:msg_list, filter(l:msg, 'type(v:val) == v:t_string'))
                                endif
                              endfor
                            
                              let l:entry = {}
                              let l:entry.type = a:type
                              let l:entry.time = strftime('%T')
                              let l:entry.msg = l:msg_list
                              let l:entry.callstack = vimtex#debug#stacktrace()[2:]
                              for l:level in l:entry.callstack
                                let l:level.nr -= 2
                              endfor
                              call add(self.entries, l:entry)
                            
                              if self.verbose
                                if self.type_to_level[a:type] > 1
                                  unsilent call self.notify(l:msg_list, a:type)
                                else
                                  call self.notify(l:msg_list, a:type)
                                endif
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:logger.notify(msg_list, type) abort dict " {{{1
                              for l:re in get(g:, 'vimtex_log_ignore', [])
                                if join(a:msg_list) =~# l:re | return | endif
                              endfor
                            
                              call vimtex#ui#echo([
                                    \ [self.type_to_highlight[a:type], 'VimTeX:'],
                                    \ ' ' . a:msg_list[0]
                                    \])
                            
                              " if len(a:msg_list) > 1
                              "   call vimtex#ui#echo(
                              "         \ join(map(a:msg_list[1:], "'        ' . v:val"), "\n"))
                              " endif
                              for l:msg in a:msg_list[1:]
                                call vimtex#ui#echo(l:msg, {'indent': 8})
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:logger.print_content() abort dict " {{{1
                              for l:entry in self.entries
                                call append('$', printf('%s: %s', l:entry.time, l:entry.type))
                                for l:stack in l:entry.callstack
                                  if l:stack.lnum > 0
                                    call append('$', printf('  #%d %s:%d', l:stack.nr, l:stack.filename, l:stack.lnum))
                                  else
                                    call append('$', printf('  #%d %s', l:stack.nr, l:stack.filename))
                                  endif
                                  call append('$', printf('  In %s', l:stack.function))
                                  if !empty(l:stack.text)
                                    call append('$', printf('    %s', l:stack.text))
                                  endif
                                endfor
                                for l:msg in l:entry.msg
                                  call append('$', printf('  %s', l:msg))
                                endfor
                                call append('$', '')
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:logger.syntax() abort dict " {{{1
                              syntax match VimtexInfoOther /.*/
                            
                              syntax include @VIM syntax/vim.vim
                              syntax match VimtexInfoVimCode /^    .*/ transparent contains=@VIM
                            
                              syntax match VimtexInfoKey /^\S*:/ nextgroup=VimtexInfoValue
                              syntax match VimtexInfoKey /^  #\d\+/ nextgroup=VimtexInfoValue
                              syntax match VimtexInfoKey /^  In/ nextgroup=VimtexInfoValue
                              syntax match VimtexInfoValue /.*/ contained
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/matchparen.vim
Sourced 1 time
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#matchparen#init_buffer() abort " {{{1
                              if !g:vimtex_matchparen_enabled | return | endif
                            
                              call vimtex#matchparen#enable()
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#matchparen#enable() abort " {{{1
                              call s:matchparen.enable()
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#matchparen#disable() abort " {{{1
                              call s:matchparen.disable()
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#matchparen#popup_check(...) abort " {{{1
                              if pumvisible()
                                call s:matchparen.highlight()
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 let s:matchparen = {}
                            
    1              0.000002 function! s:matchparen.enable() abort dict " {{{1
                              " vint: -ProhibitAutocmdWithNoGroup
                            
                              execute 'augroup vimtex_matchparen' . bufnr('%')
                                autocmd!
                                autocmd CursorMoved  <buffer> call s:matchparen.highlight()
                                autocmd CursorMovedI <buffer> call s:matchparen.highlight()
                                autocmd BufLeave     <buffer> call s:matchparen.clear()
                                autocmd WinLeave     <buffer> call s:matchparen.clear()
                                autocmd WinEnter     <buffer> call s:matchparen.highlight()
                                try
                                  autocmd TextChangedP <buffer> call s:matchparen.highlight()
                                catch /E216/
                                  silent! let self.timer =
                                        \ timer_start(50, 'vimtex#matchparen#popup_check', {'repeat' : -1})
                                endtry
                              augroup END
                            
                              call self.highlight()
                            
                              " vint: +ProhibitAutocmdWithNoGroup
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:matchparen.disable() abort dict " {{{1
                              call self.clear()
                              execute 'autocmd! vimtex_matchparen' . bufnr('%')
                              silent! call timer_stop(self.timer)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:matchparen.clear() abort dict " {{{1
                              silent! call matchdelete(w:vimtex_match_id1)
                              silent! call matchdelete(w:vimtex_match_id2)
                              unlet! w:vimtex_match_id1
                              unlet! w:vimtex_match_id2
                            endfunction
    1              0.000001 function! s:matchparen.highlight() abort dict " {{{1
                              call self.clear()
                            
                              if vimtex#syntax#in_comment() | return | endif
                            
                              " This is a hack to ensure that $ in visual block mode adhers to the rule
                              " specified in :help v_$
                              if mode() ==# "\<c-v>"
                                let l:pos = vimtex#pos#get_cursor()
                                if len(l:pos) == 5 && l:pos[-1] == 2147483647
                                  call feedkeys('$', 'in')
                                endif
                              endif
                            
                              let l:current = vimtex#delim#get_current('all', 'both')
                              if empty(l:current) | return | endif
                            
                              let l:corresponding = vimtex#delim#get_matching(l:current)
                              if empty(l:corresponding) | return | endif
                              if empty(l:corresponding.match) | return | endif
                            
                              let [l:open, l:close] = l:current.is_open
                                    \ ? [l:current, l:corresponding]
                                    \ : [l:corresponding, l:current]
                            
                              let w:vimtex_match_id1 = matchaddpos('MatchParen',
                                    \ [[l:open.lnum, l:open.cnum, strlen(l:open.match)]])
                              let w:vimtex_match_id2 = matchaddpos('MatchParen',
                                    \ [[l:close.lnum, l:close.cnum, strlen(l:close.match)]])
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/syntax.vim
Sourced 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#syntax#stack(...) abort " {{{1
                              let l:pos = a:0 > 0 ? [a:1, a:2] : [line('.'), col('.')]
                              if mode() ==# 'i'
                                let l:pos[1] -= 1
                              endif
                              call map(l:pos, 'max([v:val, 1])')
                            
                              return map(synstack(l:pos[0], l:pos[1]), "synIDattr(v:val, 'name')")
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#syntax#in(name, ...) abort " {{{1
                              return match(call('vimtex#syntax#stack', a:000), '^' . a:name) >= 0
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#syntax#in_comment(...) abort " {{{1
                              return call('vimtex#syntax#in', ['texComment'] + a:000)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#syntax#in_mathzone(...) abort " {{{1
                              " The following checks if we are inside a texMathZone environment. The
                              " arguments to \label{...}, the texRefArg group, and \text{...} like
                              " commands, the texMathTextArg group, are actively ignored as these should
                              " not be considered to be math environments.
                              let l:groups = reverse(call('vimtex#syntax#stack', a:000))
                              let l:group = matchstr(l:groups, '\v^tex%(Math%(Zone|Text|Tag)|RefArg)')
                              return l:group =~# '^texMathZone'
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/pos.vim
Sourced 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#pos#set_cursor(...) abort " {{{1
                              call cursor(s:parse_args(a:000))
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#pos#get_cursor() abort " {{{1
                              return getcurpos()
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#pos#get_cursor_line() abort " {{{1
                              let l:pos = vimtex#pos#get_cursor()
                              return l:pos[1]
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#pos#val(...) abort " {{{1
                              let [l:lnum, l:cnum; l:rest] = s:parse_args(a:000)
                            
                              return 100000*l:lnum + min([l:cnum, 90000])
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#pos#next(...) abort " {{{1
                              let [l:lnum, l:cnum; l:rest] = s:parse_args(a:000)
                            
                              return l:cnum < strlen(getline(l:lnum))
                                    \ ? [0, l:lnum, l:cnum+1, 0]
                                    \ : [0, l:lnum+1, 1, 0]
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#pos#prev(...) abort " {{{1
                              let [l:lnum, l:cnum; l:rest] = s:parse_args(a:000)
                            
                              return l:cnum > 1
                                    \ ? [0, l:lnum, l:cnum-1, 0]
                                    \ : [0, max([l:lnum-1, 1]), strlen(getline(l:lnum-1)), 0]
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#pos#larger(pos1, pos2) abort " {{{1
                              return vimtex#pos#val(a:pos1) > vimtex#pos#val(a:pos2)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#pos#equal(p1, p2) abort " {{{1
                              let l:pos1 = s:parse_args(a:p1)
                              let l:pos2 = s:parse_args(a:p2)
                              return l:pos1[:1] == l:pos2[:1]
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#pos#smaller(pos1, pos2) abort " {{{1
                              return vimtex#pos#val(a:pos1) < vimtex#pos#val(a:pos2)
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:parse_args(args) abort " {{{1
                              "
                              " The arguments should be in one of the following forms (when unpacked):
                              "
                              "   [lnum, cnum]
                              "   [bufnum, lnum, cnum, ...]
                              "   {'lnum' : lnum, 'cnum' : cnum}
                              "
                            
                              if len(a:args) > 1
                                return s:parse_args([a:args])
                              elseif len(a:args) == 1
                                if type(a:args[0]) == v:t_dict
                                  return [get(a:args[0], 'lnum'), get(a:args[0], 'cnum')]
                                else
                                  if len(a:args[0]) == 2
                                    return a:args[0]
                                  else
                                    return a:args[0][1:]
                                  endif
                                endif
                              else
                                return a:args
                              endif
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/misc.vim
Sourced 1 time
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#misc#init_buffer() abort " {{{1
                              command! -buffer                VimtexReload call vimtex#misc#reload()
                              command! -buffer -bang -range=% VimtexCountWords
                                    \ call vimtex#misc#wordcount_display({
                                    \   'range' : [<line1>, <line2>],
                                    \   'detailed' : <q-bang> == '!',
                                    \   'count_letters' : 0,
                                    \ })
                              command! -buffer -bang -range=% VimtexCountLetters
                                    \ call vimtex#misc#wordcount_display({
                                    \   'range' : [<line1>, <line2>],
                                    \   'detailed' : <q-bang> == '!',
                                    \   'count_letters' : 1,
                                    \ })
                            
                              nnoremap <buffer> <plug>(vimtex-reload) :VimtexReload<cr>
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#misc#get_graphicspath(fname) abort " {{{1
                              for l:root in b:vimtex.graphicspath + ['.']
                                let l:candidate = simplify(b:vimtex.root . '/' . l:root . '/' . a:fname)
                                for l:suffix in ['', '.jpg', '.png', '.pdf']
                                  if filereadable(l:candidate . l:suffix)
                                    return l:candidate . l:suffix
                                  endif
                                endfor
                              endfor
                            
                              return a:fname
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#misc#wordcount(...) abort " {{{1
                              let l:opts = a:0 > 0 ? a:1 : {}
                            
                              let l:range = get(l:opts, 'range', [1, line('$')])
                              if l:range == [1, line('$')]
                                let l:file = b:vimtex
                              else
                                let l:file = vimtex#parser#selection_to_texfile({'range': l:range})
                              endif
                            
                              let l:cmd = 'texcount -nosub -sum '
                                    \ . (get(l:opts, 'count_letters') ? '-letter ' : '')
                                    \ . (get(l:opts, 'detailed') ? '-inc ' : '-q -1 -merge ')
                                    \ . g:vimtex_texcount_custom_arg . ' '
                                    \ . vimtex#util#shellescape(l:file.base)
                              let l:lines = vimtex#jobs#capture(l:cmd, {'cwd': l:file.root})
                            
                              if l:file.base !=# b:vimtex.base
                                call delete(l:file.tex)
                              endif
                            
                              if get(l:opts, 'detailed')
                                return l:lines
                              else
                                call filter(l:lines, 'v:val !~# ''ERROR\|^\s*$''')
                                return join(l:lines, '')
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#misc#wordcount_display(opts) abort " {{{1
                              let output = vimtex#misc#wordcount(a:opts)
                            
                              if !get(a:opts, 'detailed')
                                call vimtex#log#info('Counted '
                                      \ . (get(a:opts, 'count_letters') ? 'letters: ' : 'words: ')
                                      \ . output)
                                return
                              endif
                            
                              " Create wordcount window
                              if bufnr('TeXcount') >= 0
                                bwipeout TeXcount
                              endif
                              split TeXcount
                            
                              " Add lines to buffer
                              for line in output
                                call append('$', printf('%s', line))
                              endfor
                              0delete _
                            
                              " Set mappings
                              nnoremap <silent><buffer><nowait> q :bwipeout<cr>
                            
                              " Set buffer options
                              setlocal bufhidden=wipe
                              setlocal buftype=nofile
                              setlocal cursorline
                              setlocal nobuflisted
                              setlocal nolist
                              setlocal nospell
                              setlocal noswapfile
                              setlocal nowrap
                              setlocal tabstop=8
                              setlocal nomodifiable
                            
                              " Set highlighting
                              syntax match TexcountText  /^.*:.*/ contains=TexcountValue
                              syntax match TexcountValue /.*:\zs.*/
                              highlight link TexcountText  VimtexMsg
                              highlight link TexcountValue Constant
                            endfunction
                            
                            " }}}1
                            " {{{1 function! vimtex#misc#reload()
    1              0.000003 if get(s:, 'reload_guard', 1)
    1              0.000002   function! vimtex#misc#reload() abort
                                let s:reload_guard = 0
                            
                                " Stop all compiler processes
                                silent call vimtex#compiler#stop_all()
                            
                                for l:file in glob(s:file . '/**/*.vim', 0, 1)
                                  execute 'source' l:file
                                endfor
                            
                                " Temporarily unset b:current_syntax (if active)
                                let l:reload_syntax = get(b:, 'current_syntax', '') ==# 'tex'
                                if l:reload_syntax
                                  unlet b:current_syntax
                                endif
                            
                                call vimtex#init()
                            
                                " Reload syntax
                                if l:reload_syntax
                                  syntax clear
                                  runtime! syntax/tex.vim
                                endif
                            
                                " Reload indent file
                                if exists('b:did_vimtex_indent')
                                  unlet b:did_indent
                                  runtime indent/tex.vim
                                endif
                            
                                call vimtex#log#info('The plugin has been reloaded!')
                                unlet s:reload_guard
                              endfunction
    1              0.000001 endif
                            
                            " }}}1
                            
                            
    1              0.000005 let s:file = expand('<sfile>:h:h')

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/motion.vim
Sourced 1 time
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#motion#init_buffer() abort " {{{1
                              if !g:vimtex_motion_enabled | return | endif
                            
                              " Utility map to avoid conflict with "normal" command
                              nnoremap <buffer> <sid>(v) v
                              nnoremap <buffer> <sid>(V) V
                            
                              " Matching pairs
                              nnoremap <silent><buffer> <plug>(vimtex-%) :call vimtex#motion#find_matching_pair()<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-%) :<c-u>call vimtex#motion#find_matching_pair(1)<cr>
                              xmap     <silent><buffer> <plug>(vimtex-%) <sid>(vimtex-%)
                              onoremap <silent><buffer> <plug>(vimtex-%) :execute "normal \<sid>(v)\<sid>(vimtex-%)"<cr>
                            
                              " Sections
                              nnoremap <silent><buffer> <plug>(vimtex-]]) :<c-u>call vimtex#motion#section(0,0,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-][) :<c-u>call vimtex#motion#section(1,0,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-[]) :<c-u>call vimtex#motion#section(1,1,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-[[) :<c-u>call vimtex#motion#section(0,1,0)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-]]) :<c-u>call vimtex#motion#section(0,0,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-][) :<c-u>call vimtex#motion#section(1,0,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-[]) :<c-u>call vimtex#motion#section(1,1,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-[[) :<c-u>call vimtex#motion#section(0,1,1)<cr>
                              xmap     <silent><buffer> <plug>(vimtex-]]) <sid>(vimtex-]])
                              xmap     <silent><buffer> <plug>(vimtex-][) <sid>(vimtex-][)
                              xmap     <silent><buffer> <plug>(vimtex-[]) <sid>(vimtex-[])
                              xmap     <silent><buffer> <plug>(vimtex-[[) <sid>(vimtex-[[)
                              onoremap <silent><buffer> <plug>(vimtex-]]) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]])"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-][) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-][)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-[]) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[])"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-[[) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[[)"<cr>
                            
                              " Math environments ($-$, $$-$$, \(-\), \[-\], \begin-\end)
                              nnoremap <silent><buffer> <plug>(vimtex-]n) :<c-u>call vimtex#motion#math(1,0,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-]N) :<c-u>call vimtex#motion#math(0,0,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-[n) :<c-u>call vimtex#motion#math(1,1,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-[N) :<c-u>call vimtex#motion#math(0,1,0)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-]n) :<c-u>call vimtex#motion#math(1,0,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-]N) :<c-u>call vimtex#motion#math(0,0,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-[n) :<c-u>call vimtex#motion#math(1,1,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-[N) :<c-u>call vimtex#motion#math(0,1,1)<cr>
                              xmap     <silent><buffer> <plug>(vimtex-]n) <sid>(vimtex-]n)
                              xmap     <silent><buffer> <plug>(vimtex-]N) <sid>(vimtex-]N)
                              xmap     <silent><buffer> <plug>(vimtex-[n) <sid>(vimtex-]n)
                              xmap     <silent><buffer> <plug>(vimtex-[N) <sid>(vimtex-]N)
                              onoremap <silent><buffer> <plug>(vimtex-]n) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]n)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-]N) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]N)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-[n) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[n)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-[N) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[N)"<cr>
                            
                              " Environments
                              nnoremap <silent><buffer> <plug>(vimtex-]m) :<c-u>call vimtex#motion#environment(1,0,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-]M) :<c-u>call vimtex#motion#environment(0,0,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-[m) :<c-u>call vimtex#motion#environment(1,1,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-[M) :<c-u>call vimtex#motion#environment(0,1,0)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-]m) :<c-u>call vimtex#motion#environment(1,0,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-]M) :<c-u>call vimtex#motion#environment(0,0,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-[m) :<c-u>call vimtex#motion#environment(1,1,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-[M) :<c-u>call vimtex#motion#environment(0,1,1)<cr>
                              xmap     <silent><buffer> <plug>(vimtex-]m) <sid>(vimtex-]m)
                              xmap     <silent><buffer> <plug>(vimtex-]M) <sid>(vimtex-]M)
                              xmap     <silent><buffer> <plug>(vimtex-[m) <sid>(vimtex-[m)
                              xmap     <silent><buffer> <plug>(vimtex-[M) <sid>(vimtex-[M)
                              onoremap <silent><buffer> <plug>(vimtex-]m) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]m)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-]M) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]M)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-[m) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[m)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-[M) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[M)"<cr>
                            
                              " Frames
                              nnoremap <silent><buffer> <plug>(vimtex-]r) :<c-u>call vimtex#motion#frame(1,0,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-]R) :<c-u>call vimtex#motion#frame(0,0,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-[r) :<c-u>call vimtex#motion#frame(1,1,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-[R) :<c-u>call vimtex#motion#frame(0,1,0)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-]r) :<c-u>call vimtex#motion#frame(1,0,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-]R) :<c-u>call vimtex#motion#frame(0,0,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-[r) :<c-u>call vimtex#motion#frame(1,1,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-[R) :<c-u>call vimtex#motion#frame(0,1,1)<cr>
                              xmap     <silent><buffer> <plug>(vimtex-]r) <sid>(vimtex-]r)
                              xmap     <silent><buffer> <plug>(vimtex-]R) <sid>(vimtex-]R)
                              xmap     <silent><buffer> <plug>(vimtex-[r) <sid>(vimtex-[r)
                              xmap     <silent><buffer> <plug>(vimtex-[R) <sid>(vimtex-[R)
                              onoremap <silent><buffer> <plug>(vimtex-]r) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]r)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-]R) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]R)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-[r) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[r)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-[R) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[R)"<cr>
                            
                              " Comments
                              nnoremap <silent><buffer> <plug>(vimtex-]/) :<c-u>call vimtex#motion#comment(1,0,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-]*) :<c-u>call vimtex#motion#comment(0,0,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-[/) :<c-u>call vimtex#motion#comment(1,1,0)<cr>
                              nnoremap <silent><buffer> <plug>(vimtex-[*) :<c-u>call vimtex#motion#comment(0,1,0)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-]/) :<c-u>call vimtex#motion#comment(1,0,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-]*) :<c-u>call vimtex#motion#comment(0,0,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-[/) :<c-u>call vimtex#motion#comment(1,1,1)<cr>
                              xnoremap <silent><buffer>  <sid>(vimtex-[*) :<c-u>call vimtex#motion#comment(0,1,1)<cr>
                              xmap     <silent><buffer> <plug>(vimtex-]/) <sid>(vimtex-]/)
                              xmap     <silent><buffer> <plug>(vimtex-]*) <sid>(vimtex-]*)
                              xmap     <silent><buffer> <plug>(vimtex-[/) <sid>(vimtex-[/)
                              xmap     <silent><buffer> <plug>(vimtex-[*) <sid>(vimtex-[*)
                              onoremap <silent><buffer> <plug>(vimtex-]/) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]/)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-]*) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]*)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-[/) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[/)"<cr>
                              onoremap <silent><buffer> <plug>(vimtex-[*) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[*)"<cr>
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#motion#find_matching_pair(...) abort " {{{1
                              if a:0 > 0
                                normal! gv
                              endif
                            
                              let delim = vimtex#delim#get_current('all', 'both')
                              if empty(delim)
                                let delim = vimtex#delim#get_next('all', 'both')
                                if empty(delim) | return | endif
                              endif
                            
                              let delim = vimtex#delim#get_matching(delim)
                              if empty(delim) | return | endif
                              if empty(delim.match) | return | endif
                            
                              " Hack to update the jump list so CTRL-o jumps back to the right place
                              normal! m`
                              call vimtex#pos#set_cursor(delim.lnum,
                                    \ (delim.is_open
                                    \   ? delim.cnum
                                    \   : delim.cnum + strlen(delim.match) - 1))
                            endfunction
                            
                            " }}}1
    1              0.000003 function! vimtex#motion#section(type, backwards, visual) abort " {{{1
                              let l:count = v:count1
                              if a:visual
                                normal! gv
                              endif
                            
                              " Hack to update the jump list so CTRL-o jumps back to the right place
                              normal! m`
                            
                              " Check trivial cases
                              let l:top = search(s:re_sec, 'nbW') == 0
                              let l:bottom = search(a:type == 1 ? s:re_sec_t2 : s:re_sec, 'nW') == 0
                              if a:backwards && l:top
                                return vimtex#pos#set_cursor([1, 1])
                              elseif !a:backwards && l:bottom
                                return vimtex#pos#set_cursor([line('$'), 1])
                              endif
                            
                              " Define search pattern and search flag
                              let l:re = a:type == 0 ? s:re_sec : s:re_sec_t1
                              let l:flags = 'W'
                              if a:backwards
                                let l:flags .= 'b'
                              endif
                            
                              for l:_ in range(l:count)
                                let l:save_pos = vimtex#pos#get_cursor()
                            
                                if a:type == 1
                                  call search('\S', 'W')
                                endif
                            
                                let l:bottom = search(s:re_sec_t2, 'nW') == 0
                                if a:type == 1 && !a:backwards && l:bottom
                                  return vimtex#pos#set_cursor([line('$'), 1])
                                endif
                            
                                let l:top = search(s:re_sec, 'ncbW') == 0
                                let l:lnum = search(l:re, l:flags)
                            
                                if l:top && l:lnum > 0 && a:type == 1 && !a:backwards
                                  let l:lnum = search(l:re, l:flags)
                                endif
                            
                                if a:type == 1
                                  call search('\S\s*\n\zs', 'Wb')
                            
                                  " Move to start of file if cursor was moved to top part of document
                                  if search(s:re_sec, 'ncbW') == 0
                                    call vimtex#pos#set_cursor([1, 1])
                                  endif
                                endif
                              endfor
                            endfunction
                            
                            " Patterns to match section/chapter/...
    1              0.000013 let s:re_sec = '\v^\s*\\%(' . join([
                                  \   '%(sub)?paragraph',
                                  \   '%(sub)*section',
                                  \   'chapter',
                                  \   'part',
                                  \   'appendi%(x|ces)',
                                  \   '%(front|back|main)matter',
                                  \   'add%(sec|chap|part)',
                                  \ ], '|') . ')>'
    1              0.000004 let s:re_sec_t1 = '\v%(' . s:re_sec . '|^\s*%(\\end\{document\}|%$))'
    1              0.000003 let s:re_sec_t2 = '\v%(' . s:re_sec . '|^\s*\\end\{document\})'
                            
                            " }}}1
    1              0.000002 function! vimtex#motion#environment(begin, backwards, visual) abort " {{{1
                              let l:count = v:count1
                              if a:visual
                                normal! gv
                              endif
                            
                              " Hack to update the jump list so CTRL-o jumps back to the right place
                              normal! m`
                            
                              let l:re = g:vimtex#re#not_comment . (a:begin ? '\\begin\s*\{' : '\\end\s*\{')
                              let l:flags = 'W' . (a:backwards ? 'b' : '')
                            
                              for l:_ in range(l:count)
                                call search(l:re, l:flags)
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#motion#frame(begin, backwards, visual) abort " {{{1
                              let l:count = v:count1
                              if a:visual
                                normal! gv
                              endif
                            
                              " Hack to update the jump list so CTRL-o jumps back to the right place
                              normal! m`
                            
                              let l:re = g:vimtex#re#not_comment . (a:begin ? '\\begin\s*\{frame\}' : '\\end\s*\{frame\}')
                              let l:flags = 'W' . (a:backwards ? 'b' : '')
                            
                              for l:_ in range(l:count)
                                call search(l:re, l:flags)
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#motion#comment(begin, backwards, visual) abort " {{{1
                              let l:count = v:count1
                              if a:visual
                                normal! gv
                              endif
                            
                              " Hack to update the jump list so CTRL-o jumps back to the right place
                              normal! m`
                            
                              let l:re = a:begin
                                    \ ? '\v%(^\s*\%.*\n)@<!\s*\%'
                                    \ : '\v^\s*\%.*\n%(^\s*\%)@!'
                              let l:flags = 'W' . (a:backwards ? 'b' : '')
                            
                              for l:_ in range(l:count)
                                call search(l:re, l:flags)
                              endfor
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#motion#math(begin, backwards, visual) abort " {{{1
                              let l:curpos_saved = vimtex#pos#get_cursor()
                              let l:count = v:count1
                              if a:visual
                                normal! gv
                              endif
                            
                              " Hack to update the jump list so CTRL-o jumps back to the right place
                              normal! m`
                            
                              " Search for math environment group delimiters
                              let l:re = g:vimtex#re#not_comment . (a:begin
                                    \ ? '%((\\\[)|(\\\()|(\\begin\s*\{)|(\$\$)|(\$))'
                                    \ : '%((\\\])|(\\\))|(\\end\s*\{)|(\$\$)|(\$))')
                            
                              " The p flag is key here and is used to specify for search to return the sub
                              " group that matches
                              let l:flags = 'Wp' . (a:backwards ? 'b' : '')
                            
                              for l:_ in range(l:count)
                                let l:success = 0
                            
                                " Iterate a maximum of 6 times to ensure we are not going into an infinite
                                " loop. The number 6 is arbitrary, but typically good enough to find the
                                " math zone in the text currently visible in the window.
                                let l:iter = 0
                                while l:iter <= 5
                                  let l:iter += 1
                                  let l:submatch = search(l:re, l:flags)
                                  let l:pos = vimtex#pos#get_cursor()
                            
                                  if l:submatch == 0 | break | endif
                            
                                  " Jump directly to \[, \], \(, \)
                                  if l:submatch < 4
                                    let l:success = 1
                                    break
                                  endif
                            
                                  if l:submatch == 4
                                    " The target position is inside a \begin ... \end delimited math
                                    " environment, where the syntax group is properly recognized on both
                                    " sides.
                                    if vimtex#syntax#in_mathzone(l:pos[1], l:pos[2])
                                      let l:success = 1
                                      break
                                    endif
                                  else
                                    " The target position is inside a $ ... $ or $$ ... $$ based math zone.
                                    " In this case, the beginning delimiter is syntax matched as a math
                                    " zone, whereas the ending delimiter is not.
                                    if a:begin
                                      if vimtex#syntax#in_mathzone(l:pos[1], l:pos[2])
                                        let l:success = 1
                                        break
                                      endif
                                    else
                                      " First check that the current search position is at least 2 columns
                                      " left from the initial position and not in mathzone already. The
                                      " check works because only opening $ and $$ are in mathzone, not
                                      " the closing ones.
                                      if vimtex#syntax#in_mathzone(l:pos[1], l:pos[2])
                                            \ || vimtex#pos#val(l:curpos_saved) - vimtex#pos#val(l:pos) == 1
                                        continue
                                      endif
                            
                                      " Now check if previous position is inside a mathzone or not
                                      let l:pos = vimtex#pos#prev(vimtex#pos#prev(l:pos))
                                      if vimtex#syntax#in_mathzone(l:pos[1], l:pos[2])
                                        let l:success = 1
                                        break
                                      endif
                                    endif
                                  endif
                                endwhile
                            
                                " If a math group delimiter is found, update the saved cursor position. If
                                " not, then we restore the last saved position and quit. This ensures that
                                " we achieve the expected behaviour with the jumps with counts.
                                if l:success
                                  let l:curpos_saved = vimtex#pos#get_cursor()
                                else
                                  call vimtex#pos#set_cursor(l:curpos_saved)
                                  break
                                endif
                              endfor
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/nvim.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#nvim#check_treesitter(...) abort " {{{1
                            lua <<EOF
                              local highlighter = require "vim.treesitter.highlighter"
                              local bufnr = vim.api.nvim_get_current_buf()
                              if vim.bo[bufnr].syntax == "" and highlighter.active[bufnr] then
                                vim.fn['vimtex#log#error'](
                                  'Syntax highlighting is controlled by Tree-sitter!'
                                )
                              end
                            EOF
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/profile.vim
Sourced 1 time
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#profile#start() abort " {{{1
                              profile start prof.log
                              profile func *
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#profile#stop() abort " {{{1
                              profile stop
                              call s:fix_sids()
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#profile#open() abort " {{{1
                              silent edit prof.log
                            endfunction
                            
                            " }}}1
    1              0.000001 function! vimtex#profile#print() abort " {{{1
                              for l:line in readfile('prof.log')
                                echo l:line
                              endfor
                              echo ''
                              quit!
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#profile#file(filename) abort " {{{1
                              call vimtex#profile#start()
                            
                              execute 'silent edit' a:filename
                            
                              call vimtex#profile#stop()
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#profile#command(cmd) abort " {{{1
                              call vimtex#profile#start()
                            
                              execute a:cmd
                            
                              call vimtex#profile#stop()
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#profile#filter(sections) abort " {{{1
                              let l:lines = readfile('prof.log')
                              " call filter(l:lines, 'v:val !~# ''FTtex''')
                              " call filter(l:lines, 'v:val !~# ''LoadFTPlugin''')
                            
                              let l:new = []
                              for l:sec in a:sections
                                call extend(l:new, s:get_section(l:sec, l:lines))
                              endfor
                            
                              call writefile(l:new, 'prof.log')
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#profile#time(...) abort " {{{1
                              let l:t1 = reltimefloat(reltime())
                            
                              if a:0 > 0
                                echo printf(
                                      \ "%s: %8.5f\n",
                                      \ a:0 > 1 ? a:2 : 'Time elapsed', l:t1 - a:1)
                              endif
                            
                              return l:t1
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:fix_sids() abort " {{{1
                              let l:lines = readfile('prof.log')
                              let l:new = []
                              for l:line in l:lines
                                let l:sid = matchstr(l:line, '\v\<SNR\>\zs\d+\ze_')
                                if !empty(l:sid)
                                  let l:filename = map(
                                        \ vimtex#util#command('scriptnames'),
                                        \ {_, x -> split(x, '\v:=\s+')[1]})[l:sid-1]
                                  if l:filename =~# 'vimtex'
                                    let l:filename = substitute(l:filename, '^.*autoload\/', '', '')
                                    let l:filename = substitute(l:filename, '\.vim$', '#s:', '')
                                    let l:filename = substitute(l:filename, '\/', '#', 'g')
                                  else
                                    let l:filename .= ':'
                                  endif
                                  call add(l:new, substitute(l:line, '\v\<SNR\>\d+_', l:filename, 'g'))
                                else
                                  call add(l:new, substitute(l:line, '\s\+$', '', ''))
                                endif
                              endfor
                              call writefile(l:new, 'prof.log')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_section(name, lines) abort " {{{1
                              let l:active = 0
                              let l:section = []
                              for l:line in a:lines
                                if l:active
                                  if l:line =~# '^FUNCTION' && l:line !~# a:name
                                    let l:active = 0
                                  else
                                    call add(l:section, l:line)
                                  endif
                                  continue
                                endif
                            
                                if l:line =~# a:name
                                  call add(l:section, l:line)
                                  let l:active = 1
                                endif
                              endfor
                            
                              if l:active
                                call add(l:section, ' ')
                              endif
                            
                              return l:section
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/scratch.vim
Sourced 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#scratch#new(opts) abort " {{{1
                              let l:buf = extend(deepcopy(s:scratch), a:opts)
                              call l:buf.open()
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000004 let s:scratch = {
                                  \ 'name' : 'VimtexScratch'
                                  \}
    1              0.000002 function! s:scratch.open() abort dict " {{{1
                              let l:bufnr = bufnr('')
                              let l:vimtex = get(b:, 'vimtex', {})
                            
                              silent execute 'keepalt edit' escape(self.name, ' ')
                            
                              let self.prev_bufnr = l:bufnr
                              let b:scratch = self
                              let b:vimtex = l:vimtex
                            
                              setlocal noreadonly
                              setlocal bufhidden=wipe
                              setlocal buftype=nofile
                              setlocal concealcursor=nvic
                              setlocal conceallevel=0
                              setlocal nobuflisted
                              setlocal nolist
                              setlocal nospell
                              setlocal noswapfile
                              setlocal nowrap
                              setlocal tabstop=8
                            
                              nnoremap <silent><buffer><nowait> q     :call b:scratch.close()<cr>
                              nnoremap <silent><buffer><nowait> <esc> :call b:scratch.close()<cr>
                              nnoremap <silent><buffer><nowait> <c-6> :call b:scratch.close()<cr>
                              nnoremap <silent><buffer><nowait> <c-^> :call b:scratch.close()<cr>
                              nnoremap <silent><buffer><nowait> <c-e> :call b:scratch.close()<cr>
                            
                              if has_key(self, 'syntax')
                                call self.syntax()
                              endif
                            
                              call self.fill()
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:scratch.close() abort dict " {{{1
                              silent execute 'keepalt buffer' self.prev_bufnr
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:scratch.fill() abort dict " {{{1
                              setlocal modifiable
                              %delete
                            
                              call self.print_content()
                            
                              0delete _
                              setlocal nomodifiable
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/text_obj.vim
Sourced 1 time
Total time:   0.000285
 Self time:   0.000285

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#text_obj#init_buffer() abort " {{{1
                              if !g:vimtex_text_obj_enabled | return | endif
                            
                              " Note: I've permitted myself long lines here to make this more readable.
                              for [l:map, l:name, l:opt] in [
                                    \ ['c', 'commands', ''],
                                    \ ['d', 'delimited', 'delims'],
                                    \ ['e', 'delimited', 'normal'],
                                    \ ['$', 'delimited', 'math'],
                                    \ ['P', 'sections', ''],
                                    \ ['m', 'items', ''],
                                    \]
                                let l:optional = empty(l:opt) ? '' : ',''' . l:opt . ''''
                                execute printf('xnoremap <silent><buffer> <plug>(vimtex-i%s) :<c-u>call vimtex#text_obj#%s(1, 1%s)<cr>', l:map, l:name, l:optional)
                                execute printf('xnoremap <silent><buffer> <plug>(vimtex-a%s) :<c-u>call vimtex#text_obj#%s(0, 1%s)<cr>', l:map, l:name, l:optional)
                                execute printf('onoremap <silent><buffer> <plug>(vimtex-i%s) :<c-u>call vimtex#text_obj#%s(1, 0%s)<cr>', l:map, l:name, l:optional)
                                execute printf('onoremap <silent><buffer> <plug>(vimtex-a%s) :<c-u>call vimtex#text_obj#%s(0, 0%s)<cr>', l:map, l:name, l:optional)
                              endfor
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#text_obj#commands(is_inner, mode) abort " {{{1
                              let l:obj = {}
                              let l:pos_save = vimtex#pos#get_cursor()
                              if a:mode
                                call vimtex#pos#set_cursor(getpos("'>"))
                              endif
                            
                              " Get the delimited text object positions
                              for l:count in range(v:count1)
                                if !empty(l:obj)
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:obj.cmd_start))
                                endif
                            
                                let l:obj_prev = l:obj
                                let l:obj = {}
                            
                                let l:cmd = vimtex#cmd#get_current()
                                if empty(l:cmd) | break | endif
                            
                                let l:pos_start = copy(l:cmd.pos_start)
                                let l:pos_end = l:cmd.pos_end
                            
                                if a:is_inner
                                  let l:pos_end.lnum = l:pos_start.lnum
                                  let l:pos_end.cnum = l:pos_start.cnum + strlen(l:cmd.name) - 1
                                  let l:pos_start.cnum += 1
                                endif
                            
                                if a:mode
                                      \ && vimtex#pos#equal(l:pos_start, getpos("'<"))
                                      \ && vimtex#pos#equal(l:pos_end, getpos("'>"))
                                  let l:pos_old = l:cmd.pos_start
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:pos_old))
                            
                                  let l:cmd = vimtex#cmd#get_current()
                                  if empty(l:cmd) | break | endif
                            
                                  if vimtex#pos#smaller(l:pos_old, l:cmd.pos_end)
                                    let l:pos_start = l:cmd.pos_start
                                    let l:pos_end = l:cmd.pos_end
                            
                                    if a:is_inner
                                      let l:pos_end.lnum = l:pos_start.lnum
                                      let l:pos_end.cnum = l:pos_start.cnum + strlen(l:cmd.name) - 1
                                      let l:pos_start.cnum += 1
                                    endif
                                  endif
                                endif
                            
                                let l:obj = {
                                      \ 'pos_start' : l:pos_start,
                                      \ 'pos_end' : l:pos_end,
                                      \ 'cmd_start' : l:cmd.pos_start,
                                      \}
                              endfor
                            
                              if empty(l:obj)
                                if empty(l:obj_prev) || g:vimtex_text_obj_variant ==# 'targets'
                                  if a:mode
                                    normal! gv
                                  else
                                    call vimtex#pos#set_cursor(l:pos_save)
                                  endif
                                  return
                                endif
                                let l:obj = l:obj_prev
                              endif
                            
                              call vimtex#pos#set_cursor(l:pos_start)
                              normal! v
                              call vimtex#pos#set_cursor(l:pos_end)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#text_obj#delimited(is_inner, mode, type) abort " {{{1
                              let l:object = {}
                              let l:prev_object = {}
                              let l:pos_save = vimtex#pos#get_cursor()
                              let l:startpos = getpos("'>")
                            
                              " Get the delimited text object positions
                              for l:count in range(v:count1)
                                if !empty(l:object)
                                  let l:pos_next = vimtex#pos#prev(
                                        \ a:is_inner ? l:object.open : l:object.pos_start)
                            
                                  if a:mode
                                    let l:startpos = l:pos_next
                                  else
                                    call vimtex#pos#set_cursor(l:pos_next)
                                  endif
                                endif
                            
                                if a:mode
                                  let l:object = s:get_sel_delimited_visual(a:is_inner, a:type, l:startpos)
                                else
                                  let [l:open, l:close] = s:get_surrounding(a:type)
                                  let l:object = empty(l:open)
                                        \ ? {} : s:get_sel_delimited(l:open, l:close, a:is_inner)
                                endif
                            
                                if empty(l:object)
                                  if !empty(l:prev_object) && g:vimtex_text_obj_variant !=# 'targets'
                                    let l:object = l:prev_object
                                    break
                                  endif
                            
                                  if a:mode
                                    normal! gv
                                  else
                                    call vimtex#pos#set_cursor(l:pos_save)
                                  endif
                                  return
                                endif
                            
                                let l:prev_object = l:object
                              endfor
                            
                              " Handle empty inner objects
                              if vimtex#pos#smaller(l:object.pos_end, l:object.pos_start)
                                if v:operator ==# 'y' && !a:mode
                                  return
                                endif
                            
                                if index(['c', 'd'], v:operator) >= 0
                                  call vimtex#pos#set_cursor(l:object.pos_start)
                                  normal! ix
                                endif
                            
                                let l:object.pos_end = l:object.pos_start
                              endif
                            
                              " Apply selection
                              execute 'normal!' l:object.select_mode
                              call vimtex#pos#set_cursor(l:object.pos_start)
                              normal! o
                              call vimtex#pos#set_cursor(l:object.pos_end)
                            
                              if &selection ==# 'exclusive'
                                normal! l
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#text_obj#sections(is_inner, mode) abort " {{{1
                              let l:pos_save = vimtex#pos#get_cursor()
                              call vimtex#pos#set_cursor(vimtex#pos#next(l:pos_save))
                            
                              " Get section border positions
                              let [l:pos_start, l:pos_end, l:type]
                                    \ = s:get_sel_sections(a:is_inner, '')
                              if empty(l:pos_start)
                                call vimtex#pos#set_cursor(l:pos_save)
                                return
                              endif
                            
                              " Increase visual area if applicable
                              if a:mode
                                    \ && visualmode() ==# 'V'
                                    \ && getpos("'<")[1] == l:pos_start[0]
                                    \ && getpos("'>")[1] == l:pos_end[0]
                                let [l:pos_start_new, l:pos_end_new, l:type]
                                      \ = s:get_sel_sections(a:is_inner, l:type)
                                if !empty(l:pos_start_new)
                                  let l:pos_start = l:pos_start_new
                                  let l:pos_end = l:pos_end_new
                                endif
                              endif
                            
                              " Repeat for count
                              for l:count in range(v:count1 - 1)
                                let [l:pos_start_new, l:pos_end_new, l:type]
                                      \ = s:get_sel_sections(a:is_inner, l:type)
                            
                                if empty(l:pos_start_new) | break | endif
                                let l:pos_start = l:pos_start_new
                                let l:pos_end = l:pos_end_new
                              endfor
                            
                              " Apply selection
                              call vimtex#pos#set_cursor(l:pos_start)
                              normal! V
                              call vimtex#pos#set_cursor(l:pos_end)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#text_obj#items(is_inner, mode) abort " {{{1
                              let l:pos_save = vimtex#pos#get_cursor()
                            
                              " Get section border positions
                              let [l:pos_start, l:pos_end] = s:get_sel_items(a:is_inner)
                              if empty(l:pos_start)
                                call vimtex#pos#set_cursor(l:pos_save)
                                return
                              endif
                            
                              " Apply selection
                              if a:is_inner
                                execute 'normal!' (v:operator ==# ':') ? visualmode() : 'v'
                              else
                                normal! V
                              endif
                              call vimtex#pos#set_cursor(l:pos_start)
                              normal! o
                              call vimtex#pos#set_cursor(l:pos_end)
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 function! s:get_sel_delimited_visual(is_inner, type, startpos) abort " {{{1
                              if a:is_inner
                                call vimtex#pos#set_cursor(vimtex#pos#next(a:startpos))
                                let [l:open, l:close] = s:get_surrounding(a:type)
                                if !empty(l:open)
                                  let l:object = s:get_sel_delimited(l:open, l:close, a:is_inner)
                            
                                  " Select next pair if we reached the same selection
                                  if (l:object.select_mode ==# 'v'
                                      \ && getpos("'<")[1:2] == l:object.pos_start
                                      \ && getpos("'>")[1:2] == l:object.pos_end)
                                      \ || (l:object.select_mode ==# 'V'
                                      \     && getpos("'<")[1] == l:object.pos_start[0]
                                      \     && getpos("'>")[1] == l:object.pos_end[0])
                                    call vimtex#pos#set_cursor(vimtex#pos#prev(l:open.lnum, l:open.cnum))
                                    let [l:open, l:close] = s:get_surrounding(a:type)
                                    if empty(l:open) | return {} | endif
                                    return s:get_sel_delimited(l:open, l:close, a:is_inner)
                                  endif
                                endif
                              endif
                            
                              call vimtex#pos#set_cursor(a:startpos)
                              let [l:open, l:close] = s:get_surrounding(a:type)
                              if empty(l:open) | return {} | endif
                              let l:object = s:get_sel_delimited(l:open, l:close, a:is_inner)
                              if a:is_inner | return l:object | endif
                            
                              " Select next pair if we reached the same selection
                              if (l:object.select_mode ==# 'v'
                                  \ && getpos("'<")[1:2] == l:object.pos_start
                                  \ && getpos("'>")[1:2] == l:object.pos_end)
                                  \ || (l:object.select_mode ==# 'V'
                                  \     && getpos("'<")[1] == l:object.pos_start[0]
                                  \     && getpos("'>")[1] == l:object.pos_end[0])
                                call vimtex#pos#set_cursor(vimtex#pos#prev(l:open.lnum, l:open.cnum))
                                let [l:open, l:close] = s:get_surrounding(a:type)
                                if empty(l:open) | return {} | endif
                                return s:get_sel_delimited(l:open, l:close, a:is_inner)
                              endif
                            
                              return l:object
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_sel_delimited(open, close, is_inner) abort " {{{1
                              " Determine if operator is linewise
                              let l:linewise = index(g:vimtex_text_obj_linewise_operators, v:operator) >= 0
                            
                              let [l1, c1, l2, c2] = [a:open.lnum, a:open.cnum, a:close.lnum, a:close.cnum]
                            
                              " Adjust the borders
                              if a:is_inner
                                if has_key(a:open, 'env_cmd') && !empty(a:open.env_cmd)
                                  let l1 = a:open.env_cmd.pos_end.lnum
                                  let c1 = a:open.env_cmd.pos_end.cnum+1
                                else
                                  let c1 += len(a:open.match)
                                endif
                                let c2 -= 1
                            
                                let l:is_inline = (l2 - l1) > 1
                                      \ && match(strpart(getline(l1),    c1), '^\s*$') >= 0
                                      \ && match(strpart(getline(l2), 0, c2), '^\s*$') >= 0
                            
                                if l:is_inline
                                  let l1 += 1
                                  let c1 = strlen(matchstr(getline(l1), '^\s*')) + 1
                                  let l2 -= 1
                                  let c2 = strlen(getline(l2))
                                  if c2 == 0 && !l:linewise
                                    let l2 -= 1
                                    let c2 = len(getline(l2)) + 1
                                  endif
                                elseif c2 == 0
                                  let l2 -= 1
                                  let c2 = len(getline(l2)) + 1
                                endif
                              else
                                let c2 += len(a:close.match) - 1
                            
                                let l:is_inline = (l2 - l1) > 1
                                      \ && match(strpart(getline(l1), 0, c1-1), '^\s*$') >= 0
                                      \ && match(strpart(getline(l2), 0, c2),   '^\s*$') >= 0
                              endif
                            
                              return {
                                    \ 'open' : a:open,
                                    \ 'close' : a:close,
                                    \ 'pos_start' : [l1, c1],
                                    \ 'pos_end' : [l2, c2],
                                    \ 'is_inline' : l:is_inline,
                                    \ 'select_mode' : l:is_inline && l:linewise
                                    \      ? 'V' : (v:operator ==# ':') ? visualmode() : 'v',
                                    \}
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_sel_sections(is_inner, type) abort " {{{1
                              let l:pos_save = vimtex#pos#get_cursor()
                              let l:min_val = get(s:section_to_val, a:type)
                            
                              " Get the position of the section start
                              while 1
                                let l:pos_start = searchpos(s:section_search, 'bcnW')
                                if l:pos_start == [0, 0] | return [[], [], ''] | endif
                            
                                let l:sec_type = matchstr(getline(l:pos_start[0]), s:section_search)
                                let l:sec_val = s:section_to_val[l:sec_type]
                            
                                if !empty(a:type)
                                  if l:sec_val >= l:min_val
                                    call vimtex#pos#set_cursor(vimtex#pos#prev(l:pos_start))
                                  else
                                    call vimtex#pos#set_cursor(l:pos_save)
                                    break
                                  endif
                                else
                                  break
                                endif
                              endwhile
                            
                              " Get the position of the section end
                              while 1
                                let l:pos_end = searchpos(s:section_search, 'nW')
                                if l:pos_end == [0, 0]
                                  let l:pos_end = [line('$')+1, 1]
                                  break
                                endif
                            
                                let l:cur_val = s:section_to_val[
                                      \ matchstr(getline(l:pos_end[0]), s:section_search)]
                                if l:cur_val <= l:sec_val
                                  let l:pos_end[0] -= 1
                                  break
                                endif
                            
                                call vimtex#pos#set_cursor(l:pos_end)
                              endwhile
                            
                              " Adjust for inner text object
                              if a:is_inner
                                call vimtex#pos#set_cursor(l:pos_start[0]+1, l:pos_start[1])
                                let l:pos_start = searchpos('\S', 'cnW')
                                call vimtex#pos#set_cursor(l:pos_end)
                                let l:pos_end = searchpos('\S', 'bcnW')
                              elseif l:sec_val ==# 'document'
                                let l:pos_start = [l:pos_start[0]+1, l:pos_start[1]]
                              endif
                            
                              return [l:pos_start, l:pos_end, l:sec_type]
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:get_sel_items(is_inner) abort " {{{1
                              let l:pos_cursor = vimtex#pos#get_cursor()
                              let l:val_cursor = vimtex#pos#val(l:pos_cursor)
                            
                              " Find previous \item
                              let l:depth = 0
                              let l:pos_cur = vimtex#pos#next(l:pos_cursor)
                              while 1
                                call vimtex#pos#set_cursor(vimtex#pos#prev(l:pos_cur))
                                if l:depth > 5 | return [[], []] | endif
                            
                                let l:pos_start = searchpos(
                                      \ l:depth > 0 ? '\\begin{\w\+}' : '^\s*\\item\S*',
                                      \ 'bcnW')
                                let l:val_start = vimtex#pos#val(l:pos_start)
                                if l:val_start == 0 | return [[], []] | endif
                            
                                let l:pos_endenv = searchpos('\%(^\s*\)\?\\end{\w\+}', 'bcnW')
                                let l:val_endenv = vimtex#pos#val(l:pos_endenv)
                            
                                if l:val_endenv == 0 || l:val_start > l:val_endenv
                                  if l:depth == 0 | break | endif
                                  let l:pos_cur = l:pos_start
                                  let l:depth -= 1
                                else
                                  let l:pos_cur = l:pos_endenv
                                  let l:depth += 1
                                endif
                              endwhile
                            
                              " Find end of current \item
                              let l:depth = 0
                              let l:pos_cur = l:pos_start
                              while 1
                                call vimtex#pos#set_cursor(vimtex#pos#next(l:pos_cur))
                            
                                let l:re = l:depth > 0
                                      \ ? '\\end{\w\+}'
                                      \ : '\n\s*\%(\\item\|\\end{\(itemize\|enumerate\)}\)'
                                let l:pos_end = searchpos(l:re, 'nW')
                                let l:val_end = vimtex#pos#val(l:pos_end)
                                if l:depth == 0 && l:val_end == 0
                                  return [[], []]
                                endif
                            
                                let l:pos_beginenv = searchpos('\\begin{\w\+}', 'cnW')
                                let l:val_beginenv = vimtex#pos#val(l:pos_beginenv)
                            
                                if l:val_beginenv == 0 || l:val_end < l:val_beginenv
                                  if l:depth == 0 | break | endif
                                  let l:pos_cur = l:pos_end
                                  let l:depth -= 1
                                else
                                  let l:pos_cur = l:pos_beginenv
                                  let l:depth += 1
                                endif
                              endwhile
                            
                              " The region must include the cursor
                              if l:val_cursor > l:val_end
                                return [[], []]
                              endif
                            
                              " Adjust for outer text object
                              if a:is_inner
                                let l:pos_start[1] = searchpos('^\s*\\item\S*\s', 'cne')[1] + 1
                                let l:pos_end[1] = col([l:pos_end[0], '$']) - 1
                              endif
                            
                              return [l:pos_start, l:pos_end]
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:get_surrounding(type) abort " {{{1
                              if a:type ==# 'delims'
                                return vimtex#delim#get_surrounding('delim_all')
                              else
                                return vimtex#env#get_surrounding(a:type)
                              endif
                            endfunction
                            
                            " }}}1
                            
                            
                            " {{{1 Initialize module
                            
                            " Pattern to match section/chapter/...
    1              0.000015 let s:section_search = '\v%(%(\\@<!%(\\\\)*)@<=\%.*)@<!\s*\\\zs('
                                  \ . join([
                                  \   '%(sub)?paragraph>',
                                  \   '%(sub)*section>',
                                  \   'chapter>',
                                  \   'part>',
                                  \   'appendix>',
                                  \   '%(front|back|main)matter>',
                                  \   'add%(sec|chap|part)>',
                                  \   '%(begin|end)\{\zsdocument\ze\}'
                                  \  ], '|')
                                  \ .')'
                            
                            " Dictionary to give values to sections in order to compare them
    1              0.000021 let s:section_to_val = {
                                  \ 'document':        0,
                                  \ 'frontmatter':     1,
                                  \ 'mainmatter':      1,
                                  \ 'appendix':        1,
                                  \ 'backmatter':      1,
                                  \ 'part':            1,
                                  \ 'addpart':         1,
                                  \ 'chapter':         2,
                                  \ 'addchap':         2,
                                  \ 'section':         3,
                                  \ 'addsec':          3,
                                  \ 'subsection':      4,
                                  \ 'subsubsection':   5,
                                  \ 'paragraph':       6,
                                  \ 'subparagraph':    7,
                                  \}
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/ui.vim
Sourced 1 time
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000002 function! vimtex#ui#echo(input, ...) abort " {{{1
                              if empty(a:input) | return | endif
                              let l:opts = extend({'indent': 0}, a:0 > 0 ? a:1 : {})
                            
                              if type(a:input) == v:t_string
                                call s:echo_string(a:input, l:opts)
                              elseif type(a:input) == v:t_list
                                call s:echo_formatted(a:input, l:opts)
                              elseif type(a:input) == v:t_dict
                                call s:echo_dict(a:input, l:opts)
                              else
                                call vimtex#log#warn('Argument not supported: ' . type(a:input))
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#ui#confirm(prompt) abort " {{{1
                              return vimtex#ui#{g:vimtex_ui_method.confirm}#confirm(a:prompt)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#ui#input(options) abort " {{{1
                              let l:options = extend({
                                    \ 'prompt': '> ',
                                    \ 'text': '',
                                    \ 'info': '',
                                    \}, a:options)
                            
                              return vimtex#ui#{g:vimtex_ui_method.input}#input(l:options)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#ui#menu(actions) abort " {{{1
                              " Argument: The 'actions' argument is a dictionary/object which contains
                              "   a list of menu items and corresponding actions (dict functions).
                              "   Something like this:
                              "
                              "   let a:actions = {
                              "         \ 'prompt': 'Prompt string for menu',
                              "         \ 'menu': [
                              "         \   {'name': 'My first action',
                              "         \    'func': 'action1'},
                              "         \   {'name': 'My second action',
                              "         \    'func': 'action2'},
                              "         \   ...
                              "         \ ],
                              "         \ 'action1': Func,
                              "         \ 'action2': Func,
                              "         \ ...
                              "         \}
                              if empty(a:actions) | return | endif
                            
                              let l:choice = vimtex#ui#select(a:actions.menu, {
                                    \ 'prompt': a:actions.prompt,
                                    \})
                              if empty(l:choice) | return | endif
                            
                              try
                                call a:actions[l:choice.func]()
                              catch
                                " error here
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#ui#select(container, ...) abort " {{{1
                              let l:options = extend(
                                    \ {
                                    \   'prompt': 'Please choose item:',
                                    \   'return': 'value',
                                    \   'force_choice': v:false,
                                    \   'auto_select': v:true,
                                    \ },
                                    \ a:0 > 0 ? a:1 : {})
                            
                              let l:list = type(a:container) == v:t_dict
                                    \ ? values(a:container)
                                    \ : a:container
                              let [l:index, l:value] = empty(l:list)
                                    \ ? [-1, '']
                                    \ : (len(l:list) == 1 && l:options.auto_select
                                    \   ? [0, l:list[0]]
                                    \   : vimtex#ui#{g:vimtex_ui_method.select}#select(l:options, l:list))
                            
                              if l:options.return ==# 'value'
                                return l:value
                              endif
                            
                              if type(a:container) == v:t_dict
                                return l:index >= 0 ? keys(a:container)[l:index] : ''
                              endif
                            
                              return l:index
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 function! vimtex#ui#get_number(max, digits, force_choice, do_echo) abort " {{{1
                              let l:choice = ''
                            
                              if a:do_echo
                                echo '> '
                              endif
                            
                              while len(l:choice) < a:digits
                                if len(l:choice) > 0 && (l:choice . '0') > a:max
                                  return l:choice - 1
                                endif
                            
                                let l:input = nr2char(getchar())
                            
                                if !a:force_choice && index(["\<C-c>", "\<Esc>", 'x'], l:input) >= 0
                                  if a:do_echo
                                    echon 'aborted!'
                                  endif
                                  return -2
                                endif
                            
                                if len(l:choice) > 0 && l:input ==# "\<cr>"
                                  return l:choice - 1
                                endif
                            
                                if l:input !~# '\d' | continue | endif
                            
                                if (l:choice . l:input) > 0
                                  let l:choice .= l:input
                                  if a:do_echo
                                    echon l:input
                                  endif
                                endif
                              endwhile
                            
                              return l:choice - 1
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! vimtex#ui#get_winwidth() abort " {{{1
                              let l:numwidth = (&number || &relativenumber)
                                    \ ? max([&numberwidth, strlen(line('$')) + 1])
                                    \ : 0
                              let l:foldwidth = str2nr(matchstr(&foldcolumn, '\d\+$'))
                            
                              " Get width of signcolumn
                              " Note: A signcolumn is 2-char wide, so in some cases we multiply by 2
                              if &signcolumn ==# 'yes'
                                let l:signwidth = 2
                              elseif &signcolumn =~# 'yes'
                                let l:signwidth = 2*split(&signcolumn, ':')[1]
                              elseif &signcolumn ==# 'auto'
                                let l:signlist = split(execute(
                                      \ printf('sign place %s buffer=%d',
                                      \   has('nvim-0.4.2') || has('patch-8.1.614') ? 'group=*' : '',
                                      \   bufnr())), "\n")
                                let l:signwidth = len(l:signlist) > 2 ? 2 : 0
                              elseif &signcolumn =~# 'auto'
                                " Get number of signs on each line that has a sign
                                let l:sign_lenths = map(
                                      \ sign_getplaced(bufnr(), {'group': '*'})[0].signs,
                                      \ { _, x -> len(
                                      \   sign_getplaced(bufnr(),
                                      \                  {'group': '*', 'lnum': x.lnum})[0].signs)})
                                let l:signwidth = 2*max(l:sign_lenths)
                              else
                                let l:signwidth = 0
                              endif
                            
                              return winwidth(0) - l:numwidth - l:foldwidth - l:signwidth
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:echo_string(msg, opts) abort " {{{1
                              echohl VimtexMsg
                              echo repeat(' ', a:opts.indent) . a:msg
                              echohl None
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:echo_formatted(parts, opts) abort " {{{1
                              echo repeat(' ', a:opts.indent)
                              try
                                for l:part in a:parts
                                  if type(l:part) == v:t_string
                                    echohl VimtexMsg
                                    echon l:part
                                  else
                                    execute 'echohl' l:part[0]
                                    echon l:part[1]
                                  endif
                                  unlet l:part
                                endfor
                              finally
                                echohl None
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:echo_dict(dict, opts) abort " {{{1
                              for [l:key, l:val] in items(a:dict)
                                call s:echo_formatted([['Label', l:key . ': '], l:val], a:opts)
                              endfor
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/text_obj/targets.vim
Sourced 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000003 function! vimtex#text_obj#targets#enabled() abort " {{{1
                              return exists('g:loaded_targets')
                                    \ && (   (type(g:loaded_targets) == v:t_number && g:loaded_targets)
                                    \     || (type(g:loaded_targets) == v:t_string && !empty(g:loaded_targets)))
                                    \ && (   g:vimtex_text_obj_variant ==# 'auto'
                                    \     || g:vimtex_text_obj_variant ==# 'targets')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#text_obj#targets#init() abort " {{{1
                              let g:vimtex_text_obj_variant = 'targets'
                            
                              " Create intermediate mappings
                              omap <expr> <plug>(vimtex-targets-i) targets#e('o', 'i', 'i')
                              xmap <expr> <plug>(vimtex-targets-i) targets#e('x', 'i', 'i')
                              omap <expr> <plug>(vimtex-targets-a) targets#e('o', 'a', 'a')
                              xmap <expr> <plug>(vimtex-targets-a) targets#e('x', 'a', 'a')
                            
                              augroup vimtex_targets
                                autocmd!
                                autocmd User targets#sources         call s:init_sources()
                                autocmd User targets#mappings#plugin call s:init_mappings()
                              augroup END
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:init_mappings() abort " {{{1
                              call targets#mappings#extend({'e': {'tex_env': [{}]}})
                              call targets#mappings#extend({'c': {'tex_cmd': [{}]}})
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:init_sources() abort " {{{1
                              call targets#sources#register('tex_env', function('vimtex#text_obj#envtargets#new'))
                              call targets#sources#register('tex_cmd', function('vimtex#text_obj#cmdtargets#new'))
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/after/ftplugin/tex.vim
Sourced 1 time
Total time:   0.000394
 Self time:   0.000250

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000004 if !get(g:, 'vimtex_enabled', 1)
                              finish
    1              0.000001 endif
                            
    1              0.000003 if exists('b:did_ftplugin_vimtex')
                              finish
    1              0.000001 endif
    1              0.000002 let b:did_ftplugin_vimtex = 1
                            
                            " Check for plugin clashes.
                            " Note: This duplicates the code in health/vimtex.vim:s:check_plugin_clash()
    1   0.000152   0.000008 let s:scriptnames = vimtex#util#command('scriptnames')
                            
    1              0.000215 let s:latexbox = !empty(filter(copy(s:scriptnames), "v:val =~# 'latex-box'"))
    1              0.000001 if s:latexbox
                              call vimtex#log#warning([
                                    \ 'Conflicting plugin detected: LaTeX-Box',
                                    \ 'VimTeX does not work as expected when LaTeX-Box is installed!',
                                    \ 'Please disable or remove it to use VimTeX!',
                                    \])
    1              0.000001 endif

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/indent/tex.vim
Sourced 1 time
Total time:   0.000344
 Self time:   0.000340

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000003 if exists('b:did_indent')
                              finish
    1              0.000001 endif
                            
    1   0.000009   0.000006 call vimtex#options#init()
                            
    1              0.000003 if !g:vimtex_indent_enabled | finish | endif
                            
    1              0.000002 let b:did_vimtex_indent = 1
    1              0.000002 let b:did_indent = 1
                            
    1              0.000003 let s:cpo_save = &cpoptions
    1              0.000006 set cpoptions&vim
                            
    1              0.000004 setlocal autoindent
    1              0.000003 setlocal indentexpr=VimtexIndentExpr()
    1              0.000003 setlocal indentkeys=!^F,o,O,0(,0),],},\&,0=\\item\ ,0=\\item[,0=\\else,0=\\fi
                            
                            " Add standard closing math delimiters to indentkeys
    8              0.000013 for s:delim in [
                                  \ 'rangle', 'rbrace', 'rvert', 'rVert', 'rfloor', 'rceil', 'urcorner']
    7              0.000025   let &l:indentkeys .= ',0=\' . s:delim
    8              0.000005 endfor
                            
                            
    1              0.000002 function! VimtexIndentExpr() abort " {{{1
                              " This wrapper function is used because of rnoweb[0] that "misuses" the
                              " indentexpr and assumes it takes no arguments.
                              "
                              " [0]: /usr/share/nvim/runtime/indent/rnoweb.vim:21
                            
                              return VimtexIndent(v:lnum)
                            endfunction
                            
                            "}}}
    1              0.000002 function! VimtexIndent(lnum) abort " {{{1
                              let s:sw = shiftwidth()
                            
                              let [l:prev_lnum, l:prev_line] = s:get_prev_lnum(prevnonblank(a:lnum - 1))
                              if l:prev_lnum == 0 | return indent(a:lnum) | endif
                              let l:line = s:clean_line(getline(a:lnum))
                            
                              " Check for verbatim modes
                              if s:in_verbatim(a:lnum)
                                return empty(l:line) ? indent(l:prev_lnum) : indent(a:lnum)
                              endif
                            
                              " Use previous indentation for comments
                              if l:line =~# '^\s*%'
                                return indent(a:lnum)
                              endif
                            
                              " Align on ampersands
                              let l:ind = s:indent_amps.check(a:lnum, l:line, l:prev_lnum, l:prev_line)
                              if s:indent_amps.finished | return l:ind | endif
                              let l:prev_lnum = s:indent_amps.prev_lnum
                              let l:prev_line = s:indent_amps.prev_line
                            
                              " Indent environments, delimiters, and conditionals
                              let l:ind += s:indent_envs(l:line, l:prev_line)
                              let l:ind += s:indent_items(l:line, a:lnum, l:prev_line, l:prev_lnum)
                              let l:ind += s:indent_delims(l:line, a:lnum, l:prev_line, l:prev_lnum)
                              let l:ind += s:indent_conditionals(l:line, a:lnum, l:prev_line, l:prev_lnum)
                            
                              " Indent tikz commands
                              if g:vimtex_indent_tikz_commands
                                let l:ind += s:indent_tikz(l:prev_lnum, l:prev_line)
                              endif
                            
                              return l:ind < 0 ? 0 : l:ind
                            endfunction
                            
                            "}}}
                            
    1              0.000002 function! s:get_prev_lnum(lnum) abort " {{{1
                              let l:lnum = a:lnum
                              let l:line = getline(l:lnum)
                            
                              while l:lnum > 0 && (l:line =~# '^\s*%' || s:in_verbatim(l:lnum))
                                let l:lnum = prevnonblank(l:lnum - 1)
                                let l:line = getline(l:lnum)
                              endwhile
                            
                              return [
                                    \ l:lnum,
                                    \ l:lnum > 0 ? s:clean_line(l:line) : '',
                                    \]
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:clean_line(line) abort " {{{1
                              return substitute(a:line, '\s*\\\@<!%.*', '', '')
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:in_verbatim(lnum) abort " {{{1
                              let l:synstack = vimtex#syntax#stack(a:lnum, col([a:lnum, '$']) - 2)
                            
                              return match(l:synstack, '\v^tex%(Lst|Verb|Markdown|Minted)Zone') >= 0
                                    \ && match(l:synstack, '\v^tex%(Minted)?Env') < 0
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 let s:indent_amps = {}
    1              0.000003 function! s:indent_amps.check(lnum, cline, plnum, pline) abort dict " {{{1
                              let self.finished = 0
                              let self.amp_ind = -1
                              let self.init_ind = -1
                              let self.prev_lnum = a:plnum
                              let self.prev_line = a:pline
                              let self.prev_ind = a:plnum > 0 ? indent(a:plnum) : 0
                              if !g:vimtex_indent_on_ampersands | return self.prev_ind | endif
                            
                              if a:cline =~# s:re_align
                                    \ || a:cline =~# s:re_amp
                                    \ || a:cline =~# '^\v\s*\\%(end|])'
                                call self.parse_context(a:lnum, a:cline)
                              endif
                            
                              if a:cline =~# s:re_align
                                let self.finished = 1
                                let l:ind_diff =
                                      \   strdisplaywidth(strpart(a:cline, 0, match(a:cline, s:re_amp)))
                                      \ - strdisplaywidth(strpart(a:cline, 0, match(a:cline, '\S')))
                                return self.amp_ind - l:ind_diff
                              endif
                            
                              if self.amp_ind >= 0
                                    \ && (a:cline =~# '^\v\s*\\%(end|])' || a:cline =~# s:re_amp)
                                let self.prev_lnum = self.init_lnum
                                let self.prev_line = self.init_line
                                return self.init_ind
                              endif
                            
                              return self.prev_ind
                            endfunction
                            
    1              0.000003 let s:re_amp = g:vimtex#re#not_bslash . '\&'
    1              0.000002 let s:re_align = '^[ \t\\]*' . s:re_amp
                            
                            " }}}1
    1              0.000003 function! s:indent_amps.parse_context(lnum, line) abort dict " {{{1
                              let l:depth = 1
                              let l:lnum = prevnonblank(a:lnum - 1)
                            
                              while l:lnum >= 1
                                let l:line = getline(l:lnum)
                            
                                if l:line =~# s:re_depth_end
                                  let l:depth += 1
                                endif
                            
                                if l:line =~# s:re_depth_beg
                                  let l:depth -= 1
                                  if l:depth == 0
                                    let self.init_lnum = l:lnum
                                    let self.init_line = l:line
                                    let self.init_ind = indent(l:lnum)
                                    break
                                  endif
                                endif
                            
                                if l:depth == 1 && l:line =~# s:re_amp
                                  if self.amp_ind < 0
                                    let self.amp_ind = strdisplaywidth(
                                          \ strpart(l:line, 0, match(l:line, s:re_amp)))
                                  endif
                                  if l:line !~# s:re_align
                                    let self.init_lnum = l:lnum
                                    let self.init_line = l:line
                                    let self.init_ind = indent(l:lnum)
                                    break
                                  endif
                                endif
                            
                                let l:lnum = prevnonblank(l:lnum - 1)
                              endwhile
                            endfunction
                            
    1              0.000003 let s:re_depth_beg = g:vimtex#re#not_bslash . '\\%(begin\s*\{|[|\w+\{\s*$)'
    1              0.000003 let s:re_depth_end = g:vimtex#re#not_bslash . '\\end\s*\{\w+\*?}|^\s*%(}|\\])'
                            
                            " }}}1
                            
    1              0.000002 function! s:indent_envs(line, prev_line) abort " {{{1
                              let l:ind = 0
                            
                              let l:ind += s:sw*(
                                    \    a:prev_line =~# s:envs_begin
                                    \ && a:prev_line !~# s:envs_end
                                    \ && a:prev_line !~# s:envs_ignored)
                              let l:ind -= s:sw*(
                                    \    a:line !~# s:envs_begin
                                    \ && a:line =~# s:envs_end
                                    \ && a:line !~# s:envs_ignored)
                            
                              return l:ind
                            endfunction
                            
    1              0.000002 let s:envs_begin = '\\begin{.*}\|\\\@<!\\\['
    1              0.000002 let s:envs_end = '\\end{.*}\|\\\]'
    1              0.000006 let s:envs_ignored = '\v<%(' . join(g:vimtex_indent_ignored_envs, '|') . ')>'
                            
                            " }}}1
    1              0.000002 function! s:indent_items(line, lnum, prev_line, prev_lnum) abort " {{{1
                              if a:prev_line =~# s:envs_item
                                    \ && (a:line !~# s:envs_enditem
                                    \     || (a:line =~# s:envs_item && a:prev_line =~# s:envs_beglist))
                                return s:sw
                              elseif a:line =~# s:envs_endlist && a:prev_line !~# s:envs_begitem
                                return -s:sw
                              elseif a:line =~# s:envs_item && a:prev_line !~# s:envs_item
                                let l:prev_lnum = a:prev_lnum
                                let l:prev_line = a:prev_line
                                while l:prev_lnum >= 1
                                  if l:prev_line =~# s:envs_begitem
                                    return -s:sw*(l:prev_line =~# s:envs_item)
                                  endif
                                  let l:prev_lnum = prevnonblank(l:prev_lnum - 1)
                                  let l:prev_line = getline(l:prev_lnum)
                                endwhile
                              endif
                            
                              return 0
                            endfunction
                            
    1              0.000004 let s:envs_lists = join(g:vimtex_indent_lists, '\|')
    1              0.000002 let s:envs_item = '^\s*\\item\>'
    1              0.000003 let s:envs_beglist = '\\begin{\%(' . s:envs_lists . '\)'
    1              0.000003 let s:envs_endlist =   '\\end{\%(' . s:envs_lists . '\)'
    1              0.000003 let s:envs_begitem = s:envs_item . '\|' . s:envs_beglist
    1              0.000003 let s:envs_enditem = s:envs_item . '\|' . s:envs_endlist
                            
                            " }}}1
    1              0.000003 function! s:indent_delims(line, lnum, prev_line, prev_lnum) abort " {{{1
                              if s:re_delim_trivial | return 0 | endif
                            
                              if s:re_opt.close_indented
                                return s:sw*(vimtex#util#count(a:prev_line, s:re_open)
                                      \ - vimtex#util#count(a:prev_line, s:re_close))
                              else
                                return s:sw*(vimtex#util#count_open(a:prev_line, s:re_open, s:re_close)
                                      \      - vimtex#util#count_close(a:line, s:re_open, s:re_close))
                              endif
                            endfunction
                            
    1              0.000013 let s:re_opt = extend({
                                  \ 'open' : ['{'],
                                  \ 'close' : ['}'],
                                  \ 'close_indented' : 0,
                                  \ 'include_modified_math' : 1,
                                  \}, g:vimtex_indent_delims)
    1              0.000004 let s:re_open = join(s:re_opt.open, '\|')
    1              0.000003 let s:re_close = join(s:re_opt.close, '\|')
    1              0.000002 if s:re_opt.include_modified_math
    1              0.000007   let s:re_open .= (empty(s:re_open) ? '' : '\|') . g:vimtex#delim#re.delim_mod_math.open
    1              0.000005   let s:re_close .= (empty(s:re_close) ? '' : '\|') . g:vimtex#delim#re.delim_mod_math.close
    1              0.000001 endif
    1              0.000004 let s:re_delim_trivial = empty(s:re_open) || empty(s:re_close)
                            
                            " }}}1
    1              0.000003 function! s:indent_conditionals(line, lnum, prev_line, prev_lnum) abort " {{{1
                              if empty(s:conditionals) | return 0 | endif
                            
                              let l:ind = s:sw*(
                                    \    (a:prev_line =~# s:conditionals.open
                                    \     || a:prev_line =~# s:conditionals.else)
                                    \ && a:prev_line !~# s:conditionals.close)
                              let l:ind -= s:sw*(
                                    \    a:line !~# s:conditionals.open
                                    \ && (a:line =~# s:conditionals.close
                                    \     || a:line =~# s:conditionals.else))
                            
                              return l:ind
                            endfunction
                            
    1              0.000002 let s:conditionals = g:vimtex_indent_conditionals
                            
                            " }}}1
    1              0.000002 function! s:indent_tikz(lnum, prev) abort " {{{1
                              if !has_key(b:vimtex.packages, 'tikz') | return 0 | endif
                            
                              let l:synstack = vimtex#syntax#stack(a:lnum, 1)
                              if match(l:synstack, '^texTikzZone') < 0 | return 0 | endif
                            
                              let l:env_lnum = search('\\begin\s*{tikzpicture\*\?}', 'bn')
                              if l:env_lnum > 0 && l:env_lnum < a:lnum
                                let l:prev_starts = a:prev =~# s:tikz_commands
                                let l:prev_stops  = a:prev =~# ';\s*$'
                            
                                " Increase indent on tikz command start
                                if l:prev_starts && ! l:prev_stops
                                  return s:sw
                                endif
                            
                                " Decrease indent on tikz command end, i.e. on semicolon
                                if ! l:prev_starts && l:prev_stops
                                  let l:context = join(getline(l:env_lnum, a:lnum-1), '')
                                  return -s:sw*(l:context =~# s:tikz_commands)
                                endif
                              endif
                            
                              return 0
                            endfunction
                            
    1              0.000010 let s:tikz_commands = '\v\\%(' . join([
                                    \ 'draw',
                                    \ 'fill',
                                    \ 'path',
                                    \ 'node',
                                    \ 'coordinate',
                                    \ 'clip',
                                    \ 'add%(legendentry|plot)',
                                  \ ], '|') . ')'
                            
                            " }}}1
                            
    1              0.000004 let &cpoptions = s:cpo_save
    1              0.000002 unlet s:cpo_save

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/jobs/neovim.vim
Sourced 1 time
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000003 function! vimtex#jobs#neovim#new(cmd) abort " {{{1
                              let l:job = deepcopy(s:job)
                              let l:job.cmd = has('win32')
                                    \ ? 'cmd /s /c "' . a:cmd . '"'
                                    \ : ['sh', '-c', a:cmd]
                              return l:job
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#jobs#neovim#run(cmd) abort " {{{1
                              call s:neovim_{s:os}_run(a:cmd)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#jobs#neovim#capture(cmd) abort " {{{1
                              return s:neovim_{s:os}_capture(a:cmd)
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! vimtex#jobs#neovim#shell_default() abort " {{{1
                              let s:saveshell = [&shell, &shellcmdflag, &shellslash]
                              let &shell = 'cmd.exe'
                              let &shellcmdflag = '/s /c'
                              set shellslash&
                            endfunction
                            
                            " }}}1
    1              0.000002 function! vimtex#jobs#neovim#shell_restore() abort " {{{1
                              let [&shell, &shellcmdflag, &shellslash] = s:saveshell
                            endfunction
                            
                            " }}}1
                            
    1              0.000004 let s:os = has('win32') ? 'win' : 'unix'
                            
                            
    1              0.000002 let s:job = {}
                            
    1              0.000002 function! s:job.start() abort dict " {{{1
                              let l:options = {}
                            
                              if self.capture_output
                                let self._output = []
                                let l:options.on_stdout = function('s:__callback')
                                let l:options.on_stderr = function('s:__callback')
                                let l:options.stdout_buffered = v:true
                                let l:options.stderr_buffered = v:true
                                let l:options.output = self._output
                              endif
                              if self.detached
                                let l:options.detach = v:true
                              endif
                              if !empty(self.cwd)
                                let l:options.cwd = self.cwd
                              endif
                            
                              call vimtex#jobs#neovim#shell_default()
                              let self.job = jobstart(self.cmd, l:options)
                              call vimtex#jobs#neovim#shell_restore()
                            
                              return self
                            endfunction
                            
    1              0.000015 function! s:__callback(id, data, event) abort dict
                              call extend(self.output, a:data)
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:job.stop() abort dict " {{{1
                              call jobstop(self.job)
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:job.wait() abort dict " {{{1
                              let l:retvals = jobwait([self.job], self.wait_timeout)
                              if empty(l:retvals) | return | endif
                              let l:status = l:retvals[0]
                              if l:status >= 0 | return | endif
                            
                              if l:status == -1
                                call vimtex#log#warning('Job timed out while waiting!', join(self.cmd))
                                call self.stop()
                              elseif l:status == -2
                                call vimtex#log#warning('Job interrupted!', self.cmd)
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:job.is_running() abort dict " {{{1
                              try
                                let l:pid = jobpid(self.job)
                                return l:pid > 0
                              catch
                                return v:false
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:job.get_pid() abort dict " {{{1
                              try
                                return jobpid(self.job)
                              catch
                                return 0
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:job.signal_hup() abort dict " {{{1
                              let l:pid = self.get_pid()
                              if l:pid > 0
                                call system(['kill', '-HUP', l:pid])
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000001 function! s:job.output() abort dict " {{{1
                              call self.wait()
                            
                              if !self.capture_output | return [] | endif
                            
                              " Trim output
                              while len(self._output) > 0
                                if !empty(self._output[0]) | break | endif
                                call remove(self._output, 0)
                              endwhile
                              while len(self._output) > 0
                                if !empty(self._output[-1]) | break | endif
                                call remove(self._output, -1)
                              endwhile
                            
                              return self._output
                            endfunction
                            
                            " }}}1
                            
    1              0.000001 function! s:job.__pprint() abort dict " {{{1
                              let l:pid = self.get_pid()
                            
                              return [
                                    \ ['pid', l:pid ? l:pid : '-'],
                                    \ ['cmd', self.cmd_raw],
                                    \]
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000002 function! s:neovim_unix_run(cmd) abort " {{{1
                              call system(['sh', '-c', a:cmd])
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:neovim_unix_capture(cmd) abort " {{{1
                              return systemlist(['sh', '-c', a:cmd])
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:neovim_win_run(cmd) abort " {{{1
                              call vimtex#jobs#neovim#shell_default()
                              call system('cmd /s /c "' . a:cmd . '"')
                              call vimtex#jobs#neovim#shell_restore()
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:neovim_win_capture(cmd) abort " {{{1
                              call vimtex#jobs#neovim#shell_default()
                              let l:output = systemlist('cmd /s /c "' . a:cmd . '"')
                              call vimtex#jobs#neovim#shell_restore()
                            
                              return l:output
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/syntax/packages.vim
Sourced 1 time
Total time:   0.000626
 Self time:   0.000533

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000003 function! vimtex#syntax#packages#init() abort " {{{1
                              if !exists('b:vimtex') || !exists('b:vimtex_syntax') | return | endif
                            
                              " Initialize project cache (used e.g. for the minted package)
                              if !has_key(b:vimtex, 'syntax')
                                let b:vimtex.syntax = {}
                              endif
                            
                              call s:register_packages()
                            
                              let l:loaded = 0
                              for [l:pkg, l:cfg] in items(b:vimtex_syntax)
                                if !l:cfg.__load || l:cfg.__loaded | continue | endif
                            
                                call vimtex#syntax#p#{l:pkg}#load(l:cfg)
                                let l:cfg.__loaded = 1
                                let l:loaded += 1
                              endfor
                            
                              if l:loaded > 0
                                call vimtex#syntax#core#init_custom()
                              endif
                            endfunction
                            
                            " }}}1
    1              0.000003 function! vimtex#syntax#packages#load(pkg) abort " {{{1
                              let l:cfg = get(b:vimtex_syntax, a:pkg, {})
                              if empty(l:cfg) || l:cfg.__loaded | return | endif
                            
                              call vimtex#syntax#p#{a:pkg}#load(l:cfg)
                              let l:cfg.__loaded = 1
                            endfunction
                            
                            " }}}1
                            
    1              0.000002 function! s:register_packages() abort " {{{1
                              let l:packages = map(
                                    \ keys(b:vimtex.packages) + [b:vimtex.documentclass],
                                    \ {_, x -> tolower(substitute(x, '-', '_', 'g'))})
                            
                              for l:pkg in s:addons
                                if empty(l:pkg) | continue | endif
                            
                                " Register "state" for package in current buffer
                                if !has_key(b:vimtex_syntax, l:pkg)
                                  let b:vimtex_syntax[l:pkg] = extend({
                                        \ 'load': 1,
                                        \ '__load': 0,
                                        \ '__loaded': 0,
                                        \}, get(g:vimtex_syntax_packages, l:pkg, {}))
                                endif
                                let l:cfg = b:vimtex_syntax[l:pkg]
                            
                                let l:cfg.__load =
                                      \    l:cfg.load > 1
                                      \ || (l:cfg.load == 1 && index(l:packages, l:pkg) >= 0)
                              endfor
                            endfunction
                            
    1   0.000577   0.000484 let s:addons = map(
                                  \ glob(expand('<sfile>:h') . '/p/*.vim', 0, 1),
                                  \ { _, x -> fnamemodify(x, ':t:r') })
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/u.vim
Sourced 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000003 function! vimtex#qf#u#caddfile(qf, file) abort " {{{1
                              " This is a utility function for loading errors from a file into the quickfix
                              " window with ":caddfile" without calling possibly defined QuickFixCmdPost
                              " autotocmds e.g. from plugins like vim-qf.
                            
                              let l:errorformat_saved = &l:errorformat
                              call a:qf.set_errorformat()
                              noautocmd execute 'caddfile' a:file
                              let &l:errorformat = l:errorformat_saved
                            endfunction
                            
                            " }}}1

SCRIPT  /home/farhaan/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/bibtex.vim
Sourced 1 time
Total time:   0.000243
 Self time:   0.000243

count  total (s)   self (s)
                            " VimTeX - LaTeX plugin for Vim
                            "
                            " Maintainer: Karl Yngve Lervåg
                            " Email:      karl.yngve@gmail.com
                            "
                            
    1              0.000007 function! vimtex#qf#bibtex#addqflist(blg) abort " {{{1
                              if get(g:vimtex_quickfix_blgparser, 'disable') | return | endif
                            
                              try
                                call s:qf.addqflist(a:blg)
                              catch /BibTeX Aborted/
                              endtry
                            endfunction
                            
                            " }}}1
                            
                            
    1              0.000011 let s:qf = {
                                  \ 'file' : '',
                                  \ 'types' : [],
                                  \ 'db_files' : [],
                                  \}
                            
    1              0.000003 function! s:qf.set_errorformat() abort dict "{{{1
                              setlocal errorformat=%+E%.%#---line\ %l\ of\ file\ %f
                              setlocal errorformat+=%+EI\ found\ %.%#---while\ reading\ file\ %f
                              setlocal errorformat+=%+WWarning--empty\ %.%#\ in\ %.%m
                              setlocal errorformat+=%+WWarning--entry\ type\ for%m
                              setlocal errorformat+=%-C--line\ %l\ of\ file\ %f
                              setlocal errorformat+=%-G%.%#
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:qf.addqflist(blg) abort " {{{1
                              let self.file = a:blg
                              if empty(self.file) || !filereadable(self.file) | throw 'BibTeX Aborted' | endif
                            
                              let self.types = map(
                                    \ filter(items(s:), 'v:val[0] =~# ''^type_'''),
                                    \ 'v:val[1]')
                              let self.db_files = []
                            
                              call vimtex#qf#u#caddfile(self, fnameescape(self.file))
                            
                              call self.fix_paths()
                            endfunction
                            
                            " }}}1
    1              0.000023 function! s:qf.fix_paths() abort " {{{1
                              let l:qflist = getqflist()
                              try
                                let l:title = getqflist({'title': 1})
                              catch /E118/
                                let l:title = 'VimTeX errors'
                              endtry
                            
                              for l:qf in l:qflist
                                for l:type in self.types
                                  if l:type.fix(self, l:qf) | break | endif
                                endfor
                              endfor
                            
                              call setqflist(l:qflist, 'r')
                            
                              " Set title if supported
                              try
                                call setqflist([], 'r', l:title)
                              catch
                              endtry
                            endfunction
                            
                            " }}}1
    1              0.000002 function! s:qf.get_db_files() abort " {{{1
                              if empty(self.db_files)
                                let l:out_dir = fnamemodify(
                                      \ b:vimtex.compiler.get_file('log'), ':.:h') . '/'
                                for l:file in map(
                                      \ filter(readfile(self.file), 'v:val =~# ''Database file #\d:'''),
                                      \ 'matchstr(v:val, '': \zs.*'')')
                                  if filereadable(l:file)
                                    call add(self.db_files, l:file)
                                  elseif filereadable(l:out_dir . l:file)
                                    call add(self.db_files, l:out_dir . l:file)
                                  endif
                                endfor
                              endif
                            
                              return self.db_files
                            endfunction
                            
                            " }}}1
    1              0.000003 function! s:qf.get_key_loc(key) abort " {{{1
                              for l:file in self.get_db_files()
                                let l:lines = readfile(l:file)
                                let l:lnum = 0
                                for l:line in l:lines
                                  let l:lnum += 1
                                  if l:line =~# '^\s*@\w*{\s*\V' . a:key
                                    return [l:file, l:lnum]
                                  endif
                                endfor
                              endfor
                            
                              return []
                            endfunction
                            
                            " }}}1
                            
                            "
                            " Parsers for the various warning types
                            "
                            
    1              0.000004 let s:type_syn_error = {}
    1              0.000003 function! s:type_syn_error.fix(ctx, entry) abort " {{{1
                              if a:entry.text =~# '---line \d\+ of file'
                                let a:entry.text = split(a:entry.text, '---')[0]
                                return 1
                              endif
                            endfunction
                            
                            " }}}1
                            
    1              0.000006 let s:type_empty = {
                                  \ 're' : '\vWarning--empty (.*) in ([^ ;]*)(.*)',
                                  \}
    1              0.000003 function! s:type_empty.fix(ctx, entry) abort " {{{1
                              let l:matches = matchlist(a:entry.text, self.re)
                              if empty(l:matches) | return 0 | endif
                            
                              let l:type = l:matches[1]
                              let l:key = l:matches[2]
                              let l:more = matchstr(l:matches[3], '; \zs.*')
                            
                              unlet a:entry.bufnr
                              let a:entry.text = empty(l:more)
                                    \ ? printf('Missing "%s" in "%s"', l:type, l:key)
                                    \ : printf('Missing "%s" in "%s" (%s)', l:type, l:key, l:more)
                            
                              let l:loc = a:ctx.get_key_loc(l:key)
                              if !empty(l:loc)
                                let a:entry.filename = l:loc[0]
                                let a:entry.lnum = l:loc[1]
                              endif
                            
                              return 1
                            endfunction
                            
                            " }}}1
                            
    1              0.000006 let s:type_style_file_defined = {
                                  \ 're' : '\vWarning--entry type for "(\w+)"',
                                  \}
    1              0.000003 function! s:type_style_file_defined.fix(ctx, entry) abort " {{{1
                              let l:matches = matchlist(a:entry.text, self.re)
                              if empty(l:matches) | return 0 | endif
                            
                              let l:key = l:matches[1]
                            
                              unlet a:entry.bufnr
                              let a:entry.text = 'Entry type for "' . l:key . '" isn''t style-file defined'
                            
                              let l:loc = a:ctx.get_key_loc(l:key)
                              if !empty(l:loc)
                                let a:entry.filename = l:loc[0]
                                let a:entry.lnum = l:loc[1]
                              endif
                            
                              return 1
                            endfunction
                            
                            " }}}1
                            
    1              0.000003 let s:type_no_bibstyle = {}
    1              0.000006 function! s:type_no_bibstyle.fix(ctx, entry) abort " {{{1
                              if a:entry.text =~# 'I found no \\bibstyle'
                                let a:entry.text = 'BibTeX found no \bibstyle command (missing \bibliographystyle?)'
                                let a:entry.filename = b:vimtex.tex
                                unlet a:entry.bufnr
                                for [l:file, l:lnum, l:line] in vimtex#parser#tex(b:vimtex.tex)
                                  if l:line =~# g:vimtex#re#not_comment . '\\bibliography'
                                    let a:entry.lnum = l:lnum
                                    let a:entry.filename = l:file
                                    break
                                  endif
                                endfor
                                return 1
                              endif
                            endfunction
                            
                            " }}}1

SCRIPT  /usr/local/share/nvim/runtime/ftplugin/qf.vim
Sourced 5 times
Total time:   0.000521
 Self time:   0.000521

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:     Vim's quickfix window
                            " Maintainer:   Lech Lorens <Lech.Lorens@gmail.com>
                            " Last Change: 	2019 Jul 15
                            
    5              0.000034 if exists("b:did_ftplugin")
                              finish
    5              0.000004 endif
                            
                            " Don't load another plugin for this buffer
    5              0.000015 let b:did_ftplugin = 1
                            
    5              0.000019 if !get(g:, 'qf_disable_statusline')
    5              0.000011   let b:undo_ftplugin = "set stl<"
                            
                              " Display the command that produced the list in the quickfix window:
    5              0.000043   setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%-15(%l,%c%V%)\ %P
    5              0.000004 endif
                            
    5              0.000021 function! s:setup_toc() abort
                              if get(w:, 'quickfix_title') !~# '\<TOC$' || &syntax != 'qf'
                                return
                              endif
                            
                              let list = getloclist(0)
                              if empty(list)
                                return
                              endif
                            
                              let bufnr = list[0].bufnr
                              setlocal modifiable
                              silent %delete _
                              call setline(1, map(list, 'v:val.text'))
                              setlocal nomodifiable nomodified
                              let &syntax = getbufvar(bufnr, '&syntax')
                            endfunction
                            
    5              0.000016 augroup qf_toc
    5              0.000069   autocmd!
    5              0.000028   autocmd Syntax <buffer> call s:setup_toc()
    5              0.000010 augroup END

SCRIPT  /usr/local/share/nvim/runtime/syntax/qf.vim
Sourced 5 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Quickfix window
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2001 Jan 15
                            
                            " Quit when a syntax file was already loaded
    5              0.000022 if exists("b:current_syntax")
                              finish
    5              0.000004 endif
                            
                            " A bunch of useful C keywords
    5              0.000051 syn match	qfFileName	"^[^|]*" nextgroup=qfSeparator
    5              0.000020 syn match	qfSeparator	"|" nextgroup=qfLineNr contained
    5              0.000023 syn match	qfLineNr	"[^|]*" contained contains=qfError
    5              0.000021 syn match	qfError		"error" contained
                            
                            " The default highlighting.
    5              0.000013 hi def link qfFileName	Directory
    5              0.000008 hi def link qfLineNr	LineNr
    5              0.000008 hi def link qfError	Error
                            
    5              0.000013 let b:current_syntax = "qf"
                            
                            " vim: ts=8

FUNCTION  vimtex#state#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state.vim:7
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000004   command! -buffer VimtexToggleMain  call vimtex#state#toggle_main()
    1              0.000003   command! -buffer VimtexReloadState call vimtex#state#reload()
                            
    1              0.000005   nnoremap <buffer> <plug>(vimtex-toggle-main)  :VimtexToggleMain<cr>
    1              0.000004   nnoremap <buffer> <plug>(vimtex-reload-state) :VimtexReloadState<cr>

FUNCTION  1()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim:143
Called 2 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    2              0.000006   let new = deepcopy(self)
    2              0.000003   unlet new.init
                            
    2              0.000003   let new.data = {}
    2              0.000003   let new.path = a:path
    2              0.000003   let new.ftime = -1
    2              0.000004   let new.default = a:opts.default
                            
    2              0.000003   let new.__validated = 0
    2              0.000006   let new.__validation_value = deepcopy(a:opts.validate)
    2              0.000006   if type(new.__validation_value) == v:t_dict
                                let new.__validation_value._version = s:_version
    2              0.000001   endif
    2              0.000006   let new.data.__validate = deepcopy(new.__validation_value)
                            
    2              0.000002   if a:opts.persistent
    1              0.000007     return extend(new, s:cache_persistent)
    1              0.000000   endif
                            
    1              0.000006   return extend(new, s:cache_volatile)

FUNCTION  2()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim:172
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000002   let self.__validated = 1
                            
    1              0.000006   if type(self.data.__validate) != type(self.__validation_value) || self.data.__validate != self.__validation_value
                                call self.clear()
                                let self.data.__validate = deepcopy(self.__validation_value)
                                call self.write()
    1              0.000000   endif

FUNCTION  3()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim:184
Called 2 times
Total time:   0.000031
 Self time:   0.000021

count  total (s)   self (s)
    2   0.000015   0.000005   call self.read()
                            
    2              0.000005   if !has_key(self.data, a:key)
                                let self.data[a:key] = deepcopy(self.default)
    2              0.000001   endif
                            
    2              0.000004   return get(self.data, a:key)

FUNCTION  4()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim:195
Called 2 times
Total time:   0.000087
 Self time:   0.000014

count  total (s)   self (s)
    2   0.000081   0.000008   call self.read()
                            
    2              0.000005   return has_key(self.data, a:key)

FUNCTION  7()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim:224
Called 4 times
Total time:   0.000083
 Self time:   0.000068

count  total (s)   self (s)
    4              0.000021   if getftime(self.path) <= self.ftime | return | endif
                            
    1              0.000003   let self.ftime = getftime(self.path)
    1              0.000012   let l:contents = join(readfile(self.path))
    1              0.000003   if empty(l:contents) | return | endif
                            
    1              0.000007   let l:data = json_decode(l:contents)
                            
    1              0.000002   if type(l:data) != v:t_dict
                                call vimtex#log#warning( 'Inconsistent cache data while reading:', self.path, 'Decoded data type: ' . type(l:data))
                                return
    1              0.000000   endif
                            
    1              0.000004   call extend(self.data, l:data)
                            
    1              0.000001   if !self.__validated
    1   0.000018   0.000004     call self.validate()
    1              0.000000   endif

FUNCTION  9()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim:262
Called 3 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    3              0.000013   if !has_key(self.data, a:key)
    1              0.000004     let self.data[a:key] = deepcopy(self.default)
    3              0.000002   endif
                            
    3              0.000011   return get(self.data, a:key)

FUNCTION  vimtex#delim#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:7
Called 1 time
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000011   nnoremap <silent><buffer> <plug>(vimtex-delim-toggle-modifier) :<c-u>call <sid>operator_setup('toggle_modifier_next') <bar> normal! <c-r>=v:count ? v:count : ''<cr>g@l<cr>
                            
    1              0.000009   nnoremap <silent><buffer> <plug>(vimtex-delim-toggle-modifier-reverse) :<c-u>call <sid>operator_setup('toggle_modifier_prev') <bar> normal! <c-r>=v:count ? v:count : ''<cr>g@l<cr>
                            
    1              0.000006   xnoremap <silent><buffer> <plug>(vimtex-delim-toggle-modifier) :<c-u>call vimtex#delim#toggle_modifier_visual()<cr>
                            
    1              0.000006   xnoremap <silent><buffer> <plug>(vimtex-delim-toggle-modifier-reverse) :<c-u>call vimtex#delim#toggle_modifier_visual({'dir': -1})<cr>
                            
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-delim-change-math) :<c-u>call <sid>operator_setup('change')<bar>normal! g@l<cr>
                            
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-delim-delete) :<c-u>call <sid>operator_setup('delete')<bar>normal! g@l<cr>
                            
    1              0.000004   inoremap <silent><buffer><expr> <plug>(vimtex-delim-close) vimtex#delim#close()
                            
    1              0.000005   nnoremap <silent><buffer> <plug>(vimtex-delim-add-modifiers) :<c-u>call vimtex#delim#add_modifiers()<cr>

FUNCTION  vimtex#parser#fls#parse()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/parser/fls.vim:7
Called 4 times
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
    4              0.000019   if !filereadable(a:file)
                                return []
    4              0.000002   endif
                            
    4              0.000137   return readfile(a:file)

FUNCTION  vimtex#nvim#check_treesitter()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/nvim.vim:7
Called 1 time
Total time:   0.003136
 Self time:   0.000128

count  total (s)   self (s)
    1              0.000010 lua <<EOF
                              local highlighter = require "vim.treesitter.highlighter"
                              local bufnr = vim.api.nvim_get_current_buf()
                              if vim.bo[bufnr].syntax == "" and highlighter.active[bufnr] then
                                vim.fn['vimtex#log#error'](
                                  'Syntax highlighting is controlled by Tree-sitter!'
                                )
                              end
                            EOF

FUNCTION  vimtex#view#_template#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view/_template.vim:7
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000011   return extend(deepcopy(s:viewer), a:viewer)

FUNCTION  vimtex#paths#s()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/paths.vim:40
Called 3 times
Total time:   0.000043
 Self time:   0.000026

count  total (s)   self (s)
                              " Use backslash on Windows
    3   0.000041   0.000024   return simplify(vimtex#util#is_win() ? tr(a:path, '/', '\') : a:path)

FUNCTION  vimtex#cmd#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cmd.vim:7
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000011   nnoremap <silent><buffer> <plug>(vimtex-cmd-delete) :<c-u>call <sid>operator_setup('delete')<bar>normal! g@l<cr>
                            
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-cmd-change) :<c-u>call <sid>operator_setup('change')<bar>normal! g@l<cr>
                            
    1              0.000005   inoremap <silent><buffer> <plug>(vimtex-cmd-create) <c-r>=vimtex#cmd#create_insert()<cr>
                            
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-cmd-create) :<c-u>call <sid>operator_setup('create')<bar>normal! g@l<cr>
                            
    1              0.000005   xnoremap <silent><buffer> <plug>(vimtex-cmd-create) :<c-u>call vimtex#cmd#create_visual()<cr>
                            
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-cmd-toggle-star) :<c-u>call <sid>operator_setup('toggle_star')<bar>normal! g@l<cr>
                            
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-cmd-toggle-frac) :<c-u>call <sid>operator_setup('toggle_frac')<bar>normal! g@l<cr>
                            
    1              0.000005   xnoremap <silent><buffer> <plug>(vimtex-cmd-toggle-frac) :<c-u>call vimtex#cmd#toggle_frac_visual()<cr>

FUNCTION  <SNR>69_qf_has_errors()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf.vim:193
Called 3 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    3              0.000054   return len(filter(getqflist(), 'v:val.type ==# ''E''')) > 0

FUNCTION  vimtex#paths#is_abs()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/paths.vim:48
Called 16 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   16              0.000072   return a:path =~# s:re_abs

FUNCTION  <SNR>87_get_cmd_part()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cmd.vim:690
Called 3 times
Total time:   0.003639
 Self time:   0.000207

count  total (s)   self (s)
    3   0.000032   0.000022   let l:save_pos = vimtex#pos#get_cursor()
    3   0.000122   0.000022   call vimtex#pos#set_cursor(a:start_pos)
    3   0.002722   0.000027   let l:open = vimtex#delim#get_next('delim_tex', 'open')
    3   0.000153   0.000027   call vimtex#pos#set_cursor(l:save_pos)
                            
                              " Ensure that the next delimiter is found and is of the right type
    3              0.000023   if empty(l:open) || l:open.match !=# a:part | return {} | endif
                            
                              " Ensure that the delimiter is the next non-whitespace character according to
                              " a configurable rule
    2   0.000165   0.000050   if ! call(g:vimtex_parser_cmd_separator_check, [ s:text_between(a:start_pos, l:open)])
    1              0.000001     return {}
    1              0.000001   endif
                            
    1   0.000369   0.000009   let l:close = vimtex#delim#get_matching(l:open)
    1              0.000002   if empty(l:close)
                                return {}
    1              0.000001   endif
                            
    1   0.000034   0.000009   return { 'open' : l:open, 'close' : l:close, 'text' : s:text_between(l:open, l:close),}

FUNCTION  <SNR>52_init_default_mappings()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex.vim:156
Called 1 time
Total time:   0.005794
 Self time:   0.000801

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_mappings_enabled | return | endif
                            
    1   0.000122   0.000009   call s:map_prefixed(0, 'n', 'i', '<plug>(vimtex-info)')
    1   0.000108   0.000032   call s:map_prefixed(0, 'n', 'I', '<plug>(vimtex-info-full)')
    1   0.000055   0.000008   call s:map_prefixed(0, 'n', 'x', '<plug>(vimtex-reload)')
    1   0.000051   0.000006   call s:map_prefixed(0, 'n', 'X', '<plug>(vimtex-reload-state)')
    1   0.000052   0.000006   call s:map_prefixed(1, 'n', 's', '<plug>(vimtex-toggle-main)')
    1   0.000048   0.000005   call s:map_prefixed(0, 'n', 'q', '<plug>(vimtex-log)')
    1   0.000049   0.000006   call s:map_prefixed(1, 'n', 'a', '<plug>(vimtex-context-menu)')
                            
    1   0.000040   0.000005   call s:map(0, 'n', 'ds$', '<plug>(vimtex-env-delete-math)')
    1   0.000039   0.000005   call s:map(0, 'n', 'cs$', '<plug>(vimtex-env-change-math)')
    1   0.000038   0.000005   call s:map(0, 'n', 'dse', '<plug>(vimtex-env-delete)')
    1   0.000039   0.000005   call s:map(0, 'n', 'cse', '<plug>(vimtex-env-change)')
    1   0.000039   0.000005   call s:map(0, 'n', 'tse', '<plug>(vimtex-env-toggle-star)')
    1   0.000038   0.000005   call s:map(0, 'n', 'ts$', '<plug>(vimtex-env-toggle-math)')
    1   0.000042   0.000005   call s:map(0, 'n', '<F6>', '<plug>(vimtex-env-surround-line)')
    1   0.000045   0.000005   call s:map(0, 'x', '<F6>', '<plug>(vimtex-env-surround-visual)')
                            
    1   0.000040   0.000005   call s:map(0, 'n', 'dsc',  '<plug>(vimtex-cmd-delete)')
    1   0.000038   0.000005   call s:map(0, 'n', 'csc',  '<plug>(vimtex-cmd-change)')
    1   0.000039   0.000005   call s:map(0, 'n', 'tsc',  '<plug>(vimtex-cmd-toggle-star)')
    1   0.000040   0.000007   call s:map(0, 'n', 'tsf',  '<plug>(vimtex-cmd-toggle-frac)')
    1   0.000040   0.000005   call s:map(0, 'x', 'tsf',  '<plug>(vimtex-cmd-toggle-frac)')
    1   0.000044   0.000005   call s:map(0, 'i', '<F7>', '<plug>(vimtex-cmd-create)')
    1   0.000047   0.000005   call s:map(0, 'n', '<F7>', '<plug>(vimtex-cmd-create)')
    1   0.000041   0.000005   call s:map(0, 'x', '<F7>', '<plug>(vimtex-cmd-create)')
                            
    1   0.000039   0.000005   call s:map(0, 'n', 'dsd', '<plug>(vimtex-delim-delete)')
    1   0.000039   0.000005   call s:map(0, 'n', 'csd', '<plug>(vimtex-delim-change-math)')
    1   0.000039   0.000005   call s:map(0, 'n', 'tsd', '<plug>(vimtex-delim-toggle-modifier)')
    1   0.000039   0.000005   call s:map(0, 'x', 'tsd', '<plug>(vimtex-delim-toggle-modifier)')
    1   0.000040   0.000005   call s:map(0, 'n', 'tsD', '<plug>(vimtex-delim-toggle-modifier-reverse)')
    1   0.000040   0.000005   call s:map(0, 'x', 'tsD', '<plug>(vimtex-delim-toggle-modifier-reverse)')
    1   0.000041   0.000005   call s:map(0, 'i', ']]',  '<plug>(vimtex-delim-close)')
    1   0.000041   0.000005   call s:map(0, 'n', '<F8>', '<plug>(vimtex-delim-add-modifiers)')
                            
    1              0.000001   if g:vimtex_compiler_enabled
    1   0.000051   0.000006     call s:map_prefixed(0, 'n', 'l', '<plug>(vimtex-compile)')
    1   0.000051   0.000006     call s:map_prefixed(0, 'n', 'o', '<plug>(vimtex-compile-output)')
    1   0.000051   0.000006     call s:map_prefixed(1, 'n', 'L', '<plug>(vimtex-compile-selected)')
    1   0.000051   0.000006     call s:map_prefixed(1, 'x', 'L', '<plug>(vimtex-compile-selected)')
    1   0.000049   0.000006     call s:map_prefixed(0, 'n', 'k', '<plug>(vimtex-stop)')
    1   0.000050   0.000005     call s:map_prefixed(0, 'n', 'K', '<plug>(vimtex-stop-all)')
    1   0.000049   0.000006     call s:map_prefixed(0, 'n', 'e', '<plug>(vimtex-errors)')
    1   0.000048   0.000005     call s:map_prefixed(0, 'n', 'c', '<plug>(vimtex-clean)')
    1   0.000048   0.000005     call s:map_prefixed(0, 'n', 'C', '<plug>(vimtex-clean-full)')
    1   0.000048   0.000005     call s:map_prefixed(0, 'n', 'g', '<plug>(vimtex-status)')
    1   0.000048   0.000005     call s:map_prefixed(0, 'n', 'G', '<plug>(vimtex-status-all)')
    1              0.000000   endif
                            
    1              0.000001   if g:vimtex_motion_enabled
                                " These are forced in order to overwrite matchit mappings
    1   0.000035   0.000005     call s:map(1, 'n', '%', '<plug>(vimtex-%)', 1)
    1   0.000034   0.000005     call s:map(1, 'x', '%', '<plug>(vimtex-%)', 1)
    1   0.000041   0.000005     call s:map(1, 'o', '%', '<plug>(vimtex-%)', 1)
                            
    1   0.000039   0.000005     call s:map(1, 'n', ']]', '<plug>(vimtex-]])')
    1   0.000038   0.000005     call s:map(1, 'n', '][', '<plug>(vimtex-][)')
    1   0.000038   0.000004     call s:map(1, 'n', '[]', '<plug>(vimtex-[])')
    1   0.000038   0.000004     call s:map(1, 'n', '[[', '<plug>(vimtex-[[)')
    1   0.000039   0.000004     call s:map(1, 'x', ']]', '<plug>(vimtex-]])')
    1   0.000038   0.000004     call s:map(1, 'x', '][', '<plug>(vimtex-][)')
    1   0.000038   0.000004     call s:map(1, 'x', '[]', '<plug>(vimtex-[])')
    1   0.000037   0.000004     call s:map(1, 'x', '[[', '<plug>(vimtex-[[)')
    1   0.000039   0.000004     call s:map(1, 'o', ']]', '<plug>(vimtex-]])')
    1   0.000038   0.000004     call s:map(1, 'o', '][', '<plug>(vimtex-][)')
    1   0.000039   0.000005     call s:map(1, 'o', '[]', '<plug>(vimtex-[])')
    1   0.000037   0.000004     call s:map(1, 'o', '[[', '<plug>(vimtex-[[)')
                            
    1   0.000040   0.000004     call s:map(1, 'n', ']M', '<plug>(vimtex-]M)')
    1   0.000038   0.000004     call s:map(1, 'n', ']m', '<plug>(vimtex-]m)')
    1   0.000038   0.000004     call s:map(1, 'n', '[M', '<plug>(vimtex-[M)')
    1   0.000038   0.000004     call s:map(1, 'n', '[m', '<plug>(vimtex-[m)')
    1   0.000038   0.000004     call s:map(1, 'x', ']M', '<plug>(vimtex-]M)')
    1   0.000037   0.000004     call s:map(1, 'x', ']m', '<plug>(vimtex-]m)')
    1   0.000037   0.000004     call s:map(1, 'x', '[M', '<plug>(vimtex-[M)')
    1   0.000037   0.000004     call s:map(1, 'x', '[m', '<plug>(vimtex-[m)')
    1   0.000038   0.000004     call s:map(1, 'o', ']M', '<plug>(vimtex-]M)')
    1   0.000044   0.000004     call s:map(1, 'o', ']m', '<plug>(vimtex-]m)')
    1   0.000038   0.000004     call s:map(1, 'o', '[M', '<plug>(vimtex-[M)')
    1   0.000037   0.000004     call s:map(1, 'o', '[m', '<plug>(vimtex-[m)')
                            
    1   0.000038   0.000004     call s:map(1, 'n', ']N', '<plug>(vimtex-]N)')
    1   0.000038   0.000004     call s:map(1, 'n', ']n', '<plug>(vimtex-]n)')
    1   0.000038   0.000004     call s:map(1, 'n', '[N', '<plug>(vimtex-[N)')
    1   0.000038   0.000004     call s:map(1, 'n', '[n', '<plug>(vimtex-[n)')
    1   0.000038   0.000004     call s:map(1, 'x', ']N', '<plug>(vimtex-]N)')
    1   0.000038   0.000004     call s:map(1, 'x', ']n', '<plug>(vimtex-]n)')
    1   0.000037   0.000004     call s:map(1, 'x', '[N', '<plug>(vimtex-[N)')
    1   0.000037   0.000004     call s:map(1, 'x', '[n', '<plug>(vimtex-[n)')
    1   0.000052   0.000004     call s:map(1, 'o', ']N', '<plug>(vimtex-]N)')
    1   0.000039   0.000005     call s:map(1, 'o', ']n', '<plug>(vimtex-]n)')
    1   0.000038   0.000004     call s:map(1, 'o', '[N', '<plug>(vimtex-[N)')
    1   0.000037   0.000004     call s:map(1, 'o', '[n', '<plug>(vimtex-[n)')
                            
    1   0.000039   0.000004     call s:map(1, 'n', ']R', '<plug>(vimtex-]R)')
    1   0.000038   0.000004     call s:map(1, 'n', ']r', '<plug>(vimtex-]r)')
    1   0.000039   0.000005     call s:map(1, 'n', '[R', '<plug>(vimtex-[R)')
    1   0.000037   0.000004     call s:map(1, 'n', '[r', '<plug>(vimtex-[r)')
    1   0.000038   0.000004     call s:map(1, 'x', ']R', '<plug>(vimtex-]R)')
    1   0.000037   0.000004     call s:map(1, 'x', ']r', '<plug>(vimtex-]r)')
    1   0.000038   0.000004     call s:map(1, 'x', '[R', '<plug>(vimtex-[R)')
    1   0.000037   0.000004     call s:map(1, 'x', '[r', '<plug>(vimtex-[r)')
    1   0.000038   0.000004     call s:map(1, 'o', ']R', '<plug>(vimtex-]R)')
    1   0.000038   0.000004     call s:map(1, 'o', ']r', '<plug>(vimtex-]r)')
    1   0.000037   0.000004     call s:map(1, 'o', '[R', '<plug>(vimtex-[R)')
    1   0.000037   0.000004     call s:map(1, 'o', '[r', '<plug>(vimtex-[r)')
                            
    1   0.000038   0.000004     call s:map(1, 'n', ']/', '<plug>(vimtex-]/)')
    1   0.000038   0.000004     call s:map(1, 'n', ']*', '<plug>(vimtex-]*)')
    1   0.000038   0.000004     call s:map(1, 'n', '[/', '<plug>(vimtex-[/)')
    1   0.000044   0.000004     call s:map(1, 'n', '[*', '<plug>(vimtex-[*)')
    1   0.000038   0.000005     call s:map(1, 'x', ']/', '<plug>(vimtex-]/)')
    1   0.000037   0.000004     call s:map(1, 'x', ']*', '<plug>(vimtex-]*)')
    1   0.000038   0.000004     call s:map(1, 'x', '[/', '<plug>(vimtex-[/)')
    1   0.000038   0.000004     call s:map(1, 'x', '[*', '<plug>(vimtex-[*)')
    1   0.000038   0.000004     call s:map(1, 'o', ']/', '<plug>(vimtex-]/)')
    1   0.000038   0.000004     call s:map(1, 'o', ']*', '<plug>(vimtex-]*)')
    1   0.000038   0.000004     call s:map(1, 'o', '[/', '<plug>(vimtex-[/)')
    1   0.000038   0.000004     call s:map(1, 'o', '[*', '<plug>(vimtex-[*)')
    1              0.000000   endif
                            
    1              0.000001   if g:vimtex_text_obj_enabled
    1   0.000037   0.000004     call s:map(0, 'x', 'id', '<plug>(vimtex-id)')
    1   0.000037   0.000004     call s:map(0, 'x', 'ad', '<plug>(vimtex-ad)')
    1   0.000037   0.000004     call s:map(0, 'o', 'id', '<plug>(vimtex-id)')
    1   0.000037   0.000004     call s:map(0, 'o', 'ad', '<plug>(vimtex-ad)')
    1   0.000038   0.000004     call s:map(0, 'x', 'i$', '<plug>(vimtex-i$)')
    1   0.000037   0.000004     call s:map(0, 'x', 'a$', '<plug>(vimtex-a$)')
    1   0.000038   0.000005     call s:map(0, 'o', 'i$', '<plug>(vimtex-i$)')
    1   0.000037   0.000004     call s:map(0, 'o', 'a$', '<plug>(vimtex-a$)')
    1   0.000038   0.000004     call s:map(1, 'x', 'iP', '<plug>(vimtex-iP)')
    1   0.000038   0.000004     call s:map(1, 'x', 'aP', '<plug>(vimtex-aP)')
    1   0.000038   0.000004     call s:map(1, 'o', 'iP', '<plug>(vimtex-iP)')
    1   0.000038   0.000004     call s:map(1, 'o', 'aP', '<plug>(vimtex-aP)')
    1   0.000038   0.000004     call s:map(1, 'x', 'im', '<plug>(vimtex-im)')
    1   0.000038   0.000004     call s:map(1, 'x', 'am', '<plug>(vimtex-am)')
    1   0.000038   0.000004     call s:map(1, 'o', 'im', '<plug>(vimtex-im)')
    1   0.000039   0.000004     call s:map(1, 'o', 'am', '<plug>(vimtex-am)')
                            
    1   0.000115   0.000059     if vimtex#text_obj#targets#enabled()
                                  call vimtex#text_obj#targets#init()
                            
                                  " These are handled explicitly to avoid conflict with gitgutter
                                  call s:map(0, 'x', 'ic', '<plug>(vimtex-targets-i)c')
                                  call s:map(0, 'x', 'ac', '<plug>(vimtex-targets-a)c')
                                  call s:map(0, 'o', 'ic', '<plug>(vimtex-targets-i)c')
                                  call s:map(0, 'o', 'ac', '<plug>(vimtex-targets-a)c')
    1              0.000001     else
    1              0.000002       if g:vimtex_text_obj_variant ==# 'targets'
                                    call vimtex#log#warning( "Ignoring g:vimtex_text_obj_variant = 'targets'" . " because 'g:loaded_targets' does not exist or is 0.")
    1              0.000001       endif
    1              0.000002       let g:vimtex_text_obj_variant = 'vimtex'
                            
    1   0.000049   0.000006       call s:map(0, 'x', 'ie', '<plug>(vimtex-ie)')
    1   0.000042   0.000005       call s:map(0, 'x', 'ae', '<plug>(vimtex-ae)')
    1   0.000041   0.000005       call s:map(0, 'o', 'ie', '<plug>(vimtex-ie)')
    1   0.000039   0.000004       call s:map(0, 'o', 'ae', '<plug>(vimtex-ae)')
    1   0.000039   0.000004       call s:map(0, 'x', 'ic', '<plug>(vimtex-ic)')
    1   0.000039   0.000004       call s:map(0, 'x', 'ac', '<plug>(vimtex-ac)')
    1   0.000040   0.000006       call s:map(0, 'o', 'ic', '<plug>(vimtex-ic)')
    1   0.000038   0.000004       call s:map(0, 'o', 'ac', '<plug>(vimtex-ac)')
    1              0.000001     endif
    1              0.000000   endif
                            
    1              0.000001   if g:vimtex_toc_enabled
    1   0.000058   0.000006     call s:map_prefixed(0, 'n', 't', '<plug>(vimtex-toc-open)')
    1   0.000055   0.000006     call s:map_prefixed(0, 'n', 'T', '<plug>(vimtex-toc-toggle)')
    1              0.000000   endif
                            
    1              0.000003   if has_key(b:vimtex, 'viewer')
    1   0.000052   0.000006     call s:map_prefixed(0, 'n', 'v', '<plug>(vimtex-view)')
    1              0.000010     if !empty(maparg('<plug>(vimtex-reverse-search)', 'n'))
                                  call s:map_prefixed(1, 'n', 'r', '<plug>(vimtex-reverse-search)')
    1              0.000001     endif
    1              0.000000   endif
                            
    1              0.000001   if g:vimtex_imaps_enabled
    1   0.000053   0.000006     call s:map_prefixed(0, 'n', 'm', '<plug>(vimtex-imaps-list)')
    1              0.000000   endif
                            
    1              0.000001   if g:vimtex_doc_enabled
    1   0.000042   0.000005     call s:map(1, 'n', 'K', '<plug>(vimtex-doc-package)')
    1              0.000000   endif

FUNCTION  vimtex#qf#setqflist()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf.vim:102
Called 3 times
Total time:   0.060853
 Self time:   0.000542

count  total (s)   self (s)
    3              0.000016   if !exists('b:vimtex.qf.addqflist') | return | endif
                            
    3              0.000009   if a:0 > 0 && !empty(a:1)
                                let l:tex = a:1
                                let l:log = fnamemodify(l:tex, ':r') . '.log'
                                let l:blg = fnamemodify(l:tex, ':r') . '.blg'
                                let l:jump = 0
    3              0.000002   else
    3              0.000007     let l:tex = b:vimtex.tex
    3   0.000208   0.000018     let l:log = b:vimtex.compiler.get_file('log')
    3   0.000210   0.000019     let l:blg = b:vimtex.compiler.get_file('blg')
    3              0.000007     let l:jump = g:vimtex_quickfix_autojump
    3              0.000002   endif
                            
    3              0.000002   try
                                " Initialize the quickfix list
                                " Note: Only create new list if the current list is not a VimTeX qf list
    3              0.000031     if get(getqflist({'title': 1}), 'title') =~# 'VimTeX'
    2   0.008390   0.000069       call setqflist([], 'r')
    1              0.000001     else
    1              0.000004       call setqflist([])
    3              0.000002     endif
                            
                                " Parse LaTeX errors
    3   0.051258   0.000028     call b:vimtex.qf.addqflist(l:tex, l:log)
                            
                                " Parse bibliography errors
    3              0.000017     if has_key(b:vimtex.packages, 'biblatex')
                                  call vimtex#qf#biblatex#addqflist(l:blg)
    3              0.000002     else
    3   0.000526   0.000145       call vimtex#qf#bibtex#addqflist(l:blg)
    3              0.000002     endif
                            
                                " Ignore entries if desired
    3              0.000010     if !empty(g:vimtex_quickfix_ignore_filters)
                                  let l:qflist = getqflist()
                                  for l:re in g:vimtex_quickfix_ignore_filters
                                    call filter(l:qflist, 'v:val.text !~# l:re')
                                  endfor
                                  call setqflist(l:qflist, 'r')
    3              0.000002     endif
                            
                                " Set title if supported
    3              0.000002     try
    3              0.000029       call setqflist([], 'r', {'title': 'VimTeX errors (' . b:vimtex.qf.name . ')'})
                                catch
    3              0.000002     endtry
                            
                                " Jump to first error if wanted
    3              0.000004     if l:jump
                                  cfirst
    3              0.000002     endif
                              catch /VimTeX: No log file found/
                                throw 'VimTeX: No log file found'
    3              0.000002   endtry

FUNCTION  vimtex#context#cite#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/context/cite.vim:7
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return deepcopy(s:handler)

FUNCTION  <SNR>90_get_re_for_delim()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:970
Called 6 times
Total time:   0.000541
 Self time:   0.000453

count  total (s)   self (s)
    6              0.000022   let l:type = a:0 > 0 ? a:1 : 'delim_all'
                            
                              " First check for unmatched math delimiter
    6              0.000013   if a:delim ==# '.'
                                return g:vimtex#delim#re.delim_math[a:side ? 'open' : 'close']
    6              0.000005   endif
                            
                              " Next check normal delimiters
    6   0.000424   0.000336   let l:index = index(map(   copy(g:vimtex#delim#lists[l:type].name),   {_, x -> x[a:side]}), a:delim)
    6              0.000040   return l:index >= 0 ? g:vimtex#delim#lists[l:type].re[l:index][a:side] : ''

FUNCTION  <SNR>58_get_main_id()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state.vim:182
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003   for [l:id, l:state] in items(s:vimtex_states)
                                if l:state.tex == a:main
                                  return str2nr(l:id)
                                endif
    1              0.000001   endfor
                            
    1              0.000001   return -1

FUNCTION  <SNR>52_map_prefixed()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex.vim:405
Called 22 times
Total time:   0.001093
 Self time:   0.000185

count  total (s)   self (s)
   22              0.000055   let l:lhs = g:vimtex_mappings_prefix . a:lhs
   22   0.001030   0.000122   call s:map(a:ftype, a:mode, l:lhs, a:rhs)

FUNCTION  <SNR>68_check_callback()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/_template.vim:485
Called 208 times
Total time:   0.103074
 Self time:   0.002523

count  total (s)   self (s)
  208              0.001634   let l:status = get(s:callbacks, substitute(a:line, '\r', '', ''))
  208              0.000625   if l:status <= 0 | return | endif
                            
    6   0.100620   0.000068   call vimtex#compiler#callback(l:status)

FUNCTION  vimtex#compiler#compile()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler.vim:101
Called 1 time
Total time:   0.008012
 Self time:   0.000086

count  total (s)   self (s)
    1              0.000020   if !b:vimtex.compiler.enabled | return | endif
                            
    1   0.000096   0.000020   if b:vimtex.compiler.is_running()
                                call vimtex#compiler#stop()
    1              0.000002   else
    1   0.007874   0.000024     call vimtex#compiler#start()
    1              0.000003   endif

FUNCTION  vimtex#options#init()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/options.vim:7
Called 2 times
Total time:   0.009253
 Self time:   0.002207

count  total (s)   self (s)
    2              0.000007   if s:initialized | return | endif
                            
    1   0.000769   0.000006   call s:init_highlights()
    1   0.000241   0.000009   call s:check_for_deprecated_options()
                            
    1   0.000024   0.000009   call s:init_option('vimtex_bibliography_commands', [ '%(no)?bibliography', 'add%(bibresource|globalbib|sectionbib)',])
                            
    1   0.000018   0.000005   call s:init_option('vimtex_compiler_enabled', 1)
    1   0.000016   0.000005   call s:init_option('vimtex_compiler_silent', 0)
    1   0.000016   0.000005   call s:init_option('vimtex_compiler_method', 'latexmk')
    1   0.000016   0.000005   call s:init_option('vimtex_compiler_clean_paths', [])
    1   0.000033   0.000021   call s:init_option('vimtex_compiler_latexmk_engines', {  '_'                : '-pdf',  'pdfdvi'           : '-pdfdvi',  'pdfps'            : '-pdfps',  'pdflatex'         : '-pdf',  'luatex'           : '-lualatex',  'lualatex'         : '-lualatex',  'xelatex'          : '-xelatex',  'context (pdftex)' : '-pdf -pdflatex=texexec',  'context (luatex)' : '-pdf -pdflatex=context',  'context (xetex)'  : '-pdf -pdflatex=''texexec --xtx''', })
    1   0.000020   0.000008   call s:init_option('vimtex_compiler_latexrun_engines', { '_'        : 'pdflatex', 'pdflatex' : 'pdflatex', 'lualatex' : 'lualatex', 'xelatex'  : 'xelatex',})
                            
    1   0.000016   0.000004   call s:init_option('vimtex_complete_enabled', 1)
    1   0.000016   0.000004   call s:init_option('vimtex_complete_close_braces', 0)
    1   0.000016   0.000005   call s:init_option('vimtex_complete_ignore_case', &ignorecase)
    1   0.000017   0.000006   call s:init_option('vimtex_complete_smart_case', &smartcase)
    1   0.000025   0.000014   call s:init_option('vimtex_complete_bib', { 'simple': 0, 'match_str_fmt': '@key [@type] @author_all (@year), "@title"', 'menu_fmt': '[@type] @author_short (@year), "@title"', 'info_fmt': "TITLE: @title\nAUTHOR: @author_all\nYEAR: @year", 'abbr_fmt': '', 'auth_len': 20, 'custom_patterns': [],})
    1   0.000017   0.000006   call s:init_option('vimtex_complete_ref', { 'custom_patterns': [],})
                            
    1              0.000003   let l:viewer = get(g:, 'vimtex_view_method', 'general')
    1              0.000002   if l:viewer ==# 'general'
    1              0.000001     let l:viewer = 'NONE'
    1              0.000001   endif
    1   0.000017   0.000005   call s:init_option('vimtex_context_pdf_viewer', l:viewer)
                            
    1   0.000016   0.000004   call s:init_option('vimtex_delim_timeout', 300)
    1   0.000016   0.000004   call s:init_option('vimtex_delim_insert_timeout', 60)
    1   0.000016   0.000004   call s:init_option('vimtex_delim_stopline', 500)
                            
    1   0.000016   0.000004   call s:init_option('vimtex_include_search_enabled', 1)
                            
    1   0.000016   0.000004   call s:init_option('vimtex_doc_enabled', 1)
    1   0.000016   0.000005   call s:init_option('vimtex_doc_confirm_single', v:true)
    1   0.000016   0.000005   call s:init_option('vimtex_doc_handlers', [])
                            
    1   0.000016   0.000004   call s:init_option('vimtex_echo_verbose_input', 1)
                            
    1   0.000016   0.000004   call s:init_option('vimtex_env_change_autofill', 0)
    1   0.000019   0.000007   call s:init_option('vimtex_env_toggle_math_map', { '$': '\[', '\[': 'equation', '$$': '\[', '\(': '$',})
                            
    1              0.000001   if &diff
                                let g:vimtex_fold_enabled = 0
                                let g:vimtex_fold_bib_enabled = 0
    1              0.000001   else
    1   0.000016   0.000005     call s:init_option('vimtex_fold_enabled', 0)
    1   0.000017   0.000005     call s:init_option('vimtex_fold_bib_enabled', g:vimtex_fold_enabled)
    1              0.000001   endif
    1   0.000016   0.000004   call s:init_option('vimtex_fold_bib_max_key_width', 0)
    1   0.000016   0.000005   call s:init_option('vimtex_fold_manual', 0)
    1   0.000016   0.000005   call s:init_option('vimtex_fold_levelmarker', '*')
    1   0.000016   0.000005   call s:init_option('vimtex_fold_types', {})
    1   0.000105   0.000093   call s:init_option('vimtex_fold_types_defaults', { 'preamble' : {}, 'items' : {}, 'comments' : { 'enabled' : 0 }, 'envs' : {   'blacklist' : [],   'whitelist' : [], }, 'env_options' : {}, 'markers' : {}, 'sections' : {   'parse_levels' : 0,   'sections' : [     '%(add)?part',     '%(chapter|addchap)',     '%(section|addsec)',     'subsection',     'subsubsection',   ],   'parts' : [     'appendix',     'frontmatter',     'mainmatter',     'backmatter',   ], }, 'cmd_single' : {   'cmds' : [     'hypersetup',     'tikzset',     'pgfplotstableread',     'lstset',   ], }, 'cmd_single_opt' : {   'cmds' : [     'usepackage',     'includepdf',   ], }, 'cmd_multi' : {   'cmds' : [     '%(re)?new%(command|environment)',     'providecommand',     'presetkeys',     'Declare%(Multi|Auto)?CiteCommand',     'Declare%(Index)?%(Field|List|Name)%(Format|Alias)',   ], }, 'cmd_addplot' : {   'cmds' : [     'addplot[+3]?',   ], },})
                            
    1   0.000016   0.000004   call s:init_option('vimtex_format_enabled', 0)
    1   0.000022   0.000010   call s:init_option('vimtex_format_border_begin', '\v^\s*%(' . join([ '\\item', '\\begin', '\\end', '%(\\\[|\$\$)\s*$',], '|') . ')')
    1   0.000024   0.000012   call s:init_option('vimtex_format_border_end', '\v\\%(' . join([ '\\\*?', 'clear%(double)?page', 'linebreak', 'new%(line|page)', 'pagebreak', '%(begin|end)\{[^}]*\}',], '|') . ')\s*$' . '|^\s*%(\\\]|\$\$)\s*$')
                            
    1   0.000018   0.000006   call s:init_option('vimtex_grammar_textidote', { 'jar': '', 'args': '',})
    1   0.000027   0.000015   call s:init_option('vimtex_grammar_vlty', { 'lt_directory': '~/lib/LanguageTool', 'lt_command': '', 'lt_disable': 'WHITESPACE_RULE', 'lt_enable': '', 'lt_disablecategories': '', 'lt_enablecategories': '', 'server': 'no', 'shell_options': '', 'show_suggestions': 0, 'encoding': 'auto',})
                            
    1   0.000016   0.000004   call s:init_option('vimtex_imaps_enabled', 1)
    1   0.000016   0.000005   call s:init_option('vimtex_imaps_disabled', [])
    1   0.000016   0.000004   call s:init_option('vimtex_imaps_leader', '`')
    1   0.001284   0.001272   call s:init_option('vimtex_imaps_list', [ { 'lhs' : '0',  'rhs' : '\emptyset' }, { 'lhs' : '2',  'rhs' : '\sqrt' }, { 'lhs' : '6',  'rhs' : '\partial' }, { 'lhs' : '8',  'rhs' : '\infty' }, { 'lhs' : '=',  'rhs' : '\equiv' }, { 'lhs' : '\',  'rhs' : '\setminus' }, { 'lhs' : '.',  'rhs' : '\cdot' }, { 'lhs' : '*',  'rhs' : '\times' }, { 'lhs' : '<',  'rhs' : '\langle' }, { 'lhs' : '>',  'rhs' : '\rangle' }, { 'lhs' : 'H',  'rhs' : '\hbar' }, { 'lhs' : '+',  'rhs' : '\dagger' }, { 'lhs' : '[',  'rhs' : '\subseteq' }, { 'lhs' : ']',  'rhs' : '\supseteq' }, { 'lhs' : '(',  'rhs' : '\subset' }, { 'lhs' : ')',  'rhs' : '\supset' }, { 'lhs' : 'A',  'rhs' : '\forall' }, { 'lhs' : 'B',  'rhs' : '\boldsymbol' }, { 'lhs' : 'E',  'rhs' : '\exists' }, { 'lhs' : 'N',  'rhs' : '\nabla' }, { 'lhs' : 'jj', 'rhs' : '\downarrow' }, { 'lhs' : 'jJ', 'rhs' : '\Downarrow' }, { 'lhs' : 'jk', 'rhs' : '\uparrow' }, { 'lhs' : 'jK', 'rhs' : '\Uparrow' }, { 'lhs' : 'jh', 'rhs' : '\leftarrow' }, { 'lhs' : 'jH', 'rhs' : '\Leftarrow' }, { 'lhs' : 'jl', 'rhs' : '\rightarrow' }, { 'lhs' : 'jL', 'rhs' : '\Rightarrow' }, { 'lhs' : 'a',  'rhs' : '\alpha' }, { 'lhs' : 'b',  'rhs' : '\beta' }, { 'lhs' : 'c',  'rhs' : '\chi' }, { 'lhs' : 'd',  'rhs' : '\delta' }, { 'lhs' : 'e',  'rhs' : '\epsilon' }, { 'lhs' : 'f',  'rhs' : '\phi' }, { 'lhs' : 'g',  'rhs' : '\gamma' }, { 'lhs' : 'h',  'rhs' : '\eta' }, { 'lhs' : 'i',  'rhs' : '\iota' }, { 'lhs' : 'k',  'rhs' : '\kappa' }, { 'lhs' : 'l',  'rhs' : '\lambda' }, { 'lhs' : 'm',  'rhs' : '\mu' }, { 'lhs' : 'n',  'rhs' : '\nu' }, { 'lhs' : 'p',  'rhs' : '\pi' }, { 'lhs' : 'q',  'rhs' : '\theta' }, { 'lhs' : 'r',  'rhs' : '\rho' }, { 'lhs' : 's',  'rhs' : '\sigma' }, { 'lhs' : 't',  'rhs' : '\tau' }, { 'lhs' : 'y',  'rhs' : '\psi' }, { 'lhs' : 'u',  'rhs' : '\upsilon' }, { 'lhs' : 'w',  'rhs' : '\omega' }, { 'lhs' : 'z',  'rhs' : '\zeta' }, { 'lhs' : 'x',  'rhs' : '\xi' }, { 'lhs' : 'D',  'rhs' : '\Delta' }, { 'lhs' : 'F',  'rhs' : '\Phi' }, { 'lhs' : 'G',  'rhs' : '\Gamma' }, { 'lhs' : 'L',  'rhs' : '\Lambda' }, { 'lhs' : 'P',  'rhs' : '\Pi' }, { 'lhs' : 'Q',  'rhs' : '\Theta' }, { 'lhs' : 'S',  'rhs' : '\Sigma' }, { 'lhs' : 'U',  'rhs' : '\Upsilon' }, { 'lhs' : 'W',  'rhs' : '\Omega' }, { 'lhs' : 'X',  'rhs' : '\Xi' }, { 'lhs' : 'Y',  'rhs' : '\Psi' }, { 'lhs' : 've', 'rhs' : '\varepsilon' }, { 'lhs' : 'vf', 'rhs' : '\varphi' }, { 'lhs' : 'vk', 'rhs' : '\varkappa' }, { 'lhs' : 'vq', 'rhs' : '\vartheta' }, { 'lhs' : 'vr', 'rhs' : '\varrho' }, { 'lhs' : '/',  'rhs' : 'vimtex#imaps#style_math("slashed")', 'expr' : 1, 'leader' : '#'}, { 'lhs' : 'b',  'rhs' : 'vimtex#imaps#style_math("mathbf")', 'expr' : 1, 'leader' : '#'}, { 'lhs' : 'f',  'rhs' : 'vimtex#imaps#style_math("mathfrak")', 'expr' : 1, 'leader' : '#'}, { 'lhs' : 'c',  'rhs' : 'vimtex#imaps#style_math("mathcal")', 'expr' : 1, 'leader' : '#'}, { 'lhs' : '-',  'rhs' : 'vimtex#imaps#style_math("overline")', 'expr' : 1, 'leader' : '#'}, { 'lhs' : 'B',  'rhs' : 'vimtex#imaps#style_math("mathbb")', 'expr' : 1, 'leader' : '#'}, { 'lhs' : g:vimtex_imaps_leader,   'rhs' : repeat(g:vimtex_imaps_leader, 2),   'wrapper' : 'vimtex#imaps#wrap_trivial'},])
                            
    1   0.000016   0.000005   call s:init_option('vimtex_indent_enabled', 1)
    1   0.000016   0.000005   call s:init_option('vimtex_indent_bib_enabled', 1)
    1   0.000016   0.000004   call s:init_option('vimtex_indent_tikz_commands', 1)
    1   0.000020   0.000008   call s:init_option('vimtex_indent_conditionals', { 'open': '\v%(\\newif)@<!\\if%(f>|field|name|numequal|thenelse|toggle)@!', 'else': '\\else\>', 'close': '\\fi\>',})
    1   0.000021   0.000009   call s:init_option('vimtex_indent_delims', { 'open' : ['{'], 'close' : ['}'], 'close_indented' : 0, 'include_modified_math' : 1,})
    1   0.000017   0.000005   call s:init_option('vimtex_indent_ignored_envs', ['document'])
    1   0.000018   0.000006   call s:init_option('vimtex_indent_lists', [ 'itemize', 'description', 'enumerate', 'thebibliography',])
    1   0.000016   0.000005   call s:init_option('vimtex_indent_on_ampersands', 1)
                            
    1   0.000016   0.000004   call s:init_option('vimtex_mappings_enabled', 1)
    1   0.000016   0.000005   call s:init_option('vimtex_mappings_disable', {})
    1   0.000023   0.000005   call s:init_option('vimtex_mappings_override_existing', 0)
                            
    1   0.000016   0.000005   call s:init_option('vimtex_mappings_prefix', '<localleader>l')
                            
    1   0.000016   0.000004   call s:init_option('vimtex_matchparen_enabled', 1)
    1   0.000016   0.000004   call s:init_option('vimtex_motion_enabled', 1)
                            
    1   0.000016   0.000004   call s:init_option('vimtex_labels_enabled', 1)
    1   0.000016   0.000004   call s:init_option('vimtex_labels_refresh_always', 1)
                            
                            
    1              0.000007   let s:chktexrc = (empty($XDG_CONFIG_HOME) ? $HOME . '/.config' : $XDG_CONFIG_HOME) . '/chktexrc'
                            
    1   0.000024   0.000012   call s:init_option('vimtex_lint_chktex_parameters', filereadable(s:chktexrc)   ? '--localrc ' . shellescape(s:chktexrc)   : '')
    1   0.000017   0.000005   call s:init_option('vimtex_lint_chktex_ignore_warnings', '-n1 -n3 -n8 -n25 -n36')
                            
    1   0.000016   0.000005   call s:init_option('vimtex_parser_bib_backend', 'bibtex')
    1   0.000017   0.000005   call s:init_option('vimtex_parser_cmd_separator_check', 'vimtex#cmd#parser_separator_check')
                            
    1   0.000016   0.000004   call s:init_option('vimtex_quickfix_enabled', 1)
    1   0.000016   0.000005   call s:init_option('vimtex_quickfix_method', 'latexlog')
    1   0.000016   0.000004   call s:init_option('vimtex_quickfix_autojump', 0)
    1   0.000016   0.000005   call s:init_option('vimtex_quickfix_ignore_filters', [])
    1   0.000016   0.000004   call s:init_option('vimtex_quickfix_mode', 2)
    1   0.000016   0.000005   call s:init_option('vimtex_quickfix_open_on_warning', 1)
    1   0.000016   0.000005   call s:init_option('vimtex_quickfix_blgparser', {})
    1   0.000017   0.000005   call s:init_option('vimtex_quickfix_autoclose_after_keystrokes', 0)
                            
    1   0.000016   0.000004   call s:init_option('vimtex_subfile_start_local', 0)
                            
    1   0.000016   0.000004   call s:init_option('vimtex_syntax_enabled', 1)
    1   0.000028   0.000017   call s:init_option('vimtex_syntax_conceal', { 'accents': 1, 'ligatures': 1, 'cites': 1, 'fancy': 1, 'spacing': 1, 'greek': 1, 'math_bounds': 1, 'math_delimiters': 1, 'math_fracs': 1, 'math_super_sub': 1, 'math_symbols': 1, 'sections': 0, 'styles': 1,})
    1   0.000019   0.000008   call s:init_option('vimtex_syntax_conceal_cites', { 'type': 'brackets', 'icon': '📖', 'verbose': v:true,})
    1   0.000016   0.000005   call s:init_option('vimtex_syntax_conceal_disable', 0)
    1   0.000016   0.000005   call s:init_option('vimtex_syntax_custom_cmds', [])
    1   0.000017   0.000005   call s:init_option('vimtex_syntax_custom_cmds_with_concealed_delims', [])
    1   0.000016   0.000005   call s:init_option('vimtex_syntax_custom_envs', [])
    1   0.000016   0.000005   call s:init_option('vimtex_syntax_match_unicode', v:true)
    1   0.000044   0.000032   call s:init_option('vimtex_syntax_nested', { 'aliases' : {   'C' : 'c',   'csharp' : 'cs', }, 'ignored' : {   'sh' : ['shSpecial'],   'bash' : ['shSpecial'],   'cs' : [     'csBraces',   ],   'haskell' : [     'hsVarSym',   ],   'java' : [     'javaError',   ],   'lua' : [     'luaParen',     'luaParenError',   ],   'markdown' : [     'mkdNonListItemBlock',   ],   'python' : [     'pythonEscape',     'pythonBEscape',     'pythonBytesEscape',   ], }})
    1   0.000017   0.000005   call s:init_option('vimtex_syntax_nospell_comments', 0)
    1   0.000025   0.000013   call s:init_option('vimtex_syntax_packages', { 'amsmath': {'conceal': 1, 'load': 2}, 'babel': {'conceal': 1}, 'hyperref': {'conceal': 1}, 'fontawesome5': {'conceal': 1},})
                            
                              " Disable conceals if chosen
    1              0.000001   if g:vimtex_syntax_conceal_disable
                                call map(g:vimtex_syntax_conceal, {k, v -> 0})
                                let g:vimtex_syntax_packages.amsmath.conceal = 0
                                let g:vimtex_syntax_packages.babel.conceal = 0
                                let g:vimtex_syntax_packages.hyperref.conceal = 0
                                let g:vimtex_syntax_packages.fontawesome5.conceal = 0
    1              0.000001   endif
                            
    1   0.000016   0.000004   call s:init_option('vimtex_texcount_custom_arg', '')
                            
    1   0.000016   0.000004   call s:init_option('vimtex_text_obj_enabled', 1)
    1   0.000016   0.000004   call s:init_option('vimtex_text_obj_variant', 'auto')
    1   0.000017   0.000005   call s:init_option('vimtex_text_obj_linewise_operators', ['d', 'y'])
                            
    1   0.000016   0.000004   call s:init_option('vimtex_toc_enabled', 1)
    1   0.000055   0.000044   call s:init_option('vimtex_toc_config', { 'name' : 'Table of contents (VimTeX)', 'mode' : 1, 'fold_enable' : 0, 'fold_level_start' : -1, 'hide_line_numbers' : 1, 'hotkeys_enabled' : 0, 'hotkeys' : 'abcdeilmnopuvxyz', 'hotkeys_leader' : ';', 'indent_levels' : 0, 'layer_status' : {   'content': 1,   'label': 1,   'todo': 1,   'include': 1, }, 'layer_keys' : {   'content': 'C',   'label': 'L',   'todo': 'T',   'include': 'I', }, 'resize' : 0, 'refresh_always' : 1, 'show_help' : 1, 'show_numbers' : 1, 'split_pos' : 'vert leftabove', 'split_width' : 50, 'tocdepth' : 3, 'todo_sorted' : 1,})
    1   0.000017   0.000005   call s:init_option('vimtex_toc_config_matchers', {})
    1   0.000016   0.000005   call s:init_option('vimtex_toc_custom_matchers', [])
    1   0.000016   0.000004   call s:init_option('vimtex_toc_show_preamble', 1)
    1   0.000018   0.000006   call s:init_option('vimtex_toc_todo_labels', { 'TODO': 'TODO: ', 'FIXME': 'FIXME: '})
                            
    1   0.000019   0.000007   call s:init_option('vimtex_toggle_fractions', { 'INLINE': 'frac', 'frac': 'INLINE', 'dfrac': 'INLINE',})
                            
    1   0.000025   0.000014   call s:init_option('vimtex_ui_method', { 'confirm': has('nvim') ? 'nvim' : 'legacy', 'input': has('nvim') ? 'nvim' : 'legacy', 'select': has('nvim') ? 'nvim' : 'legacy',})
                            
    1   0.000016   0.000004   call s:init_option('vimtex_view_enabled', 1)
    1   0.000016   0.000004   call s:init_option('vimtex_view_automatic', 1)
    1   0.000016   0.000005   call s:init_option('vimtex_view_method', 'general')
    1   0.000017   0.000005   call s:init_option('vimtex_view_use_temp_files', 0)
    1   0.000016   0.000005   call s:init_option('vimtex_view_forward_search_on_start', 1)
    1   0.000017   0.000005   call s:init_option('vimtex_view_reverse_search_edit_cmd', 'edit')
                            
                              " OS dependent defaults
    1   0.004774   0.000041   let l:os = vimtex#util#get_os()
    1              0.000001   if l:os ==# 'win'
                                if executable('SumatraPDF')
                                  call s:init_option('vimtex_view_general_viewer', 'SumatraPDF')
                                  call s:init_option('vimtex_view_general_options', '-reuse-instance -forward-search @tex @line @pdf')
                                elseif executable('mupdf')
                                  call s:init_option('vimtex_view_general_viewer', 'mupdf')
                                  call s:init_option('vimtex_view_general_options', '@pdf')
                                else
                                  call s:init_option('vimtex_view_general_viewer', 'start ""')
                                  call s:init_option('vimtex_view_general_options', '@pdf')
                                endif
    1              0.000001   else
    1   0.000023   0.000010     call s:init_option('vimtex_view_general_viewer', get({ 'linux' : 'xdg-open', 'mac'   : 'open',}, l:os, ''))
    1   0.000017   0.000005     call s:init_option('vimtex_view_general_options', '@pdf')
    1              0.000001   endif
                            
    1   0.000016   0.000005   call s:init_option('vimtex_view_mupdf_options', '')
    1   0.000016   0.000005   call s:init_option('vimtex_view_mupdf_send_keys', '')
    1   0.000016   0.000005   call s:init_option('vimtex_view_sioyek_exe', 'sioyek')
    1   0.000016   0.000004   call s:init_option('vimtex_view_sioyek_options', '')
    1   0.000018   0.000004   call s:init_option('vimtex_view_skim_activate', 0)
    1   0.000017   0.000005   call s:init_option('vimtex_view_skim_sync', 0)
    1   0.000016   0.000005   call s:init_option('vimtex_view_skim_reading_bar', 0)
    1   0.000016   0.000004   call s:init_option('vimtex_view_skim_no_select', 0)
    1   0.000016   0.000004   call s:init_option('vimtex_view_texshop_activate', 0)
    1   0.000016   0.000004   call s:init_option('vimtex_view_texshop_sync', 0)
    1   0.000016   0.000004   call s:init_option('vimtex_view_zathura_options', '')
    1   0.000016   0.000005   call s:init_option('vimtex_view_zathura_check_libsynctex', 1)
                            
                              " Fallback option
    1              0.000002   if g:vimtex_context_pdf_viewer ==# 'NONE'
    1              0.000002     let g:vimtex_context_pdf_viewer = g:vimtex_view_general_viewer
    1              0.000000   endif
                            
    1              0.000001   let s:initialized = v:true

FUNCTION  vimtex#fold#init_state()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold.vim:35
Called 1 time
Total time:   0.001656
 Self time:   0.000827

count  total (s)   self (s)
                              "
                              " Initialize the enabled fold types
                              "
    1              0.000002   let a:state.fold_types_dict = {}
   12              0.000027   for [l:key, l:val] in items(g:vimtex_fold_types_defaults)
   11              0.000074     let l:config = extend(deepcopy(l:val), get(g:vimtex_fold_types, l:key, {}))
   11              0.000025     if get(l:config, 'enabled', 1)
   10   0.001239   0.000410       let a:state.fold_types_dict[l:key] = vimtex#fold#{l:key}#new(l:config)
   11              0.000006     endif
   12              0.000007   endfor
                            
                              "
                              " Define ordered list and the global fold regex
                              "
    1              0.000002   let a:state.fold_types_ordered = []
    1              0.000004   let a:state.fold_re = '\v' .  '\\%(begin|end)>' . '|^\s*\%' . '|^\s*\]\s*%(\{|$)' . '|^\s*}'
    1              0.000001   let a:state.fold_re_next = ''
   12              0.000021   for l:name in [ 'preamble', 'cmd_single', 'cmd_single_opt', 'cmd_multi', 'cmd_addplot', 'sections', 'markers', 'comments', 'items', 'envs', 'env_options',]
   11              0.000035     let l:type = get(a:state.fold_types_dict, l:name, {})
   11              0.000017     if !empty(l:type)
   10              0.000022       call add(a:state.fold_types_ordered, l:type)
   10              0.000021       if exists('l:type.re.fold_re')
    8              0.000021         let a:state.fold_re .= '|' . l:type.re.fold_re
   10              0.000005       endif
   10              0.000020       if exists('l:type.re.fold_re_next')
    1              0.000005         let a:state.fold_re_next .= (empty(a:state.fold_re_next) ? '\v' : '|') . l:type.re.fold_re_next
   10              0.000005       endif
   11              0.000005     endif
   12              0.000006   endfor

FUNCTION  vimtex#syntax#in_comment()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/syntax.vim:23
Called 43 times
Total time:   0.005429
 Self time:   0.001087

count  total (s)   self (s)
   43   0.005386   0.001044   return call('vimtex#syntax#in', ['texComment'] + a:000)

FUNCTION  <SNR>53_init_option()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/options.vim:642
Called 112 times
Total time:   0.001318
 Self time:   0.001318

count  total (s)   self (s)
  112              0.000200   let l:option = 'g:' . a:option
  112              0.000232   if !exists(l:option)
  112              0.000271     let {l:option} = a:default
                              elseif type(a:default) == v:t_dict
                                call vimtex#util#extend_recursive({l:option}, a:default, 'keep')
  112              0.000052   endif

FUNCTION  vimtex#compiler#latexmk#get_rc_opt()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/latexmk.vim:13
Called 3 times
Total time:   0.000568
 Self time:   0.000568

count  total (s)   self (s)
                              "
                              " Parse option from .latexmkrc.
                              "
                              " Arguments:
                              "   root         Root of LaTeX project
                              "   opt          Name of options
                              "   type         0 if string, 1 if integer, 2 if list
                              "   default      Value to return if option not found in latexmkrc file
                              "
                              " Output:
                              "   [value, location]
                              "
                              "   value        Option value (integer or string)
                              "   location     An integer that indicates where option was found
                              "                 -1: not found (default value returned)
                              "                  0: global latexmkrc file
                              "                  1: local latexmkrc file
                              "
                            
    3              0.000008   if a:type == 0
    2              0.000006     let l:pattern = '^\s*\$' . a:opt . '\s*=\s*[''"]\(.\+\)[''"]'
    1              0.000004   elseif a:type == 1
    1              0.000009     let l:pattern = '^\s*\$' . a:opt . '\s*=\s*\(\d\+\)'
                              elseif a:type == 2
                                let l:pattern = '^\s*@' . a:opt . '\s*=\s*(\(.*\))'
                              else
                                throw 'VimTeX: Argument error'
    3              0.000002   endif
                            
                              " Candidate files
                              " - each element is a pair [path_to_file, is_local_rc_file].
    3              0.000105   let l:files = [ [a:root . '/latexmkrc', 1], [a:root . '/.latexmkrc', 1], [fnamemodify('~/.latexmkrc', ':p'), 0], [fnamemodify(    !empty($XDG_CONFIG_HOME) ? $XDG_CONFIG_HOME : '~/.config', ':p')    . '/latexmk/latexmkrc', 0]]
                            
    3              0.000012   let l:result = [a:default, -1]
                            
   15              0.000068   for [l:file, l:is_local] in l:files
   12              0.000068     if filereadable(l:file)
                                  let l:match = matchlist(readfile(l:file), l:pattern)
                                  if len(l:match) > 1
                                    let l:result = [l:match[1], l:is_local]
                                    break
                                  end
   12              0.000008     endif
   15              0.000011   endfor
                            
                              " Parse the list
    3              0.000006   if a:type == 2 && l:result[1] > -1
                                let l:array = split(l:result[0], ',')
                                let l:result[0] = []
                                for l:x in l:array
                                  let l:x = substitute(l:x, "^'", '', '')
                                  let l:x = substitute(l:x, "'$", '', '')
                                  let l:result[0] += [l:x]
                                endfor
    3              0.000002   endif
                            
    3              0.000003   return l:result

FUNCTION  vimtex#state#init_local()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state.vim:36
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000003   let l:preserve_root = get(s:, 'subfile_preserve_root')
    1              0.000002   unlet! s:subfile_preserve_root
                            
    1              0.000006   if &filetype !=# 'tex' || empty(b:vimtex.tex) | return | endif
                            
    1              0.000008   let l:filename = expand('%:p')
    1              0.000003   if b:vimtex.tex ==# l:filename | return | endif
                            
                              let l:vimtex_id = s:get_main_id(l:filename)
                            
                              if l:vimtex_id < 0
                                let l:vimtex_id = s:vimtex_next_id
                                let l:vimtex = vimtex#state#class#new({ 'main': l:filename, 'main_parser': 'local file', 'preserve_root': l:preserve_root || s:check_standalone(),})
                                let s:vimtex_next_id += 1
                                let s:vimtex_states[l:vimtex_id] = l:vimtex
                            
                                if !has_key(b:vimtex, 'subids')
                                  let b:vimtex.subids = []
                                endif
                                call add(b:vimtex.subids, l:vimtex_id)
                                let l:vimtex.main_id = b:vimtex_id
                              endif
                            
                              let b:vimtex_local = { 'active' : 0, 'main_id' : b:vimtex_id, 'sub_id' : l:vimtex_id,}
                            
                              if b:vimtex.main_parser ==# 'subfiles' && g:vimtex_subfile_start_local
                                silent call vimtex#state#toggle_main()
                              endif

FUNCTION  <SNR>52_init_state()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex.vim:30
Called 1 time
Total time:   0.009157
 Self time:   0.000048

count  total (s)   self (s)
    1   0.009125   0.000039   call vimtex#state#init()
    1   0.000032   0.000008   call vimtex#state#init_local()

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/local/share/nvim/runtime/ftplugin.vim:14
Called 9 times
Total time:   0.053934
 Self time:   0.013844

count  total (s)   self (s)
    9              0.000038     if exists("b:undo_ftplugin")
    5              0.000063       exe b:undo_ftplugin
    5              0.000011       unlet! b:undo_ftplugin b:did_ftplugin
    9              0.000006     endif
                            
    9              0.000036     let s = expand("<amatch>")
    9              0.000016     if s != ""
    9              0.000067       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    9              0.000005       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   18              0.000060       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
    9   0.053466   0.013377         exe printf('runtime! ftplugin/%s.vim ftplugin/%s.lua ftplugin/%s_*.vim ftplugin/%s_*.lua ftplugin/%s/*.vim ftplugin/%s/*.lua', name, name, name, name, name, name)
   18              0.000025       endfor
    9              0.000006     endif

FUNCTION  <SNR>90_init_delim_lists()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:1013
Called 1 time
Total time:   0.000455
 Self time:   0.000357

count  total (s)   self (s)
                              " Define the default value
    1              0.000198   let l:lists = { 'env_tex' : {   'name' : [['begin', 'end']],   're' : [['\\begin\s*{[^}]*}', '\\end\s*{[^}]*}']], }, 'env_math' : {   'name' : [     ['\(', '\)'],     ['\[', '\]'],     ['$$', '$$'],     ['$', '$'],   ],   're' : [     ['\\(', '\\)'],     ['\\\@<!\\\[', '\\\]'],     ['\$\$', '\$\$'],     ['\$', '\$'],   ], }, 'delim_tex' : {   'name' : [     ['[', ']'],     ['{', '}'],   ],   're' : [     ['\[', '\]'],     ['\\\@<!{', '\\\@<!}'],   ] }, 'delim_math' : {   'name' : [     ['(', ')'],     ['[', ']'],     ['\{', '\}'],     ['\langle', '\rangle'],     ['\lbrace', '\rbrace'],     ['\lvert', '\rvert'],     ['\lVert', '\rVert'],     ['\lfloor', '\rfloor'],     ['\lceil', '\rceil'],     ['\ulcorner', '\urcorner'],   ] }, 'mods' : {   'name' : [     ['\left', '\right'],     ['\bigl', '\bigr'],     ['\Bigl', '\Bigr'],     ['\biggl', '\biggr'],     ['\Biggl', '\Biggr'],     ['\big', '\big'],     ['\Big', '\Big'],     ['\bigg', '\bigg'],     ['\Bigg', '\Bigg'],   ],   're' : [     ['\\left', '\\right'],     ['\\bigl', '\\bigr'],     ['\\Bigl', '\\Bigr'],     ['\\biggl', '\\biggr'],     ['\\Biggl', '\\Biggr'],     ['\\big\>', '\\big\>'],     ['\\Big\>', '\\Big\>'],     ['\\bigg\>', '\\bigg\>'],     ['\\Bigg\>', '\\Bigg\>'],   ] },}
                            
                              " Get user defined lists
    1              0.000006   call extend(l:lists, get(g:, 'vimtex_delim_list', {}))
                            
                              " Generate corresponding regexes if necessary
    6              0.000008   for l:type in values(l:lists)
    5              0.000016     if !has_key(l:type, 're') && has_key(l:type, 'name')
    1   0.000131   0.000033       let l:type.re = map(deepcopy(l:type.name), {i1, x -> map(x, {i2, y -> escape(y, '\$[]')})})
    5              0.000003     endif
    6              0.000003   endfor
                            
                              " Generate combined lists
    1              0.000002   let l:lists.env_all = {}
    1              0.000002   let l:lists.delim_all = {}
    1              0.000002   let l:lists.all = {}
    3              0.000004   for k in ['name', 're']
    2              0.000010     let l:lists.env_all[k] = l:lists.env_tex[k] + l:lists.env_math[k]
    2              0.000009     let l:lists.delim_all[k] = l:lists.delim_math[k] + l:lists.delim_tex[k]
    2              0.000009     let l:lists.all[k] = l:lists.env_all[k] + l:lists.delim_all[k]
    3              0.000002   endfor
                            
    1              0.000001   return l:lists

FUNCTION  18()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state/class.vim:121
Called 4 times
Total time:   0.006522
 Self time:   0.006054

count  total (s)   self (s)
    4              0.000019   if !has_key(self, 'compiler') | return | endif
                            
                              " Try to parse .fls file if present, as it is usually more complete. That is,
                              " it contains a generated list of all the packages that are used.
  380   0.000884   0.000416   for l:line in vimtex#parser#fls(self.compiler.get_file('fls'))
  376              0.003056     let l:package = matchstr(l:line, '^INPUT \zs.\+\ze\.sty$')
  376              0.000915     let l:package = fnamemodify(l:package, ':t')
  376              0.000586     if !empty(l:package)
  144              0.000308       let self.packages[l:package] = {}
  376              0.000169     endif
  380              0.000203   endfor

FUNCTION  19()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state/class.vim:136
Called 1 time
Total time:   0.001299
 Self time:   0.000218

count  total (s)   self (s)
    1              0.000007   let l:tex_program_re = '\v^\c\s*\%\s*!?\s*tex\s+%(ts-)?program\s*\=\s*\zs.*\ze\s*$'
                            
    1   0.001113   0.000033   let l:lines = vimtex#parser#preamble(self.tex, {'root' : self.root})[:20]
    1              0.000135   call map(l:lines, 'matchstr(v:val, l:tex_program_re)')
    1              0.000030   call filter(l:lines, '!empty(v:val)')
    1              0.000010   return tolower(get(l:lines, -1, '_'))

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/local/share/nvim/runtime/indent.vim:13
Called 9 times
Total time:   0.003182
 Self time:   0.002515

count  total (s)   self (s)
    9              0.000027     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    9              0.000005     endif
    9              0.000035     let s = expand("<amatch>")
    9              0.000016     if s != ""
    9              0.000019       if exists("b:did_indent")
    1              0.000002 	unlet b:did_indent
    9              0.000005       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   18              0.000053       for name in split(s, '\.')
    9   0.001897   0.001229         exe 'runtime! indent/' . name . '.vim'
    9              0.001017         exe 'runtime! indent/' . name . '.lua'
   18              0.000015       endfor
    9              0.000005     endif

FUNCTION  vimtex#fold#cmd_multi#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_multi.vim:7
Called 1 time
Total time:   0.000026
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000026   0.000008   return extend(deepcopy(s:folder), a:config).init()

FUNCTION  <SNR>43_SynSet()
    Defined: /usr/local/share/nvim/runtime/syntax/synload.vim:26
Called 11 times
Total time:   0.005524
 Self time:   0.005275

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   11              0.000062   syn clear
   11              0.000058   if exists("b:current_syntax")
                                unlet b:current_syntax
   11              0.000012   endif
                            
   11              0.000068   0verbose let s = expand("<amatch>")
   11              0.000022   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   11              0.000017   elseif s == "OFF"
                                let s = ""
   11              0.000006   endif
                            
   11              0.000013   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   14              0.000056     for name in split(s, '\.')
    7              0.000016       if !empty(name)
    7   0.002731   0.002482         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    7              0.002184         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
    7              0.000007       endif
   14              0.000012     endfor
   11              0.000007   endif

FUNCTION  20()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state/class.vim:147
Called 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000007   if self.main_parser ==# 'fallback current file'
                                " This conditional branch essentially means VimTeX gave up on finding the
                                " current project's main file. This _sometimes_ indicates a file that is
                                " not compileable. We therefore do a weak check of whether the file is
                                " compileable by looking for the classic preamble header and
                                " \begin{document} + \end{document}.
                            
                                let l:lines = getline(1, '$')
                                let l:index = match(l:lines, '^\s*\\documentclass\_\s*[\[{]')
                                if l:index < 0 | return v:false | endif
                            
                                let l:index = match(l:lines, '^\s*\\begin\s*{document}', l:index+1)
                                if l:index < 0 | return v:false | endif
                            
                                let l:index = match(l:lines, '^\s*\\end\s*{document}', l:index+1)
                                return l:index >= 0
    1              0.000001   endif
                            
    1              0.000003   return v:true

FUNCTION  22()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view/_template.vim:16
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000008   let l:viewer = deepcopy(self)
    1              0.000002   unlet l:viewer.init
    1              0.000001   return l:viewer

FUNCTION  23()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view/_template.vim:23
Called 3 times
Total time:   0.000070
 Self time:   0.000028

count  total (s)   self (s)
    3              0.000008   if !has_key(self, '_check_value')
    1   0.000048   0.000006     let self._check_value = self._check()
    3              0.000002   endif
                            
    3              0.000004   return self._check_value

FUNCTION  24()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view/_template.vim:32
Called 3 times
Total time:   0.000248
 Self time:   0.000096

count  total (s)   self (s)
    3   0.000168   0.000015   let l:out = b:vimtex.compiler.get_file('pdf')
                            
                              " Copy pdf and synctex files if we use temporary files
    3              0.000005   if g:vimtex_view_use_temp_files
                                let l:temp = b:vimtex.root . '/' . b:vimtex.name . '_vimtex.pdf'
                                if getftime(l:out) > getftime(l:temp)
                                  call writefile(readfile(l:out, 'b'), l:temp, 'b')
                                endif
                                let l:out = l:temp
                            
                                let l:old = b:vimtex.compiler.get_file('synctex.gz')
                                let l:new = fnamemodify(l:out, ':r') . '.synctex.gz'
                                if getftime(l:old) > getftime(l:new)
                                  call rename(l:old, l:new)
                                endif
    3              0.000001   endif
                            
    3              0.000013   return filereadable(l:out) ? l:out : ''

FUNCTION  26()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view/_template.vim:80
Called 3 times
Total time:   0.002294
 Self time:   0.000042

count  total (s)   self (s)
    3              0.000014   if !g:vimtex_view_automatic || has_key(self, 'started_through_callback') | return | endif
                            
    1   0.002260   0.000008   call self._start(a:outfile)
    1              0.000004   let self.started_through_callback = 1
                            
    1              0.000009   if exists('#User#VimtexEventView')
                                doautocmd <nomodeline> User VimtexEventView
    1              0.000001   endif

FUNCTION  <SNR>90_get_delim()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:510
Called 46 times
Total time:   0.044388
 Self time:   0.033943

count  total (s)   self (s)
                              " Arguments:
                              "   opts = {
                              "     'direction'   :  next
                              "                      prev
                              "                      current
                              "     'type'        :  env_tex
                              "                      env_math
                              "                      env_all
                              "                      delim_tex
                              "                      delim_math
                              "                      delim_modq_math (possibly modified math delimiter)
                              "                      delim_mod_math  (modified math delimiter)
                              "                      delim_all
                              "                      all
                              "     'side'        :  open
                              "                      close
                              "                      both
                              "     'syn_exclude' :  Don't match in given syntax
                              "  }
                              "
                              " Returns:
                              "   delim = {
                              "     type    : env | delim
                              "     side    : open | close
                              "     name    : name of environment [only for type env]
                              "     lnum    : number
                              "     cnum    : number
                              "     match   : unparsed matched delimiter
                              "     corr    : corresponding delimiter
                              "     re : {
                              "       open  : regexp for the opening part
                              "       close : regexp for the closing part
                              "     }
                              "     remove  : method to remove the delimiter
                              "   }
                              "
   46   0.001094   0.000699   let l:save_pos = vimtex#pos#get_cursor()
   46              0.000609   let l:re = g:vimtex#delim#re[a:opts.type][a:opts.side]
   46              0.000142   while 1
   46              0.014801     let [l:lnum, l:cnum] = a:opts.direction ==# 'next' ? searchpos(l:re, 'cnW', line('.') + g:vimtex_delim_stopline) : a:opts.direction ==# 'prev'   ? searchpos(l:re, 'bcnW', max([line('.') - g:vimtex_delim_stopline, 1]))   : searchpos(l:re, 'bcnW', line('.'))
   46              0.000424     if l:lnum == 0 | break | endif
                            
    4              0.000037     if has_key(a:opts, 'syn_exclude') && vimtex#syntax#in(a:opts.syn_exclude, l:lnum, l:cnum)
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:lnum, l:cnum))
                                  continue
    4              0.000004     endif
                            
    4              0.000005     break
   46              0.000130   endwhile
   46   0.004468   0.000781   call vimtex#pos#set_cursor(l:save_pos)
                            
   46              0.003962   let l:match = matchstr(getline(l:lnum), '^' . l:re, l:cnum-1)
                            
   46              0.000881   if a:opts.direction ==# 'current' && l:cnum + strlen(l:match) + (mode() ==# 'i' ? 1 : 0) <= col('.')
   42              0.000145     let l:match = ''
   42              0.000115     let l:lnum = 0
   42              0.000101     let l:cnum = 0
   46              0.000068   endif
                            
  268              0.000851   for l:parser in s:parsers
  226   0.006866   0.002235     if l:parser.detect(l:match)
    4   0.001841   0.000109       return l:parser.parse({ 'lnum' : l:lnum, 'cnum' : l:cnum, 'match' : l:match, 'remove' : function('s:delim_remove'),}, a:opts)
  222              0.000273     endif
  264              0.000395   endfor
                            
   42              0.000127   return {}

FUNCTION  113()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/envs.vim:24
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                              " Define the validator as simple as possible
    1              0.000004   if empty(self.whitelist) && empty(self.blacklist)
    1              0.000002     function! self.validate(env) abort dict
                                  return 1
                                endfunction
                              elseif empty(self.whitelist)
                                function! self.validate(env) abort dict
                                  return index(self.blacklist, a:env) < 0
                                endfunction
                              elseif empty(self.blacklist)
                                function! self.validate(env) abort dict
                                  return index(self.whitelist, a:env) >= 0
                                endfunction
                              else
                                function! self.validate(env) abort dict
                                  return index(self.whitelist, a:env) >= 0 && index(self.blacklist, a:env) < 0
                                endfunction
    1              0.000001   endif
                            
    1              0.000001   return self

FUNCTION  <SNR>52_map()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex.vim:411
Called 134 times
Total time:   0.004752
 Self time:   0.004752

count  total (s)   self (s)
  134              0.003777   if (a:ftype == 0     || a:ftype == 1 && &filetype ==# 'tex'     || a:ftype == 2 && &filetype ==# 'bib') && !hasmapto(a:rhs, a:mode) && index(get(g:vimtex_mappings_disable, a:mode, []), a:lhs) < 0 && (a:0 > 0     || g:vimtex_mappings_override_existing     || empty(maparg(a:lhs, a:mode)))
  134              0.000830     silent execute a:mode . 'map <silent><buffer><nowait>' a:lhs a:rhs
  134              0.000061   endif

FUNCTION  vimtex#compiler#start()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler.vim:196
Called 1 time
Total time:   0.007850
 Self time:   0.000405

count  total (s)   self (s)
    1              0.000009   if !b:vimtex.compiler.enabled | return | endif
                            
    1   0.000079   0.000015   if !b:vimtex.is_compileable()
                                call vimtex#log#error( 'Compilation error due to failed mainfile detection!', 'Please ensure that VimTeX can locate the proper main .tex file.', 'Read ":help vimtex-multi-file" for more info.')
                                return
    1              0.000001   endif
    1   0.000059   0.000010   if b:vimtex.compiler.is_running()
                                call vimtex#log#warning( 'Compiler is already running for `' . b:vimtex.base . "'")
                                return
    1              0.000001   endif
                            
    1   0.004430   0.000021   call b:vimtex.compiler.start()
                            
    1              0.000004   if g:vimtex_compiler_silent | return | endif
                            
                              " We add a redraw here to clear messages (e.g. file written). This is useful
                              " to avoid the "Press ENTER" prompt in some cases, see e.g.
                              " https://github.com/lervag/vimtex/issues/2149
    1              0.000284   redraw
                            
    1              0.000006   if b:vimtex.compiler.continuous
    1   0.002937   0.000016     call vimtex#log#info('Compiler started in continuous mode')
                              else
                                call vimtex#log#info('Compiler started in background!')
    1              0.000001   endif

FUNCTION  39()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view/general.vim:18
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
                              " Check if the viewer is executable
                              " * split to ensure that we handle stuff like "gio open"
    1              0.000011   let l:exe = get(split(g:vimtex_view_general_viewer), 0, '')
    1              0.000020   if empty(l:exe) || (!executable(l:exe)     && !(vimtex#util#get_os() ==# 'win'          && g:vimtex_view_general_viewer ==# 'start ""'))
                                call vimtex#log#warning( 'Generic viewer is not executable!', '- Viewer: ' . g:vimtex_view_general_viewer, '- Executable: ' . l:exe, '- Please see :h g:vimtex_view_general_viewer')
                                return v:false
    1              0.000001   endif
                            
    1              0.000001   return v:true

FUNCTION  <SNR>90_get_timeout()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:963
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000034   return (empty(v:insertmode) ? mode() : v:insertmode) ==# 'i' ? g:vimtex_delim_insert_timeout : g:vimtex_delim_timeout

FUNCTION  120()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_single_opt.vim:20
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000005   let l:re = '\v^\s*\\%(' . join(self.cmds, '|') . ')\*?'
                            
    1              0.000003   let self.re.start = l:re . '\s*\[\s*%($|\%)'
    1              0.000002   let self.re.end = '^\s*\]{'
    1              0.000002   let self.re.text = l:re
    1              0.000004   let self.re.fold_re = '\\%(' . join(self.cmds, '|') . ')'
                            
    1              0.000001   return self

FUNCTION  123()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/markers.vim:21
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000003   let self.re.start = '%.*' . self.open
    1              0.000002   let self.re.end = '%.*' . self.close
    1              0.000010   let self.re.text = [ [self.re.start . '\d\?\s*\zs.*', '% ' . self.open . ' '], ['%\s*\zs.*\ze' . self.open, '% ' . self.open . ' '], ['^.*\ze\s*%', ''],]
                            
    1              0.000005   let self.re.fold_re = escape(self.open . '|' . self.close, '{}%+*.')
                            
    1              0.000001   return self

FUNCTION  128()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/sections.vim:23
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000005   let self.re.parts = '\v^\s*\\%(' . join(self.parts, '|') . ')'
    1              0.000005   let self.re.sections = '\v^\s*\\%(' . join(self.sections, '|') . ')'
    1              0.000005   let self.re.fake_sections = '\v^\s*\% Fake%(' . join(self.sections, '|') . ').*'
    1              0.000005   let self.re.any_sections = '\v^\s*%(\\|\% Fake)%(' . join(self.sections, '|') . ').*'
                            
    1              0.000005   let self.re.start = self.re.parts . '|' . self.re.sections . '|' . self.re.fake_sections
                            
    1              0.000003   let self.re.secpat1 = self.re.sections . '\*?\s*\{\zs.*'
    1              0.000002   let self.re.secpat2 = self.re.sections . '\*?\s*\[\zs.*'
                            
    1              0.000007   let self.re.fold_re = '\\%(' . join(self.parts + self.sections, '|') . ')'
                            
    1              0.000001   return self

FUNCTION  vimtex#compiler#_template#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/_template.vim:7
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000013   return extend(deepcopy(s:compiler), a:opts)

FUNCTION  40()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view/general.vim:38
Called 1 time
Total time:   0.002252
 Self time:   0.000098

count  total (s)   self (s)
                              " Update file path for Windows+cygwin
    1              0.000020   let l:path_pdf = executable('cygpath') ? join(vimtex#jobs#capture('cygpath -aw "' . a:file . '"'), '') : a:file
                            
                              " Escapes for shell command and the substitute
    1   0.000035   0.000014   let l:path_tex = vimtex#util#shellescape(expand('%:p'))
    1              0.000003   let l:path_tex = escape(l:path_tex, '&')
    1   0.000020   0.000005   let l:path_pdf = vimtex#util#shellescape(l:path_pdf)
    1              0.000003   let l:path_pdf = escape(l:path_pdf, '&')
                            
                              " Parse options
    1              0.000002   let l:cmd = g:vimtex_view_general_viewer
    1              0.000003   let l:cmd .= ' ' . g:vimtex_view_general_options
                            
                              " Substitute magic patterns
    1              0.000007   let l:cmd = substitute(l:cmd, '@line', line('.'), 'g')
    1              0.000006   let l:cmd = substitute(l:cmd, '@col', col('.'), 'g')
    1              0.000004   let l:cmd = substitute(l:cmd, '@tex', l:path_tex, 'g')
    1              0.000005   let l:cmd = substitute(l:cmd, '@pdf', l:path_pdf, 'g')
                            
                              " Start the view process
                              " NB: Use vimtex#jobs#start to ensure it runs in the background
    1   0.002139   0.000021   let self.job = vimtex#jobs#start(l:cmd, { 'detached': vimtex#util#get_os() !=# 'win'})

FUNCTION  <SNR>90_get_corr_delimiter()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:989
Called 3 times
Total time:   0.000411
 Self time:   0.000411

count  total (s)   self (s)
    3              0.000010   let l:type = a:0 > 0 ? a:1 : 'delim_all'
                            
   36              0.000058   for l:pair in g:vimtex#delim#lists[l:type].name
   36              0.000088     if a:delim ==# l:pair[0]
    3              0.000006       return l:pair[1]
   33              0.000081     elseif a:delim ==# l:pair[1]
                                  return l:pair[0]
   33              0.000022     endif
   33              0.000024   endfor

FUNCTION  46()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/_template.vim:26
Called 1 time
Total time:   0.000432
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000013   let l:compiler = extend(deepcopy(self), a:options)
    1              0.000004   let l:backend = has('nvim') ? 'nvim' : 'jobs'
    1              0.000009   call extend(l:compiler, deepcopy(s:compiler_{l:backend}))
                            
    1   0.000037   0.000004   call l:compiler.__check_requirements()
                            
    1   0.000013   0.000007   call vimtex#util#materialize_property(l:compiler, 'out_dir')
    1   0.000336   0.000003   call l:compiler.__init()
                            
                              " $VIMTEX_OUTPUT_DIRECTORY overrides configured compiler.out_dir
    1              0.000003   if !empty($VIMTEX_OUTPUT_DIRECTORY)
                                if !empty(l:compiler.out_dir) && (l:compiler.out_dir !=# $VIMTEX_OUTPUT_DIRECTORY)
                                  call vimtex#log#warning( 'Setting VIMTEX_OUTPUT_DIRECTORY overrides out_dir!', 'Changed out_dir from: ' . l:compiler.out_dir, 'Changed out_dir to: ' . $VIMTEX_OUTPUT_DIRECTORY)
                                endif
                            
                                let l:compiler.out_dir = $VIMTEX_OUTPUT_DIRECTORY
    1              0.000000   endif
                            
                              " Remove init methods
    1              0.000002   unlet l:compiler.new
    1              0.000001   unlet l:compiler.__check_requirements
    1              0.000001   unlet l:compiler.__init
                            
    1              0.000001   return l:compiler

FUNCTION  <SNR>53_check_for_deprecated_options()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/options.vim:514
Called 1 time
Total time:   0.000232
 Self time:   0.000232

count  total (s)   self (s)
    1              0.000217   let l:deprecated = filter([ 'g:vimtex_change_complete_envs', 'g:vimtex_change_ignored_delims_pattern', 'g:vimtex_change_set_formatexpr', 'g:vimtex_change_toggled_delims', 'g:vimtex_compiler_callback_hooks', 'g:vimtex_disable_recursive_main_file_detection', 'g:vimtex_env_complete_list', 'g:vimtex_fold_commands', 'g:vimtex_fold_commands_default', 'g:vimtex_fold_comments', 'g:vimtex_fold_env_blacklist', 'g:vimtex_fold_env_whitelist', 'g:vimtex_fold_envs', 'g:vimtex_fold_markers', 'g:vimtex_fold_parts', 'g:vimtex_fold_preamble', 'g:vimtex_fold_sections', 'g:vimtex_index_hide_line_numbers', 'g:vimtex_index_mode', 'g:vimtex_index_resize', 'g:vimtex_index_show_help', 'g:vimtex_index_split_pos', 'g:vimtex_index_split_width', 'g:vimtex_latexmk_autojump', 'g:vimtex_latexmk_background', 'g:vimtex_latexmk_callback', 'g:vimtex_latexmk_callback_hooks', 'g:vimtex_latexmk_continuous', 'g:vimtex_latexmk_enabled', 'g:vimtex_latexmk_options', 'g:vimtex_latexmk_progname', 'g:vimtex_quickfix_ignore_all_warnings', 'g:vimtex_quickfix_ignored_warnings', 'g:vimtex_quickfix_latexlog', 'g:vimtex_quickfix_warnings', 'g:vimtex_syntax_autoload_packages', 'g:vimtex_syntax_conceal_default', 'g:vimtex_syntax_nospell_commands', 'g:vimtex_textidote_jar', 'g:vimtex_toc_fold', 'g:vimtex_toc_fold_level_start', 'g:vimtex_toc_fold_levels', 'g:vimtex_toc_hide_help', 'g:vimtex_toc_hide_line_numbers', 'g:vimtex_toc_hide_preamble', 'g:vimtex_toc_hotkeys', 'g:vimtex_toc_layers', 'g:vimtex_toc_number_width', 'g:vimtex_toc_numbers', 'g:vimtex_toc_numbers_width', 'g:vimtex_toc_refresh_always', 'g:vimtex_toc_resize', 'g:vimtex_toc_show_numbers', 'g:vimtex_toc_split_pos', 'g:vimtex_toc_tocdepth', 'g:vimtex_toc_width', 'g:vimtex_view_automatic_xwin', 'g:vimtex_view_general_callback', 'g:vimtex_view_general_hook_callback', 'g:vimtex_view_general_hook_view', 'g:vimtex_view_general_options_latexmk', 'g:vimtex_view_mupdf_hook_callback', 'g:vimtex_view_mupdf_hook_view', 'g:vimtex_view_skim_hook_callback', 'g:vimtex_view_skim_hook_view', 'g:vimtex_view_zathura_hook_callback', 'g:vimtex_view_zathura_hook_view',], 'exists(v:val)')
                            
    1              0.000002   if !empty(l:deprecated)
                                redraw!
                                let l:message = ['Deprecated option(s) detected!'] + map(l:deprecated, { _, val -> '- ' . val}) + ['Please see `:help OPTION` for more info!']
                                call vimtex#log#warning(l:message)
    1              0.000001   endif

FUNCTION  133()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_addplot.vim:20
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000004   let l:re = '\v^\s*\\%(' . join(self.cmds, '|') . ')\s*%(\[[^\]]*\])?'
                            
    1              0.000003   let self.re.start = l:re . '\s*\w+\s*%(\[[^\]]*\])?\s*\ze\{\s*%($|\%)'
    1              0.000001   let self.re.end = '^\s*}'
    1              0.000004   let self.re.fold_re = '\\%(' . join(self.cmds, '|') . ')'
                            
    1              0.000001   return self

FUNCTION  vimtex#util#command()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/util.vim:7
Called 28 times
Total time:   0.002399
 Self time:   0.002399

count  total (s)   self (s)
   28              0.002372   return split(execute(a:cmd, 'silent!'), "\n")

FUNCTION  vimtex#delim#get_next()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:365
Called 3 times
Total time:   0.002696
 Self time:   0.000061

count  total (s)   self (s)
    3   0.002694   0.000059   return s:get_delim(extend({ 'direction' : 'next', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  51()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/_template.vim:113
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
                              " Create build dir "path" if it does not exist
                              " Note: This may need to create a hierarchical structure!
    2              0.000016   if empty(a:path) | return | endif
                            
                              if has_key(self.state, 'get_sources')
                                let l:dirs = self.state.get_sources()
                                call filter(map( l:dirs, "fnamemodify(v:val, ':h')"), {_, x -> x !=# '.'})
                                call filter(l:dirs, {_, x -> stridx(x, '../') != 0})
                              else
                                let l:dirs = glob(self.state.root . '/**/*.tex', v:false, v:true)
                                call map(l:dirs, "fnamemodify(v:val, ':h')")
                                call map(l:dirs, 'strpart(v:val, strlen(self.state.root) + 1)')
                              endif
                              call uniq(sort(filter(l:dirs, '!empty(v:val)')))
                            
                              call map(l:dirs, {_, x -> (vimtex#paths#is_abs(a:path) ? '' : self.state.root . '/') . a:path . '/' . x})
                              call filter(l:dirs, '!isdirectory(v:val)')
                              if empty(l:dirs) | return | endif
                            
                              " Create the non-existing directories
                              call vimtex#log#warning(["Creating directorie(s):"] + map(copy(l:dirs), {_, x -> '* ' . x}))
                            
                              for l:dir in l:dirs
                                call mkdir(l:dir, 'p')
                              endfor

FUNCTION  57()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/_template.vim:220
Called 1 time
Total time:   0.004409
 Self time:   0.000204

count  total (s)   self (s)
    1   0.000059   0.000013   if self.is_running() | return | endif
                            
    1   0.000067   0.000011   call self.create_dirs()
                            
                              " Initialize output file
    1              0.000097   call writefile([], self.output, 'a')
                            
                              " Prepare compile command
    1   0.001918   0.000018   let self.cmd = self.__build_cmd()
    1              0.000006   let l:cmd = has('win32') ? 'cmd /s /c "' . self.cmd . '"' : ['sh', '-c', self.cmd]
                            
                              " Execute command and toggle status
    1   0.002213   0.000010   call self.exec(l:cmd)
    1              0.000003   let self.status = 1
                            
                              " Use timer to check that compiler started properly
    1              0.000002   if self.continuous
    1              0.000019     let self.check_timer = timer_start(50, function('s:check_if_running'), {'repeat': 20})
    1              0.000002     let self.vimtex_id = b:vimtex_id
    1              0.000004     let s:check_timers[self.check_timer] = self
    1              0.000001   endif
                            
    1              0.000005   if exists('#User#VimtexEventCompileStarted')
                                doautocmd <nomodeline> User VimtexEventCompileStarted
    1              0.000001   endif

FUNCTION  vimtex#fold#markers#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/markers.vim:7
Called 1 time
Total time:   0.000031
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000030   0.000008   return extend(deepcopy(s:folder), a:config).init()

FUNCTION  <SNR>58_get_main()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state.vim:192
Called 1 time
Total time:   0.001241
 Self time:   0.000048

count  total (s)   self (s)
                              " Use buffer variable if it exists
    1              0.000004   if exists('b:vimtex_main') && filereadable(b:vimtex_main)
                                return [fnamemodify(b:vimtex_main, ':p'), 'buffer variable', []]
    1              0.000001   endif
                            
                              " Search for TEX root specifier at the beginning of file. This is used by
                              " several other plugins and editors.
    1   0.000339   0.000006   let l:candidate = s:get_main_from_texroot()
    1              0.000002   if !empty(l:candidate)
                                return [l:candidate, 'texroot specifier', []]
    1              0.000001   endif
                            
    1              0.000002   if &filetype ==# 'tex'
                                " Check if the current file is a main file
    1   0.000875   0.000014     if s:file_is_main(expand('%:p'))
    1              0.000010       return [expand('%:p'), 'current file verified', []]
                                endif
                            
                                " Support for subfiles package
                                let l:candidate = s:get_main_from_subfile()
                                if !empty(l:candidate)
                                  return [l:candidate, 'subfiles', []]
                                endif
                              endif
                            
                              " Search for .latexmain-specifier
                              let l:candidate = s:get_main_latexmain(expand('%:p'))
                              if !empty(l:candidate)
                                return [l:candidate, 'latexmain specifier', []]
                              endif
                            
                              " Search for .latexmkrc @default_files specifier
                              let l:candidate = s:get_main_latexmk()
                              if !empty(l:candidate)
                                return [l:candidate, 'latexmkrc @default_files', []]
                              endif
                            
                              " Check if we are class or style file
                              if index(['cls', 'sty'], expand('%:e')) >= 0
                                let l:id = getbufvar('#', 'vimtex_id', -1)
                                if l:id >= 0 && has_key(s:vimtex_states, l:id)
                                  return [ s:vimtex_states[l:id].tex, 'cls/sty file (inherit from alternate)', []]
                                else
                                  return [ expand('%:p'), 'cls/sty file', ['compiler', 'view', 'toc', 'qf']]
                                endif
                              endif
                            
                              " Search for main file recursively through include specifiers
                              if &filetype ==# 'tex'
                                let l:candidate = s:get_main_choose(s:get_main_recurse())
                                if !empty(l:candidate)
                                  return [l:candidate, 'recursive search', []]
                                endif
                              else
                                let l:candidate = s:get_main_choose(s:get_main_recurse_from_bib())
                                if !empty(l:candidate)
                                  return [l:candidate, 'recursive search (bib)', []]
                                endif
                              endif
                            
                              " Fallbacks:
                              " 1.  fallback candidate from get_main_latexmain
                              " 2. a. tex: current file
                              "    b. bib: check alternate file or current
                              if exists('s:cand_fallback')
                                let l:candidate = s:cand_fallback
                                unlet s:cand_fallback
                                return [l:candidate, 'fallback', []]
                              elseif &filetype ==# 'bib'
                                let l:id = getbufvar('#', 'vimtex_id', -1)
                                if l:id >= 0 && has_key(s:vimtex_states, l:id)
                                  return [ s:vimtex_states[l:id].tex, 'bib file (inherit from alternate)', []]
                                else
                                  return [ expand('%:p'), 'bib file', ['compiler', 'view', 'toc', 'qf', 'fold']]
                                endif
                              else
                                return [expand('%:p'), 'fallback current file', []]
                              endif

FUNCTION  <SNR>56_cache_open()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim:97
Called 5 times
Total time:   0.000450
 Self time:   0.000154

count  total (s)   self (s)
    5              0.000028   let l:name = a:project_local ? s:local_name(a:name) : a:name
                            
    5              0.000028   let s:caches = get(s:, 'caches', {})
    5              0.000018   if !has_key(s:caches, l:name)
    2   0.000239   0.000012     let l:path = vimtex#cache#path(l:name . '.json')
    2   0.000084   0.000015     let s:caches[l:name] = s:cache.init(l:path, a:opts)
    5              0.000004   endif
                            
    5              0.000015   return s:caches[l:name]

FUNCTION  140()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_multi.vim:20
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000005   let l:re = '\v^\s*\\%(' . join(self.cmds, '|') . ')\*?'
                            
    1              0.000003   let self.re.start = l:re . '.*(\{|\[)\s*(\%.*)?$'
    1              0.000002   let self.re.end = '\v^\s*%(\}\s*\{)*\}\s*%(\%|$)'
    1              0.000002   let self.re.text = l:re . '\{[^}]*\}'
    1              0.000005   let self.re.fold_re = '\\%(' . join(self.cmds, '|') . ')'
                            
    1              0.000001   return self

FUNCTION  143()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/items.vim:19
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000005   let l:envs = '\{%(' . join(g:vimtex_indent_lists, '|') . ')\*?}'
                            
    1              0.000002   let self.re.env_start = '\v^\s*\\begin' . l:envs
    1              0.000002   let self.re.env_end = '\v^\s*\\end' . l:envs
                            
    1              0.000001   let self.re.fold_re = '^\s*\\item>'
    1              0.000003   let self.re.fold_re_next = '^\s*\\%(item>|end' . l:envs . ')'
                            
    1              0.000002   let self.re.start = '\v' . self.re.fold_re
    1              0.000002   let self.re.end = '\v' . self.re.fold_re_next
                            
    1              0.000001   return self

FUNCTION  146()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_single.vim:20
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000005   let l:re = '\v^\s*\\%(' . join(self.cmds, '|') . ')\*?\s*%(\[.*\])?'
                            
    1              0.000002   let self.re.start = l:re . '\s*\{\s*%($|\%)'
    1              0.000001   let self.re.end = '^\s*}'
    1              0.000002   let self.re.text = l:re
    1              0.000005   let self.re.fold_re = '\\%(' . join(self.cmds, '|') . ')'
                            
    1              0.000001   return self

FUNCTION  vimtex#delim#get_matching()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:392
Called 2 times
Total time:   0.005671
 Self time:   0.000859

count  total (s)   self (s)
    2              0.000027   if empty(a:delim) || !has_key(a:delim, 'lnum') | return {} | endif
                            
                              " Get the matching position
    2   0.000036   0.000025   let l:save_pos = vimtex#pos#get_cursor()
    2   0.000139   0.000025   call vimtex#pos#set_cursor(a:delim)
    2   0.000876   0.000030   let [l:match, l:lnum, l:cnum] = a:delim.get_matching()
    2   0.000118   0.000020   call vimtex#pos#set_cursor(l:save_pos)
                            
                              " Create the match result
    2              0.000024   let l:matching = deepcopy(a:delim)
    2              0.000006   let l:matching.lnum = l:lnum
    2              0.000005   let l:matching.cnum = l:cnum
    2              0.000005   let l:matching.match = l:match
    2              0.000006   let l:matching.corr  = a:delim.match
    2              0.000008   let l:matching.side = a:delim.is_open ? 'close' : 'open'
    2              0.000007   let l:matching.is_open = !a:delim.is_open
    2              0.000007   let l:matching.re.corr = a:delim.re.this
    2              0.000006   let l:matching.re.this = a:delim.re.corr
                            
    2              0.000006   if l:matching.type ==# 'delim'
    1              0.000002     let l:matching.corr_delim = a:delim.delim
    1              0.000002     let l:matching.corr_mod = a:delim.mod
    1              0.000002     let l:matching.delim = a:delim.corr_delim
    1              0.000002     let l:matching.mod = a:delim.corr_mod
    1              0.000009   elseif l:matching.type ==# 'env' && has_key(l:matching, 'name')
    1              0.000003     if l:matching.is_open
    1              0.002346       let l:matching.env_cmd = vimtex#cmd#get_at(l:lnum, l:cnum)
                                else
                                  unlet l:matching.env_cmd
    1              0.000001     endif
    1              0.000007     let l:matching.name = matchstr(l:match, '{\zs\k*\ze\*\?}')
    2              0.000001   endif
                            
    2              0.000002   return l:matching

FUNCTION  vimtex#view#compiler_callback()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view.vim:50
Called 3 times
Total time:   0.002705
 Self time:   0.000093

count  total (s)   self (s)
    3              0.000010   if exists('*b:vimtex.viewer.compiler_callback')
    3   0.000093   0.000023     if !b:vimtex.viewer.check() | return | endif
                            
    3   0.000262   0.000014     let l:outfile = b:vimtex.viewer.out()
    3              0.000015     if !filereadable(l:outfile) | return | endif
                            
    3   0.002315   0.000021     call b:vimtex.viewer.compiler_callback(l:outfile)
    3              0.000003   endif

FUNCTION  vimtex#doc#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/doc.vim:7
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000004   command! -buffer -nargs=? VimtexDocPackage call vimtex#doc#package(<q-args>)
                            
    1              0.000005   nnoremap <buffer> <plug>(vimtex-doc-package) :VimtexDocPackage<cr>

FUNCTION  vimtex#pos#set_cursor()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/pos.vim:7
Called 59 times
Total time:   0.004271
 Self time:   0.001045

count  total (s)   self (s)
   59   0.004212   0.000986   call cursor(s:parse_args(a:000))

FUNCTION  vimtex#syntax#stack()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/syntax.vim:7
Called 43 times
Total time:   0.003043
 Self time:   0.003043

count  total (s)   self (s)
   43              0.000752   let l:pos = a:0 > 0 ? [a:1, a:2] : [line('.'), col('.')]
   43              0.000212   if mode() ==# 'i'
   31              0.000196     let l:pos[1] -= 1
   43              0.000070   endif
   43              0.000813   call map(l:pos, 'max([v:val, 1])')
                            
   43              0.000818   return map(synstack(l:pos[0], l:pos[1]), "synIDattr(v:val, 'name')")

FUNCTION  65()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/_template.vim:398
Called 1 time
Total time:   0.002203
 Self time:   0.001974

count  total (s)   self (s)
    1              0.000015   let l:shell = { 'stdin': 'null', 'on_stdout': function('s:callback_nvim_output'), 'on_stderr': function('s:callback_nvim_output'), 'cwd': self.state.root, 'tex': self.state.tex, 'output': self.output,}
                            
    1              0.000001   if !self.continuous
                                let l:shell.on_exit = function('s:callback_nvim_exit')
    1              0.000001   endif
                            
    1   0.000255   0.000069   call vimtex#jobs#neovim#shell_default()
    1              0.001857   let self.job = jobstart(a:cmd, l:shell)
    1   0.000069   0.000026   call vimtex#jobs#neovim#shell_restore()

FUNCTION  68()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/_template.vim:433
Called 23 times
Total time:   0.000937
 Self time:   0.000937

count  total (s)   self (s)
   23              0.000107   try
   23              0.000361     let pid = jobpid(self.job)
   20              0.000155     return l:pid > 0
    3              0.000058   catch
    3              0.000015     return v:false
   23              0.000059   endtry

FUNCTION  vimtex#format#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/format.vim:7
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   if !g:vimtex_format_enabled | return | endif
                            
                              setlocal formatexpr=vimtex#format#formatexpr()

FUNCTION  158()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/complete.vim:93
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002   if self.initialized | return | endif
    1              0.000001   let self.initialized = 1
                            
    1              0.000002   let self.patterns += g:vimtex_complete_bib.custom_patterns

FUNCTION  vimtex#ui#echo()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/ui.vim:7
Called 5 times
Total time:   0.000786
 Self time:   0.000281

count  total (s)   self (s)
    5              0.000028   if empty(a:input) | return | endif
    5              0.000057   let l:opts = extend({'indent': 0}, a:0 > 0 ? a:1 : {})
                            
    5              0.000022   if type(a:input) == v:t_string
                                call s:echo_string(a:input, l:opts)
    5              0.000021   elseif type(a:input) == v:t_list
    5   0.000564   0.000058     call s:echo_formatted(a:input, l:opts)
                              elseif type(a:input) == v:t_dict
                                call s:echo_dict(a:input, l:opts)
                              else
                                call vimtex#log#warn('Argument not supported: ' . type(a:input))
    5              0.000004   endif

FUNCTION  70()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/latexmk.vim:97
Called 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000028   if !executable(self.executable)
                                call vimtex#log#warning(self.executable . ' is not executable')
                                let self.enabled = v:false
    1              0.000001   endif

FUNCTION  71()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/latexmk.vim:105
Called 1 time
Total time:   0.000333
 Self time:   0.000035

count  total (s)   self (s)
    1   0.000010   0.000006   call vimtex#util#materialize_property(self, 'aux_dir')
                            
    1   0.000166   0.000007   call s:compare_with_latexmkrc(self, 'out_dir')
    1   0.000142   0.000007   call s:compare_with_latexmkrc(self, 'aux_dir')
                              
                              " $VIMTEX_OUTPUT_DIRECTORY overrides configured compiler.aux_dir
    1              0.000004   if !empty($VIMTEX_OUTPUT_DIRECTORY)
                                if !empty(self.aux_dir) && (self.aux_dir !=# $VIMTEX_OUTPUT_DIRECTORY)
                                  call vimtex#log#warning( 'Setting VIMTEX_OUTPUT_DIRECTORY overrides aux_dir!', 'Changed aux_dir from: ' . self.aux_dir, 'Changed aux_dir to: ' . $VIMTEX_OUTPUT_DIRECTORY)
                                endif
                            
                                let self.aux_dir = $VIMTEX_OUTPUT_DIRECTORY
    1              0.000000   endif

FUNCTION  72()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/latexmk.vim:126
Called 1 time
Total time:   0.001900
 Self time:   0.000131

count  total (s)   self (s)
    1              0.000023   let l:cmd = (has('win32') ? 'set max_print_line=2000 & ' : 'max_print_line=2000 ') . self.executable
                            
    1              0.000016   let l:cmd .= ' ' . join(self.options)
    1   0.001714   0.000014   let l:cmd .= ' ' . self.get_engine()
                            
    1              0.000002   if !empty(self.out_dir)
                                let l:cmd .= ' -outdir=' . fnameescape(self.out_dir)
    1              0.000001   endif
                            
    1              0.000002   if !empty(self.aux_dir)
                                let l:cmd .= ' -emulate-aux-dir'
                                let l:cmd .= ' -auxdir=' . fnameescape(self.aux_dir)
    1              0.000000   endif
                            
    1              0.000001   if self.continuous
    1              0.000002     let l:cmd .= ' -pvc -view=none'
                            
    1              0.000001     if self.callback
    4              0.000015       for [l:opt, l:val] in [ ['compiling_cmd', 'vimtex_compiler_callback_compiling'], ['success_cmd', 'vimtex_compiler_callback_success'], ['failure_cmd', 'vimtex_compiler_callback_failure'],]
    3   0.000078   0.000026         let l:cmd .= s:wrap_option_appendcmd(l:opt, 'echo ' . l:val)
    4              0.000004       endfor
    1              0.000001     endif
    1              0.000000   endif
                            
    1   0.000026   0.000009   return l:cmd . ' ' . vimtex#util#shellescape(self.state.base)

FUNCTION  74()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/latexmk.vim:177
Called 13 times
Total time:   0.000754
 Self time:   0.000689

count  total (s)   self (s)
   55              0.000136   for l:root in [ $VIMTEX_OUTPUT_DIRECTORY, self.aux_dir, self.out_dir, self.state.root]
   91              0.000150     if empty(l:root) | continue | endif
                            
   13              0.000066     let l:cand = printf('%s/%s.%s', l:root, self.state.name, a:ext)
   13   0.000136   0.000071     if !vimtex#paths#is_abs(l:root)
                                  let l:cand = self.state.root . '/' . l:cand
   13              0.000007     endif
                            
   13              0.000089     if filereadable(l:cand)
   10              0.000042       return fnamemodify(l:cand, ':p')
    3              0.000001     endif
    6              0.000005   endfor
                            
    3              0.000003   return ''

FUNCTION  75()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/latexmk.vim:200
Called 1 time
Total time:   0.000056
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000028   0.000014   call self._create_build_dir(self.out_dir)
    1   0.000026   0.000017   call self._create_build_dir(self.aux_dir)

FUNCTION  78()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/latexmk.vim:231
Called 1 time
Total time:   0.001701
 Self time:   0.000080

count  total (s)   self (s)
                              " Parse tex_program from TeX directive
    1   0.001316   0.000017   let l:tex_program_directive = self.state.get_tex_program()
    1              0.000006   let l:tex_program = l:tex_program_directive
                            
                              " Parse tex_program from from pdf_mode option in .latexmkrc
    1   0.000351   0.000029   let [l:pdf_mode, l:is_local] = vimtex#compiler#latexmk#get_rc_opt(self.state.root, 'pdf_mode', 1, -1)
                            
    1              0.000002   if l:pdf_mode >= 1 && l:pdf_mode <= 5
                                let l:tex_program_pdfmode = [ 'pdflatex', 'pdfps', 'pdfdvi', 'lualatex', 'xelatex',][l:pdf_mode-1]
                            
                                " Use pdf_mode if there is no TeX directive
                                if l:tex_program_directive ==# '_'
                                  let l:tex_program = l:tex_program_pdfmode
                                elseif l:is_local && l:tex_program_directive !=# l:tex_program_pdfmode
                                  " Give warning when there may be a confusing conflict
                                  call vimtex#log#warning( 'Value of pdf_mode from latexmkrc is inconsistent with ' . 'TeX program directive!', 'TeX program: ' . l:tex_program_directive, 'pdf_mode:    ' . l:tex_program_pdfmode, 'The value of pdf_mode will be ignored.')
                                endif
    1              0.000000   endif
                            
    1              0.000005   return get(g:vimtex_compiler_latexmk_engines, l:tex_program, g:vimtex_compiler_latexmk_engines._)

FUNCTION  79()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/latexlog.vim:18
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000012   let self.types = map( filter(items(s:), 'v:val[0] =~# ''^type_'''), 'v:val[1]')

FUNCTION  <SNR>62_parse_graphicspath()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state/class.vim:207
Called 1 time
Total time:   0.000096
 Self time:   0.000064

count  total (s)   self (s)
                              " Combine the preamble as one long string of commands
    1   0.000061   0.000028   let l:preamble = join(map(copy(a:preamble), {_, x -> substitute(x, '\\\@<!%.*', '', '')}))
                            
                              " Extract the graphicspath command from this string
    1              0.000018   let l:graphicspath = matchstr(l:preamble, g:vimtex#re#not_bslash . '\\graphicspath\s*\{\s*\{\s*\zs.{-}\ze\s*\}\s*\}')
                            
                              " Add all parsed graphicspaths
    1              0.000001   let l:paths = []
    1              0.000004   for l:path in split(l:graphicspath, '\s*}\s*{\s*')
                                let l:path = substitute(l:path, '\/\s*$', '', '')
                                call add(l:paths, vimtex#paths#is_abs(l:path) ? l:path : simplify(a:root . '/' . l:path))
    1              0.000001   endfor
                            
    1              0.000001   return l:paths

FUNCTION  161()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/complete.vim:246
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000003   if self.initialized | return | endif
    1              0.000002   let self.initialized = 1
                            
                              " Add custom patterns
    1              0.000003   let self.patterns += g:vimtex_complete_ref.custom_patterns

FUNCTION  vimtex#util#is_win()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/util.vim:101
Called 5 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    5              0.000026   return has('win32') || has('win32unix')

FUNCTION  vimtex#qf#bibtex#addqflist()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/bibtex.vim:7
Called 3 times
Total time:   0.000129
 Self time:   0.000079

count  total (s)   self (s)
    3              0.000020   if get(g:vimtex_quickfix_blgparser, 'disable') | return | endif
                            
    3              0.000003   try
    3   0.000068   0.000018     call s:qf.addqflist(a:blg)
    3              0.000027   catch /BibTeX Aborted/
    3              0.000005   endtry

FUNCTION  80()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/latexlog.vim:25
Called 3 times
Total time:   0.001024
 Self time:   0.000883

count  total (s)   self (s)
                              "
                              " Note: The errorformat assumes we're using the -file-line-error with
                              "       [pdf]latex. For more info, see |errorformat-LaTeX|.
                              "
                            
                              " Push file to file stack
    3   0.000050   0.000035   setlocal errorformat=%-P**%f
    3   0.000014   0.000010   setlocal errorformat+=%-P**\"%f\"
                            
                              " Match errors
    3   0.000013   0.000009   setlocal errorformat+=%E!\ LaTeX\ %trror:\ %m
    3   0.000012   0.000008   setlocal errorformat+=%E%f:%l:\ %m
    3   0.000012   0.000009   setlocal errorformat+=%+ERunaway\ argument?
    3   0.000011   0.000008   setlocal errorformat+=%+C{%m
    3   0.000011   0.000008   setlocal errorformat+=%C!\ %m
                            
                              " More info for undefined control sequences
    3   0.000012   0.000009   setlocal errorformat+=%Z<argument>\ %m
                            
                              " More info for some errors
    3   0.000013   0.000010   setlocal errorformat+=%Cl.%l\ %m
                            
                              "
                              " Define general warnings
                              "
    3   0.000015   0.000012   setlocal errorformat+=%+WLaTeX\ Font\ Warning:\ %.%#line\ %l%.%#
    3   0.000017   0.000014   setlocal errorformat+=%-CLaTeX\ Font\ Warning:\ %m
    3   0.000015   0.000012   setlocal errorformat+=%-C(Font)%m
                            
    3   0.000017   0.000014   setlocal errorformat+=%+WLaTeX\ %.%#Warning:\ %.%#line\ %l%.%#
    3   0.000015   0.000012   setlocal errorformat+=%+WLaTeX\ %.%#Warning:\ %m
                            
    3   0.000017   0.000014   setlocal errorformat+=%+WOverfull\ %\\%\\hbox%.%#\ at\ lines\ %l--%*\\d
    3   0.000020   0.000017   setlocal errorformat+=%+WOverfull\ %\\%\\hbox%.%#\ at\ line\ %l
    3   0.000018   0.000015   setlocal errorformat+=%+WOverfull\ %\\%\\vbox%.%#\ at\ line\ %l
                            
    3   0.000020   0.000017   setlocal errorformat+=%+WUnderfull\ %\\%\\hbox%.%#\ at\ lines\ %l--%*\\d
    3   0.000021   0.000018   setlocal errorformat+=%+WUnderfull\ %\\%\\vbox%.%#\ at\ line\ %l
                            
                              "
                              " Define package related warnings
                              "
    3   0.000024   0.000021   setlocal errorformat+=%+WPackage\ natbib\ Warning:\ %m\ on\ input\ line\ %l.
                            
    3   0.000023   0.000020   setlocal errorformat+=%+WPackage\ biblatex\ Warning:\ %m
    3   0.000024   0.000021   setlocal errorformat+=%-C(biblatex)%.%#in\ t%.%#
    3   0.000025   0.000022   setlocal errorformat+=%-C(biblatex)%.%#Please\ v%.%#
    3   0.000028   0.000025   setlocal errorformat+=%-C(biblatex)%.%#LaTeX\ a%.%#
    3   0.000026   0.000023   setlocal errorformat+=%-C(biblatex)%m
                            
    3   0.000027   0.000024   setlocal errorformat+=%+WPackage\ babel\ Warning:\ %m
    3   0.000029   0.000026   setlocal errorformat+=%-Z(babel)%.%#input\ line\ %l.
    3   0.000024   0.000021   setlocal errorformat+=%-C(babel)%m
                            
    3   0.000035   0.000031   setlocal errorformat+=%+WPackage\ hyperref\ Warning:\ %m
    3   0.000029   0.000026   setlocal errorformat+=%-C(hyperref)%m\ on\ input\ line\ %l.
    3   0.000029   0.000026   setlocal errorformat+=%-C(hyperref)%m
                            
    3   0.000029   0.000026   setlocal errorformat+=%+WPackage\ scrreprt\ Warning:\ %m
    3   0.000025   0.000023   setlocal errorformat+=%-C(scrreprt)%m
                            
    3   0.000031   0.000028   setlocal errorformat+=%+WPackage\ fixltx2e\ Warning:\ %m
    3   0.000029   0.000026   setlocal errorformat+=%-C(fixltx2e)%m
                            
    3   0.000029   0.000026   setlocal errorformat+=%+WPackage\ titlesec\ Warning:\ %m
    3   0.000028   0.000025   setlocal errorformat+=%-C(titlesec)%m
                            
    3   0.000032   0.000029   setlocal errorformat+=%+WPackage\ %.%#\ Warning:\ %m\ on\ input\ line\ %l.
    3   0.000034   0.000031   setlocal errorformat+=%+WPackage\ %.%#\ Warning:\ %m
    3   0.000033   0.000030   setlocal errorformat+=%-Z(%.%#)\ %m\ on\ input\ line\ %l.
    3   0.000035   0.000032   setlocal errorformat+=%-C(%.%#)\ %m
                            
                              " Ignore unmatched lines
    3   0.000034   0.000031   setlocal errorformat+=%-G%.%#

FUNCTION  81()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/latexlog.vim:103
Called 3 times
Total time:   0.051230
 Self time:   0.000243

count  total (s)   self (s)
    3              0.000024   if empty(a:log) || !filereadable(a:log)
                                throw 'VimTeX: No log file found'
    3              0.000002   endif
                            
    3   0.009349   0.000103   call vimtex#qf#u#caddfile(self, fnameescape(a:log))
                            
                              " Apply some post processing of the quickfix list
    3              0.000009   let self.main = a:tex
    3              0.000015   let self.root = fnamemodify(a:tex, ':h')
    3   0.041821   0.000081   call self.fix_paths(a:log)

FUNCTION  82()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/latexlog.vim:117
Called 3 times
Total time:   0.041740
 Self time:   0.000830

count  total (s)   self (s)
    3              0.000039   let l:qflist = getqflist()
    3              0.000161   let l:lines = readfile(a:log)
    3              0.000012   let l:nlines = len(l:lines)
    3              0.000014   let l:hbox_cache = {'index': {}, 'paths': {}}
                            
   12              0.000023   for l:qf in l:qflist
                                " Handle missing buffer/filename: Fallback to the main file (this is always
                                " correct in single-file projects and is thus a good fallback).
    9              0.000020     if l:qf.bufnr == 0
    9              0.000099       let l:bufnr_main = bufnr(self.main)
    9              0.000066       if bufnr(self.main) < 0
                                    execute 'badd' self.main
                                    let l:bufnr_main = bufnr(self.main)
    9              0.000007       endif
    9              0.000019       let l:qf.bufnr = l:bufnr_main
    9              0.000007     endif
                            
                                " Try to parse the filename from logfile for certain errors, except for
                                " large log files where this makes for bad UI because it locks Vim while
                                " waiting for this parsing to finish.
    9   0.033888   0.000127     if l:nlines < 10000 && s:fix_paths_hbox_warning(l:qf, l:lines, self.root, l:hbox_cache)
    9              0.000013       continue
                                endif
                            
                                " Check and possibly fix invalid file from file:line type entries
                                call s:fix_paths_invalid_bufname(l:qf, self.root)
    3              0.000004   endfor
                            
    3   0.007227   0.000078   call setqflist(l:qflist, 'r')

FUNCTION  vimtex#jobs#neovim#shell_restore()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/jobs/neovim.vim:35
Called 2 times
Total time:   0.000070
 Self time:   0.000048

count  total (s)   self (s)
    2   0.000065   0.000043   let [&shell, &shellcmdflag, &shellslash] = s:saveshell

FUNCTION  vimtex#text_obj#targets#enabled()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/text_obj/targets.vim:7
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015   return exists('g:loaded_targets') && (   (type(g:loaded_targets) == v:t_number && g:loaded_targets)     || (type(g:loaded_targets) == v:t_string && !empty(g:loaded_targets))) && (   g:vimtex_text_obj_variant ==# 'auto'     || g:vimtex_text_obj_variant ==# 'targets')

FUNCTION  vimtex#text_obj#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/text_obj.vim:7
Called 1 time
Total time:   0.000310
 Self time:   0.000310

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_text_obj_enabled | return | endif
                            
                              " Note: I've permitted myself long lines here to make this more readable.
    7              0.000032   for [l:map, l:name, l:opt] in [ ['c', 'commands', ''], ['d', 'delimited', 'delims'], ['e', 'delimited', 'normal'], ['$', 'delimited', 'math'], ['P', 'sections', ''], ['m', 'items', ''],]
    6              0.000020     let l:optional = empty(l:opt) ? '' : ',''' . l:opt . ''''
    6              0.000059     execute printf('xnoremap <silent><buffer> <plug>(vimtex-i%s) :<c-u>call vimtex#text_obj#%s(1, 1%s)<cr>', l:map, l:name, l:optional)
    6              0.000064     execute printf('xnoremap <silent><buffer> <plug>(vimtex-a%s) :<c-u>call vimtex#text_obj#%s(0, 1%s)<cr>', l:map, l:name, l:optional)
    6              0.000055     execute printf('onoremap <silent><buffer> <plug>(vimtex-i%s) :<c-u>call vimtex#text_obj#%s(1, 0%s)<cr>', l:map, l:name, l:optional)
    6              0.000054     execute printf('onoremap <silent><buffer> <plug>(vimtex-a%s) :<c-u>call vimtex#text_obj#%s(0, 0%s)<cr>', l:map, l:name, l:optional)
    7              0.000004   endfor

FUNCTION  vimtex#view#init_state()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view.vim:21
Called 1 time
Total time:   0.000359
 Self time:   0.000084

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_view_enabled | return | endif
    1              0.000004   if has_key(a:state, 'viewer') | return | endif
                            
    1              0.000002   augroup vimtex_viewer
    1              0.000012     autocmd!
    1              0.000007     autocmd User VimtexEventCompileSuccess call vimtex#view#compiler_callback()
    1              0.000005     autocmd User VimtexEventCompileStopped call vimtex#view#compiler_stopped()
    1              0.000001   augroup END
                            
    1              0.000001   try
    1   0.000317   0.000042     let a:state.viewer = vimtex#view#{g:vimtex_view_method}#new()
                              catch /E117/
                                call vimtex#log#warning( 'Invalid viewer: ' . g:vimtex_view_method, 'Please see :h g:vimtex_view_method')
                                return
    1              0.000001   endtry

FUNCTION  <SNR>68_callback_nvim_output()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/_template.vim:452
Called 208 times
Total time:   0.122532
 Self time:   0.018051

count  total (s)   self (s)
                              " Filter out unwanted newlines
  208              0.003458   let l:data = split(substitute(join(a:data, 'QQ'), '^QQ\|QQ$', '', ''), 'QQ')
                            
  208              0.002151   if !empty(l:data) && filewritable(self.output)
  208              0.002838     call writefile(l:data, self.output, 'a')
  208              0.000189   endif
                            
  208   0.109935   0.005454   call s:check_callback( get(filter(copy(a:data),   {_, x -> x =~# '^vimtex_compiler_callback'}), -1, ''))
                            
  208              0.001128   if !exists('b:vimtex.compiler.hooks') | return | endif
  208              0.000176   try
  208              0.000600     for l:Hook in b:vimtex.compiler.hooks
                                  call l:Hook(join(a:data, "\n"))
  208              0.000193     endfor
                              catch /E716/
  208              0.000176   endtry

FUNCTION  vimtex#view#general#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view/general.vim:7
Called 1 time
Total time:   0.000015
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000015   0.000004   return s:viewer.init()

FUNCTION  <SNR>26_Highlight_Matching_Pair()
    Defined: /usr/local/share/nvim/runtime/plugin/matchparen.vim:39
Called 105 times
Total time:   0.024434
 Self time:   0.021836

count  total (s)   self (s)
                              " Remove any previous match.
  105   0.006762   0.004165   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  105              0.001147   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  105              0.000132   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  105              0.000731   let c_lnum = line('.')
  105              0.000591   let c_col = col('.')
  105              0.000310   let before = 0
                            
  105              0.000700   let text = getline(c_lnum)
  105              0.003360   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  105              0.000530   if empty(matches)
                                let [c_before, c] = ['', '']
  105              0.000171   else
  105              0.001044     let [c_before, c] = matches[1:2]
  105              0.000148   endif
  105              0.002354   let plist = split(&matchpairs, '.\zs[:,]')
  105              0.000748   let i = index(plist, c)
  105              0.000289   if i < 0
                                " not found, in Insert mode try character before the cursor
  105              0.001002     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   80              0.000542       let before = strlen(c_before)
   80              0.000292       let c = c_before
   80              0.000467       let i = index(plist, c)
  105              0.000142     endif
  105              0.000257     if i < 0
                                  " not found, nothing to do
  105              0.000218       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  175()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/complete.vim:547
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   if !has_key(b:vimtex.packages, 'glossaries-extra') | return | endif
                            
                              " Detect stuff like this:
                              "  \GlsXtrLoadResources[src=glossary.bib]
                              "  \GlsXtrLoadResources[src={glossary.bib}, selection={all}]
                              "  \GlsXtrLoadResources[selection={all},src={glossary.bib}]
                              "  \GlsXtrLoadResources[
                              "    src={glossary.bib},
                              "    selection={all},
                              "  ]
                            
                              let l:do_search = 0
                              for l:line in vimtex#parser#preamble(b:vimtex.tex)
                                if line =~# '^\s*\\GlsXtrLoadResources\s*\['
                                  let l:do_search = 1
                                  let l:line = matchstr(l:line, '^\s*\\GlsXtrLoadResources\s*\[\zs.*')
                                endif
                                if !l:do_search | continue | endif
                            
                                let l:matches = split(l:line, '[=,]')
                                if empty(l:matches) | continue | endif
                            
                                while !empty(l:matches)
                                  let l:key = vimtex#util#trim(remove(l:matches, 0))
                                  if l:key ==# 'src'
                                    let l:value = vimtex#util#trim(remove(l:matches, 0))
                                    let l:value = substitute(l:value, '^{', '', '')
                                    let l:value = substitute(l:value, '[]}]\s*', '', 'g')
                                    let b:vimtex.complete.glsbib = l:value
                                    break
                                  endif
                                endwhile
                              endfor

FUNCTION  vimtex#fold#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold.vim:7
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   if !g:vimtex_fold_enabled || s:foldmethod_in_modeline() | return | endif
                            
                              " Set fold options
                              setlocal foldmethod=expr
                              setlocal foldexpr=vimtex#fold#level(v:lnum)
                              setlocal foldtext=vimtex#fold#text()
                            
                              if g:vimtex_fold_manual
                                " Remap zx to refresh fold levels
                                nnoremap <silent><buffer><nowait> zx :call vimtex#fold#refresh('zx')<cr>
                                nnoremap <silent><buffer><nowait> zX :call vimtex#fold#refresh('zX')<cr>
                            
                                " Define commands
                                command! -buffer VimtexRefreshFolds call vimtex#fold#refresh('zx')
                            
                                " Ensure that folds are refreshed on startup
                                augroup vimtex_temporary
                                  autocmd! * <buffer>
                                  autocmd CursorMoved <buffer>   call vimtex#fold#refresh('zx') | autocmd! vimtex_temporary CursorMoved <buffer>
                                augroup END
                              endif

FUNCTION  vimtex#motion#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/motion.vim:7
Called 1 time
Total time:   0.000386
 Self time:   0.000386

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_motion_enabled | return | endif
                            
                              " Utility map to avoid conflict with "normal" command
    1              0.000003   nnoremap <buffer> <sid>(v) v
    1              0.000002   nnoremap <buffer> <sid>(V) V
                            
                              " Matching pairs
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-%) :call vimtex#motion#find_matching_pair()<cr>
    1              0.000005   xnoremap <silent><buffer>  <sid>(vimtex-%) :<c-u>call vimtex#motion#find_matching_pair(1)<cr>
    1              0.000004   xmap     <silent><buffer> <plug>(vimtex-%) <sid>(vimtex-%)
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-%) :execute "normal \<sid>(v)\<sid>(vimtex-%)"<cr>
                            
                              " Sections
    1              0.000005   nnoremap <silent><buffer> <plug>(vimtex-]]) :<c-u>call vimtex#motion#section(0,0,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-][) :<c-u>call vimtex#motion#section(1,0,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-[]) :<c-u>call vimtex#motion#section(1,1,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-[[) :<c-u>call vimtex#motion#section(0,1,0)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-]]) :<c-u>call vimtex#motion#section(0,0,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-][) :<c-u>call vimtex#motion#section(1,0,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-[]) :<c-u>call vimtex#motion#section(1,1,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-[[) :<c-u>call vimtex#motion#section(0,1,1)<cr>
    1              0.000004   xmap     <silent><buffer> <plug>(vimtex-]]) <sid>(vimtex-]])
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-][) <sid>(vimtex-][)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-[]) <sid>(vimtex-[])
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-[[) <sid>(vimtex-[[)
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-]]) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]])"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-][) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-][)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-[]) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[])"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-[[) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[[)"<cr>
                            
                              " Math environments ($-$, $$-$$, \(-\), \[-\], \begin-\end)
    1              0.000005   nnoremap <silent><buffer> <plug>(vimtex-]n) :<c-u>call vimtex#motion#math(1,0,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-]N) :<c-u>call vimtex#motion#math(0,0,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-[n) :<c-u>call vimtex#motion#math(1,1,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-[N) :<c-u>call vimtex#motion#math(0,1,0)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-]n) :<c-u>call vimtex#motion#math(1,0,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-]N) :<c-u>call vimtex#motion#math(0,0,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-[n) :<c-u>call vimtex#motion#math(1,1,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-[N) :<c-u>call vimtex#motion#math(0,1,1)<cr>
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-]n) <sid>(vimtex-]n)
    1              0.000004   xmap     <silent><buffer> <plug>(vimtex-]N) <sid>(vimtex-]N)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-[n) <sid>(vimtex-]n)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-[N) <sid>(vimtex-]N)
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-]n) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]n)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-]N) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]N)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-[n) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[n)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-[N) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[N)"<cr>
                            
                              " Environments
    1              0.000005   nnoremap <silent><buffer> <plug>(vimtex-]m) :<c-u>call vimtex#motion#environment(1,0,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-]M) :<c-u>call vimtex#motion#environment(0,0,0)<cr>
    1              0.000005   nnoremap <silent><buffer> <plug>(vimtex-[m) :<c-u>call vimtex#motion#environment(1,1,0)<cr>
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-[M) :<c-u>call vimtex#motion#environment(0,1,0)<cr>
    1              0.000005   xnoremap <silent><buffer>  <sid>(vimtex-]m) :<c-u>call vimtex#motion#environment(1,0,1)<cr>
    1              0.000017   xnoremap <silent><buffer>  <sid>(vimtex-]M) :<c-u>call vimtex#motion#environment(0,0,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-[m) :<c-u>call vimtex#motion#environment(1,1,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-[M) :<c-u>call vimtex#motion#environment(0,1,1)<cr>
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-]m) <sid>(vimtex-]m)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-]M) <sid>(vimtex-]M)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-[m) <sid>(vimtex-[m)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-[M) <sid>(vimtex-[M)
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-]m) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]m)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-]M) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]M)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-[m) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[m)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-[M) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[M)"<cr>
                            
                              " Frames
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-]r) :<c-u>call vimtex#motion#frame(1,0,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-]R) :<c-u>call vimtex#motion#frame(0,0,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-[r) :<c-u>call vimtex#motion#frame(1,1,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-[R) :<c-u>call vimtex#motion#frame(0,1,0)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-]r) :<c-u>call vimtex#motion#frame(1,0,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-]R) :<c-u>call vimtex#motion#frame(0,0,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-[r) :<c-u>call vimtex#motion#frame(1,1,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-[R) :<c-u>call vimtex#motion#frame(0,1,1)<cr>
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-]r) <sid>(vimtex-]r)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-]R) <sid>(vimtex-]R)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-[r) <sid>(vimtex-[r)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-[R) <sid>(vimtex-[R)
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-]r) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]r)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-]R) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]R)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-[r) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[r)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-[R) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[R)"<cr>
                            
                              " Comments
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-]/) :<c-u>call vimtex#motion#comment(1,0,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-]*) :<c-u>call vimtex#motion#comment(0,0,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-[/) :<c-u>call vimtex#motion#comment(1,1,0)<cr>
    1              0.000004   nnoremap <silent><buffer> <plug>(vimtex-[*) :<c-u>call vimtex#motion#comment(0,1,0)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-]/) :<c-u>call vimtex#motion#comment(1,0,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-]*) :<c-u>call vimtex#motion#comment(0,0,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-[/) :<c-u>call vimtex#motion#comment(1,1,1)<cr>
    1              0.000004   xnoremap <silent><buffer>  <sid>(vimtex-[*) :<c-u>call vimtex#motion#comment(0,1,1)<cr>
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-]/) <sid>(vimtex-]/)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-]*) <sid>(vimtex-]*)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-[/) <sid>(vimtex-[/)
    1              0.000003   xmap     <silent><buffer> <plug>(vimtex-[*) <sid>(vimtex-[*)
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-]/) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]/)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-]*) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-]*)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-[/) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[/)"<cr>
    1              0.000005   onoremap <silent><buffer> <plug>(vimtex-[*) :execute "normal \<sid>(V)" . v:count1 . "\<sid>(vimtex-[*)"<cr>

FUNCTION  185()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:622
Called 46 times
Total time:   0.000523
 Self time:   0.000523

count  total (s)   self (s)
   46              0.000483   return a:match =~# '^\\\%(begin\|end\)\>'

FUNCTION  vimtex#toc#init_state()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/toc.vim:18
Called 1 time
Total time:   0.000075
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_toc_enabled | return | endif
                            
    1   0.000071   0.000005   let a:state.toc = vimtex#toc#new()

FUNCTION  187()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:657
Called 1 time
Total time:   0.000677
 Self time:   0.000659

count  total (s)   self (s)
    1              0.000002   try
    1   0.000620   0.000602     let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close, self.gms_flags, '', 0, s:get_timeout())
                              catch /E118/
                                let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close, self.gms_flags, '', self.gms_stopline)
    1              0.000003   endtry
                            
    1              0.000024   let match = matchstr(getline(lnum), '^' . self.re.corr, cnum-1)
    1              0.000006   return [match, lnum, cnum]

FUNCTION  188()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:675
Called 45 times
Total time:   0.000510
 Self time:   0.000510

count  total (s)   self (s)
   45              0.000469   return a:x =~# '^\$\$\?' && !vimtex#syntax#in('texComment')

FUNCTION  <SNR>95_create_map()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/imaps.vim:85
Called 74 times
Total time:   0.004234
 Self time:   0.004234

count  total (s)   self (s)
   74              0.000410   if index(b:vimtex_imaps, a:map) >= 0 | return | endif
   74              0.000178   let l:map = deepcopy(a:map)
                            
   74              0.000216   let l:leader = get(l:map, 'leader', g:vimtex_imaps_leader)
   74              0.000352   if l:leader !=# '' && !hasmapto(l:leader, 'i')
    1              0.000007     silent execute 'inoremap <silent><buffer><nowait>' l:leader . l:leader l:leader
   74              0.000033   endif
   74              0.000148   let l:lhs = l:leader . l:map.lhs
                            
   74              0.000216   let l:wrapper = get(l:map, 'wrapper', 'vimtex#imaps#wrap_math')
   74              0.000175   if ! exists('*' . l:wrapper)
                                echoerr 'VimTeX error: imaps wrapper does not exist!'
                                echoerr '              ' . l:wrapper
                                return
   74              0.000031   endif
                            
                              " Some wrappers use a context which must be made available to the wrapper
                              " function at run time.
   74              0.000132   if has_key(l:map, 'context')
                                execute 'let l:key = "' . escape(l:lhs, '<') . '"'
                                let l:key .= l:map.rhs
                                if !exists('b:vimtex_context')
                                  let b:vimtex_context = {}
                                endif
                                let b:vimtex_context[l:key] = l:map.context
   74              0.000032   endif
                            
                              " The rhs may be evaluated before being passed to wrapper, unless expr is
                              " disabled (which it is by default)
   74              0.000126   if !get(l:map, 'expr')
   68              0.000162     let l:map.rhs = string(l:map.rhs)
   74              0.000035   endif
                            
   74              0.000699   silent execute 'inoremap <silent><buffer><nowait><expr>' l:lhs l:wrapper . '("' . escape(l:lhs, '\') . '", ' . l:map.rhs . ')'
                            
   74              0.000146   let b:vimtex_imaps += [l:map]

FUNCTION  191()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:749
Called 45 times
Total time:   0.000382
 Self time:   0.000382

count  total (s)   self (s)
   45              0.000350   return a:match =~# '^\\\%((\|)\|\[\|\]\)'

FUNCTION  194()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:796
Called 45 times
Total time:   0.000402
 Self time:   0.000402

count  total (s)   self (s)
   45              0.000373   return a:match =~# '^\\\%(left\|right\)\s*\.'

FUNCTION  197()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:885
Called 45 times
Total time:   0.002814
 Self time:   0.002814

count  total (s)   self (s)
   45              0.002782   return a:match =~# '^' . g:vimtex#delim#re.delim_all.both

FUNCTION  198()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:890
Called 3 times
Total time:   0.001551
 Self time:   0.000599

count  total (s)   self (s)
    3              0.000036   let result = extend(deepcopy(self), a:ctx, 'keep')
    3              0.000007   unlet result.detect
    3              0.000004   unlet result.parse
                            
    3              0.000084   let result.side = a:ctx.match =~# g:vimtex#delim#re.delim_all.open ? 'open' : 'close'
    3              0.000011   let result.is_open = result.side ==# 'open'
    3              0.000010   let result.gms_flags = result.is_open ? 'nW' : 'bnW'
    3              0.000031   let result.gms_stopline = result.is_open ? line('.') + g:vimtex_delim_stopline : max([1, line('.') - g:vimtex_delim_stopline])
                            
                              " Find corresponding delimiter and the regexps
    3              0.000060   if a:ctx.match =~# '^' . g:vimtex#delim#re.mods.both
                                let m1 = matchstr(a:ctx.match, '^' . g:vimtex#delim#re.mods.both)
                                let d1 = substitute(strpart(a:ctx.match, len(m1)), '^\s*', '', '')
                                let s1 = !result.is_open
                                let re1 = s:get_re_for_delim(m1, s1, 'mods')  . '\s*' . s:get_re_for_delim(d1, s1, 'delim_math')
                            
                                let m2 = s:get_corr_delimiter(m1, 'mods')
                                let d2 = s:get_corr_delimiter(d1, 'delim_math')
                                let s2 = result.is_open
                                let re2 = s:get_re_for_delim(m2, s2, 'mods') . '\s*' . (m1 =~# '\\\%(left\|right\)'   ? '\%(' . s:get_re_for_delim(d2, s2, 'delim_math') . '\|\.\)'   : s:get_re_for_delim(d2, s2, 'delim_math'))
    3              0.000003   else
    3              0.000008     let d1 = a:ctx.match
    3              0.000006     let m1 = ''
    3   0.000315   0.000033     let re1 = s:get_re_for_delim(a:ctx.match, !result.is_open)
                            
    3   0.000442   0.000031     let d2 = s:get_corr_delimiter(a:ctx.match)
    3              0.000005     let m2 = ''
    3   0.000288   0.000029     let re2 = s:get_re_for_delim(d2, result.is_open)
    3              0.000003   endif
                            
    3              0.000009   let result.delim = d1
    3              0.000007   let result.mod = m1
    3              0.000011   let result.corr = m2 . d2
    3              0.000011   let result.corr_delim = d2
    3              0.000007   let result.corr_mod = m2
    3              0.000037   let result.re = { 'this'  : re1, 'corr'  : re2, 'open'  : result.is_open ? re1 : re2, 'close' : result.is_open ? re2 : re1,}
                            
    3              0.000005   return result

FUNCTION  199()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:944
Called 1 time
Total time:   0.000169
 Self time:   0.000152

count  total (s)   self (s)
    1              0.000002   try
    1   0.000099   0.000081     let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close, self.gms_flags, 'synIDattr(synID(line("."), col("."), 0), "name") =~? "comment"', 0, s:get_timeout())
                              catch /E118/
                                let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close, self.gms_flags, 'synIDattr(synID(line("."), col("."), 0), "name") =~? "comment"', self.gms_stopline)
    1              0.000002   endtry
                            
    1              0.000037   let match = matchstr(getline(lnum), '^' . self.re.corr, cnum-1)
    1              0.000002   return [match, lnum, cnum]

FUNCTION  vimtex#qf#open()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf.vim:42
Called 3 times
Total time:   0.084707
 Self time:   0.009904

count  total (s)   self (s)
    3              0.000025   if !exists('b:vimtex.qf.addqflist') | return | endif
                            
    3              0.000003   try
    3   0.060883   0.000029     call vimtex#qf#setqflist()
                              catch /VimTeX: No log file found/
                                if a:force
                                  call vimtex#log#warning('No log file found')
                                endif
                                if g:vimtex_quickfix_mode > 0
                                  cclose
                                endif
                                return
                              catch
                                call vimtex#log#error( 'Something went wrong when parsing log files!', v:exception)
                                if g:vimtex_quickfix_mode > 0
                                  cclose
                                endif
                                return
    3              0.000002   endtry
                            
    3              0.000034   if empty(getqflist())
                                if a:force
                                  call vimtex#log#info('No errors!')
                                endif
                                if g:vimtex_quickfix_mode > 0
                                  cclose
                                endif
                                return
    3              0.000002   endif
                            
                              "
                              " There are two options that determine when to open the quickfix window.  If
                              " forced, the quickfix window is always opened when there are errors or
                              " warnings (forced typically imply that the functions is called from the
                              " normal mode mapping).  Else the behaviour is based on the settings.
                              "
    3   0.000092   0.000035   let l:errors_or_warnings = s:qf_has_errors() || g:vimtex_quickfix_open_on_warning
                            
    3              0.000011   if a:force || (g:vimtex_quickfix_mode > 0 && l:errors_or_warnings)
    3              0.000010     let s:previous_window = win_getid()
    3   0.010282   0.000262     botright cwindow
    3              0.000005     if g:vimtex_quickfix_mode == 2
    3              0.005306       redraw
    3   0.003912   0.000040       call win_gotoid(s:previous_window)
    3              0.000002     endif
    3              0.000009     if g:vimtex_quickfix_autoclose_after_keystrokes > 0
                                  augroup vimtex_qf_autoclose
                                    autocmd!
                                    autocmd CursorMoved,CursorMovedI * call s:qf_autoclose_check()
                                  augroup END
    3              0.000002     endif
    3              0.004020     redraw
    3              0.000007   endif

FUNCTION  vimtex#paths#join()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/paths.vim:34
Called 3 times
Total time:   0.000061
 Self time:   0.000018

count  total (s)   self (s)
    3   0.000059   0.000016   return vimtex#paths#s(a:root . '/' . a:tail)

FUNCTION  vimtex#cache#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim:7
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   command! -buffer -nargs=1 VimtexClearCache call vimtex#cache#clear(<q-args>)

FUNCTION  vimtex#env#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/env.vim:7
Called 1 time
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000007   nnoremap <silent><buffer> <plug>(vimtex-env-change) :<c-u>call <sid>operator_setup('change', 'normal')<bar>normal! g@l<cr>
                            
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-env-change-math) :<c-u>call <sid>operator_setup('change', 'math')<bar>normal! g@l<cr>
                            
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-env-delete) :<c-u>call <sid>operator_setup('delete', 'normal')<bar>normal! g@l<cr>
                            
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-env-delete-math) :<c-u>call <sid>operator_setup('delete', 'math')<bar>normal! g@l<cr>
                            
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-env-toggle-star) :<c-u>call <sid>operator_setup('toggle_star', '')<bar>normal! g@l<cr>
                            
    1              0.000006   nnoremap <silent><buffer> <plug>(vimtex-env-toggle-math) :<c-u>call <sid>operator_setup('toggle_math', '')<bar>normal! g@l<cr>
                            
    1              0.000005   nnoremap <silent><buffer><expr> <plug>(vimtex-env-surround-operator) vimtex#env#surround_opfunc('operator')
    1              0.000006   nmap     <silent><buffer>       <plug>(vimtex-env-surround-line) <plug>(vimtex-env-surround-operator)_
    1              0.000005   xnoremap <silent><buffer>       <plug>(vimtex-env-surround-visual) :<c-u>call vimtex#env#surround_opfunc('visual')<cr>

FUNCTION  vimtex#cmd#parser_separator_check()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cmd.vim:272
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000017   return a:separator_string =~# '\v^%(\n\s*)?$'

FUNCTION  <SNR>56_root()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim:299
Called 3 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    3              0.000030   return get(g:, 'vimtex_cache_root', (empty($XDG_CACHE_HOME) ? $HOME . '/.cache' : $XDG_CACHE_HOME) . '/vimtex')

FUNCTION  vimtex#syntax#in()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/syntax.vim:18
Called 43 times
Total time:   0.004342
 Self time:   0.001299

count  total (s)   self (s)
   43   0.004291   0.001249   return match(call('vimtex#syntax#stack', a:000), '^' . a:name) >= 0

FUNCTION  vimtex#cache#path()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim:13
Called 3 times
Total time:   0.000273
 Self time:   0.000085

count  total (s)   self (s)
    3   0.000046   0.000014   let l:root = s:root()
    3              0.000011   if !isdirectory(l:root)
                                call mkdir(l:root, 'p')
    3              0.000002   endif
                            
    3   0.000205   0.000049   return vimtex#paths#join(l:root, a:name)

FUNCTION  vimtex#toc#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/toc.vim:7
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_toc_enabled | return | endif
                            
    1              0.000003   command! -buffer VimtexTocOpen   call b:vimtex.toc.open()
    1              0.000003   command! -buffer VimtexTocToggle call b:vimtex.toc.toggle()
                            
    1              0.000005   nnoremap <buffer> <plug>(vimtex-toc-open)   :call b:vimtex.toc.open()<cr>
    1              0.000004   nnoremap <buffer> <plug>(vimtex-toc-toggle) :call b:vimtex.toc.toggle()<cr>

FUNCTION  vimtex#fold#env_options#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/env_options.vim:7
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   return extend(deepcopy(s:folder), a:config)

FUNCTION  vimtex#qf#latexlog#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/latexlog.vim:7
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return deepcopy(s:qf)

FUNCTION  vimtex#state#init()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state.vim:16
Called 1 time
Total time:   0.008777
 Self time:   0.000078

count  total (s)   self (s)
    1   0.001249   0.000008   let [l:main, l:main_parser, l:unsupported_modules] = s:get_main()
    1   0.000018   0.000008   let l:id = s:get_main_id(l:main)
                            
    1              0.000001   if l:id >= 0
                                let b:vimtex_id = l:id
                                let b:vimtex = s:vimtex_states[l:id]
    1              0.000001   else
    1              0.000002     let b:vimtex_id = s:vimtex_next_id
    1   0.007497   0.000048     let b:vimtex = vimtex#state#class#new({ 'main': l:main, 'main_parser': l:main_parser, 'unsupported_modules': l:unsupported_modules})
    1              0.000002     let s:vimtex_next_id += 1
    1              0.000003     let s:vimtex_states[b:vimtex_id] = b:vimtex
    1              0.000001   endif

FUNCTION  <SNR>90_init_delim_regexes()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:1109
Called 1 time
Total time:   0.000506
 Self time:   0.000360

count  total (s)   self (s)
    1              0.000002   let l:re = {}
    1              0.000001   let l:re.env_all = {}
    1              0.000002   let l:re.delim_all = {}
    1              0.000001   let l:re.all = {}
                            
    1   0.000032   0.000007   let l:re.env_tex = s:init_delim_regexes_generator('env_tex')
    1   0.000033   0.000006   let l:re.env_math = s:init_delim_regexes_generator('env_math')
    1   0.000029   0.000006   let l:re.delim_tex = s:init_delim_regexes_generator('delim_tex')
    1   0.000043   0.000006   let l:re.delim_math = s:init_delim_regexes_generator('delim_math')
    1   0.000041   0.000006   let l:re.mods = s:init_delim_regexes_generator('mods')
                            
    1              0.000014   let l:o = join(map(copy(g:vimtex#delim#lists.delim_math.re), 'v:val[0]'), '\|')
    1              0.000013   let l:c = join(map(copy(g:vimtex#delim#lists.delim_math.re), 'v:val[1]'), '\|')
                            
                              "
                              " Matches modified math delimiters
                              "
    1              0.000020   let l:re.delim_mod_math = { 'open' : '\%(\%(' . l:re.mods.open . '\)\)\s*\\\@<!\%('   . l:o . '\)\|\\left\s*\.', 'close' : '\%(\%(' . l:re.mods.close . '\)\)\s*\\\@<!\%('   . l:c . '\)\|\\right\s*\.', 'both' : '\%(\%(' . l:re.mods.both . '\)\)\s*\\\@<!\%('   . l:o . '\|' . l:c . '\)\|\\\%(left\|right\)\s*\.',}
                            
                              "
                              " Matches possibly modified math delimiters
                              "
    1              0.000019   let l:re.delim_modq_math = { 'open' : '\%(\%(' . l:re.mods.open . '\)\s*\)\?\\\@<!\%('   . l:o . '\)\|\\left\s*\.', 'close' : '\%(\%(' . l:re.mods.close . '\)\s*\)\?\\\@<!\%('   . l:c . '\)\|\\right\s*\.', 'both' : '\%(\%(' . l:re.mods.both . '\)\s*\)\?\\\@<!\%('   . l:o . '\|' . l:c . '\)\|\\\%(left\|right\)\s*\.',}
                            
    4              0.000005   for k in ['open', 'close', 'both']
    3              0.000014     let l:re.env_all[k] = l:re.env_tex[k] . '\|' . l:re.env_math[k]
    3              0.000015     let l:re.delim_all[k] = l:re.delim_modq_math[k] . '\|' . l:re.delim_tex[k]
    3              0.000015     let l:re.all[k] = l:re.env_all[k] . '\|' . l:re.delim_all[k]
    4              0.000002   endfor
                            
                              "
                              " Be explicit about regex mode (set magic mode)
                              "
   11              0.000011   for l:type in values(l:re)
   40              0.000042     for l:side in ['open', 'close', 'both']
   30              0.000088       let l:type[l:side] = '\m' . l:type[l:side]
   40              0.000018     endfor
   11              0.000005   endfor
                            
    1              0.000001   return l:re

FUNCTION  <SNR>70_fix_paths_hbox_warning()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/latexlog.vim:152
Called 9 times
Total time:   0.033761
 Self time:   0.012592

count  total (s)   self (s)
    9              0.000080   if a:qf.text !~# 'Underfull\|Overfull' | return v:false | endif
                            
    9              0.000066   let l:index = index(a:log, a:qf.text)
    9              0.000031   if l:index < 0 | return v:false | endif
                            
                              " Check index cache first
    9              0.000031   if has_key(a:cache.index, l:index)
    3              0.000011     if has_key(a:cache.index[l:index], 'bufnr')
    3              0.000009       let a:qf.bufnr = a:cache.index[l:index].bufnr
                                else
                                  let a:qf.bufnr = 0
                                  let a:qf.filename = a:cache.index[l:index].filename
    3              0.000002     endif
    3              0.000004     return v:true
    6              0.000003   endif
                            
                              " Search for a line above the Overflow/Underflow message that specifies the
                              " correct source filename
    6              0.000009   let l:file = ''
    6              0.000008   let l:level = 1
  483              0.000508   for l:lnum in range(l:index - 1, 1, -1)
                                " Check line number cache
  483              0.001306     if has_key(a:cache.paths, l:lnum)
    3              0.000009       let l:file = a:cache.paths[l:lnum]
    3              0.000011       let a:cache.paths[l:index] = l:file
    3              0.000002       break
  480              0.000230     endif
                            
  480   0.009720   0.002993     let l:level += vimtex#util#count(a:log[l:lnum], ')')
  480   0.017331   0.002906     let l:level -= vimtex#util#count(a:log[l:lnum], '(')
  954              0.001577     if l:lnum < l:index - 1 && l:level > 0 | continue | endif
                            
    9              0.000098     let l:file = matchstr(a:log[l:lnum], '\v\(\zs\f+\ze\)?\s*%(\[\d+]?)?$')
    9              0.000021     if !empty(l:file)
                                  " Do some simple parsing and cleanup of the filename
    3   0.000037   0.000020       if !vimtex#paths#is_abs(l:file)
    3              0.000018         let l:file = simplify(a:root . '/' . l:file)
    3              0.000002       endif
                            
                                  " Store in line number cache
    3              0.000011       let a:cache.paths[l:index] = l:file
    3              0.000002       break
    6              0.000004     endif
   12              0.000044   endfor
                            
    6              0.000089   if empty(l:file) || !filereadable(l:file) | return v:false | endif
                            
    6              0.000083   let l:bufnr = bufnr(l:file)
    6              0.000010   if l:bufnr > 0
    6              0.000049     let a:qf.bufnr = bufnr(l:file)
    6              0.000033     let a:cache.index[l:index] = {'bufnr': a:qf.bufnr}
                              else
                                let a:qf.bufnr = 0
                                let a:qf.filename = fnamemodify(l:file, ':.')
                                let a:cache.index[l:index] = {'filename': a:qf.filename}
    6              0.000004   endif
                            
    6              0.000009   return v:true

FUNCTION  vimtex#log#info()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/log.vim:15
Called 4 times
Total time:   0.009779
 Self time:   0.000044

count  total (s)   self (s)
    4   0.009772   0.000036   call s:logger.add(a:000, 'info')

FUNCTION  <SNR>117_setup_toc()
    Defined: /usr/local/share/nvim/runtime/ftplugin/qf.vim:20
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005   if get(w:, 'quickfix_title') !~# '\<TOC$' || &syntax != 'qf'
    1              0.000001     return
                              endif
                            
                              let list = getloclist(0)
                              if empty(list)
                                return
                              endif
                            
                              let bufnr = list[0].bufnr
                              setlocal modifiable
                              silent %delete _
                              call setline(1, map(list, 'v:val.text'))
                              setlocal nomodifiable nomodified
                              let &syntax = getbufvar(bufnr, '&syntax')

FUNCTION  206()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/log.vim:76
Called 5 times
Total time:   0.012715
 Self time:   0.001051

count  total (s)   self (s)
    5              0.000023   let l:msg_list = []
   10              0.000029   for l:msg in a:msg_arg
    5              0.000028     if type(l:msg) == v:t_string
    5              0.000025       call add(l:msg_list, l:msg)
                                elseif type(l:msg) == v:t_list
                                  call extend(l:msg_list, filter(l:msg, 'type(v:val) == v:t_string'))
    5              0.000005     endif
   10              0.000021   endfor
                            
    5              0.000016   let l:entry = {}
    5              0.000015   let l:entry.type = a:type
    5              0.000100   let l:entry.time = strftime('%T')
    5              0.000014   let l:entry.msg = l:msg_list
    5   0.010963   0.000294   let l:entry.callstack = vimtex#debug#stacktrace()[2:]
   17              0.000030   for l:level in l:entry.callstack
   12              0.000025     let l:level.nr -= 2
   17              0.000014   endfor
    5              0.000022   call add(self.entries, l:entry)
                            
    5              0.000009   if self.verbose
    5              0.000020     if self.type_to_level[a:type] > 1
    1   0.000312   0.000029       unsilent call self.notify(l:msg_list, a:type)
    4              0.000003     else
    4   0.000859   0.000148       call self.notify(l:msg_list, a:type)
    5              0.000004     endif
    5              0.000003   endif

FUNCTION  vimtex#context#init_state()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/context.vim:14
Called 1 time
Total time:   0.000171
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000002   let a:state.context_menu = []
                            
    2              0.000004   for l:handler in copy(s:handlers)
    1   0.000159   0.000041     call add(a:state.context_menu, vimtex#context#{l:handler}#new())
    2              0.000001   endfor

FUNCTION  186()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:627
Called 1 time
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
    1              0.000023   let result = extend(deepcopy(self), a:ctx, 'keep')
    1              0.000004   unlet result.detect
    1              0.000003   unlet result.parse
                            
    1              0.000021   let result.name = matchstr(a:ctx.match, '{\zs[^}*]*\ze\*\?}')
    1              0.000021   let result.starred = match(a:ctx.match, '\*}$') > 0
    1              0.000011   let result.side = a:ctx.match =~# '\\begin' ? 'open' : 'close'
    1              0.000006   let result.is_open = result.side ==# 'open'
                            
    1              0.000007   let result.gms_flags = result.is_open ? 'nW' : 'bnW'
    1              0.000020   let result.gms_stopline = result.is_open ? line('.') + g:vimtex_delim_stopline : max([1, line('.') - g:vimtex_delim_stopline])
                            
    1              0.000003   if result.is_open
                                let result.env_cmd = vimtex#cmd#get_at(a:ctx.lnum, a:ctx.cnum)
    1              0.000001   endif
                            
    1              0.000024   let result.corr = result.is_open ? substitute(a:ctx.match, 'begin', 'end', '') : substitute(a:ctx.match, 'end', 'begin', '')
                            
    1              0.000010   let result.re.this = result.is_open ? result.re.open  : result.re.close
    1              0.000009   let result.re.corr = result.is_open ? result.re.close : result.re.open
                            
    1              0.000003   return result

FUNCTION  vimtex#compiler#init_state()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler.vim:35
Called 1 time
Total time:   0.001118
 Self time:   0.000009

count  total (s)   self (s)
    1   0.001117   0.000009   let a:state.compiler = s:init_compiler({'state': a:state})

FUNCTION  <SNR>66_init_compiler()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler.vim:314
Called 1 time
Total time:   0.001109
 Self time:   0.000077

count  total (s)   self (s)
    1              0.000006   if type(g:vimtex_compiler_method) == v:t_func || exists('*' . g:vimtex_compiler_method)
                                let l:method = call(g:vimtex_compiler_method, [a:options.state.tex])
    1              0.000001   else
    1              0.000002     let l:method = g:vimtex_compiler_method
    1              0.000001   endif
                            
    1              0.000005   if index([ 'arara', 'generic', 'latexmk', 'latexrun', 'tectonic',], l:method) < 0
                                call vimtex#log#error('Error! Invalid compiler method: ' . l:method)
                                let l:method = 'latexmk'
    1              0.000001   endif
                            
    1              0.000004   let l:options = get(g:, 'vimtex_compiler_' . l:method, {})
    1              0.000006   let l:options = extend(deepcopy(l:options), a:options)
    1   0.001074   0.000043   let l:compiler = vimtex#compiler#{l:method}#init(l:options)
    1              0.000001   return l:compiler

FUNCTION  vimtex#util#count()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/util.vim:12
Called 960 times
Total time:   0.021152
 Self time:   0.021152

count  total (s)   self (s)
  960              0.003127   if empty(a:pattern) | return 0 | endif
                            
  960              0.001186   let l:count = 1
 1215              0.005528   while match(a:line, a:pattern, 0, l:count) >= 0
  255              0.000388     let l:count += 1
 1215              0.000759   endwhile
                            
  960              0.001162   return l:count - 1

FUNCTION  vimtex#qf#init_state()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf.vim:16
Called 1 time
Total time:   0.000210
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_quickfix_enabled | return | endif
                            
    1              0.000001   try
    1   0.000180   0.000041     let l:qf = vimtex#qf#{g:vimtex_quickfix_method}#new()
    1   0.000016   0.000004     call l:qf.init(a:state)
    1              0.000001     unlet l:qf.init
    1              0.000002     let a:state.qf = l:qf
                              catch /VimTeX: Requirements not met/
                                call vimtex#log#warning( 'Quickfix state not initialized!', 'Please see :help g:vimtex_quickfix_method')
    1              0.000001   endtry

FUNCTION  <SNR>58_file_is_main()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state.vim:490
Called 1 time
Total time:   0.000860
 Self time:   0.000137

count  total (s)   self (s)
    1              0.000007   if !filereadable(a:file) | return 0 | endif
                            
    1   0.000768   0.000044   let l:preamble = vimtex#parser#preamble(a:file, { 'root' : fnamemodify(a:file, ':p:h'),})
                            
                              " Check if a:file is a main file by looking for the \documentclass command,
                              " but ignore the following:
                              " * \documentclass[...]{subfiles}
                              " * \documentclass[...]{standalone}
    1              0.000003   let l:lines = copy(l:preamble)
    1              0.000034   call filter(l:lines, 'v:val =~# ''^\s*\\documentclass\_\s*[\[{]''')
    1              0.000005   call filter(l:lines, 'v:val !~# ''{subfiles}''')
    1              0.000005   call filter(l:lines, 'v:val !~# ''{standalone}''')
    1              0.000004   if len(l:lines) == 0 | return 0 | endif
                            
                              " A main file must also contain `\begin{document}`
    1              0.000003   let l:lines = copy(l:preamble)
    1              0.000026   call filter(l:lines, 'v:val =~# ''^\s*\\begin\s*{document}''')
    1              0.000002   return len(l:lines) > 0

FUNCTION  <SNR>67_compare_with_latexmkrc()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/latexmk.vim:271
Called 2 times
Total time:   0.000293
 Self time:   0.000047

count  total (s)   self (s)
                              " Check if option is specified in .latexmkrc.
                              " If it is, .latexmkrc should be respected!
    2   0.000266   0.000020   let l:value = vimtex#compiler#latexmk#get_rc_opt( a:dict.state.root, a:option, 0, '')[0]
    2              0.000004   if !empty(l:value)
                                if !empty(a:dict[a:option]) && (a:dict[a:option] !=# l:value)
                                  call vimtex#log#warning( 'Option "' . a:option . '" is overriden by latexmkrc', 'Changed from: ' . a:dict[a:option], 'Changed to: ' . l:value)
                                endif
                                let a:dict[a:option] = l:value
    2              0.000001   endif

FUNCTION  vimtex#jobs#neovim#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/jobs/neovim.vim:7
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000010   let l:job = deepcopy(s:job)
    1              0.000006   let l:job.cmd = has('win32') ? 'cmd /s /c "' . a:cmd . '"' : ['sh', '-c', a:cmd]
    1              0.000001   return l:job

FUNCTION  vimtex#fold#cmd_addplot#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_addplot.vim:7
Called 1 time
Total time:   0.000023
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000023   0.000008   return extend(deepcopy(s:folder), a:config).init()

FUNCTION  vimtex#pos#val()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/pos.vim:24
Called 2 times
Total time:   0.000104
 Self time:   0.000039

count  total (s)   self (s)
    2   0.000090   0.000024   let [l:lnum, l:cnum; l:rest] = s:parse_args(a:000)
                            
    2              0.000012   return 100000*l:lnum + min([l:cnum, 90000])

FUNCTION  vimtex#log#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/log.vim:7
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000003   command! -buffer -bang VimtexLog call vimtex#log#open()
                            
    1              0.000004   nnoremap <buffer> <plug>(vimtex-log) :VimtexLog<cr>

FUNCTION  vimtex#fold#cmd_single_opt#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_single_opt.vim:7
Called 1 time
Total time:   0.000027
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000026   0.000009   return extend(deepcopy(s:folder), a:config).init()

FUNCTION  <SNR>109_echo_formatted()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/ui.vim:187
Called 5 times
Total time:   0.000506
 Self time:   0.000506

count  total (s)   self (s)
    5              0.000060   echo repeat(' ', a:opts.indent)
    5              0.000006   try
   15              0.000055     for l:part in a:parts
   10              0.000035       if type(l:part) == v:t_string
    5              0.000010         echohl VimtexMsg
    5              0.000039         echon l:part
    5              0.000005       else
    5              0.000037         execute 'echohl' l:part[0]
    5              0.000095         echon l:part[1]
   10              0.000008       endif
   10              0.000019       unlet l:part
   15              0.000014     endfor
    5              0.000006   finally
    5              0.000007     echohl None
    5              0.000005   endtry

FUNCTION  vimtex#debug#stacktrace()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/debug.vim:7
Called 5 times
Total time:   0.010670
 Self time:   0.008415

count  total (s)   self (s)
                              " This function builds on Luc Hermite's answer on Stack Exchange:
                              " http://vi.stackexchange.com/a/6024/21
                            
                              " Get stack and exception
    5              0.000021   if empty(v:throwpoint)
    5              0.000008     try
    5              0.000037       throw 'dummy'
    5              0.000054     catch
    5              0.000078       let l:stack = reverse(split(v:throwpoint, '\.\.'))[1:]
    5              0.000014       let l:exception = 'Manual stacktrace'
    5              0.000010     endtry
                              else
                                let l:stack = reverse(split(v:throwpoint, '\.\.'))
                                let l:exception = v:exception
    5              0.000004   endif
                            
                              " Build the quickfix entries
    5              0.000011   let l:qflist = []
    5              0.000014   let l:files = {}
   27              0.000045   for l:func in l:stack
   22              0.000019     try
   22              0.000584       let [l:name, l:offset] = (l:func =~# '\S\+\[\d') ? matchlist(l:func, '\(\S\+\)\[\(\d\+\)\]')[1:2] : matchlist(l:func, '\(\S\+\), line \(\d\+\)')[1:2]
                                catch
                                  let l:name = l:func
                                  let l:offset = 0
   22              0.000018     endtry
                            
   22              0.000151     if l:name =~# '\v(\<SNR\>|^)\d+_'
    6              0.000043       let l:sid = matchstr(l:name, '\v(\<SNR\>|^)\zs\d+\ze_')
    6              0.000038       let l:name  = substitute(l:name, '\v(\<SNR\>|^)\d+_', 's:', '')
    6   0.001063   0.000109       let l:filename = substitute( vimtex#util#command('scriptnames')[l:sid-1], '^\s*\d\+:\s*', '', '')
   16              0.000012     else
   16              0.000111       let l:func_name = l:name =~# '^\d\+$' ? '{' . l:name . '}' : l:name
   16   0.001148   0.000195       let l:func_lines = vimtex#util#command('verbose function ' . l:func_name)
   16              0.000053       if len(l:func_lines) > 1
   16              0.000373         let l:filename = matchstr( l:func_lines[1], v:lang[0:1] ==# 'en'   ? 'Last set from \zs.*\.vim' : '\f\+\.vim')
                                  else
                                    let l:filename = 'NOFILE'
   16              0.000011       endif
   22              0.000017     endif
                            
   22              0.000249     let l:filename = fnamemodify(l:filename, ':p')
   22              0.000145     if filereadable(l:filename)
   22              0.000080       if !has_key(l:files, l:filename)
   13              0.000787         let l:files[l:filename] = reverse(readfile(l:filename))
   22              0.000016       endif
                            
   22              0.000097       if l:name =~# '^\d\+$'
    5              0.000011         let l:lnum = 0
    5   0.000411   0.000063         let l:output = vimtex#util#command('function {' . l:name . '}')
    5              0.000116         let l:text = substitute( matchstr(l:output, '^\s*' . l:offset), '^\d\+\s*', '', '')
   17              0.000012       else
   17              0.002260         let l:lnum = l:offset + len(l:files[l:filename]) - match(l:files[l:filename], '^\s*fu\%[nction]!\=\s\+' . l:name .'(')
   17              0.000083         let l:lnum_rev = len(l:files[l:filename]) - l:lnum
   17              0.000150         let l:text = substitute(l:files[l:filename][l:lnum_rev], '^\s*', '', '')
   22              0.000016       endif
                                else
                                  let l:filename = ''
                                  let l:lnum = 0
                                  let l:text = ''
   22              0.000014     endif
                            
   22              0.000327     call add(l:qflist, { 'filename': l:filename, 'function': l:name, 'lnum': l:lnum, 'text': len(l:qflist) == 0 ? l:exception : l:text, 'nr': len(l:qflist),})
   27              0.000051   endfor
                            
                              " Fill in empty filenames
    5              0.000019   let l:prev_filename = '_'
    5              0.000017   call reverse(l:qflist)
   27              0.000041   for l:entry in l:qflist
   22              0.000064     if empty(l:entry.filename)
                                  let l:entry.filename = l:prev_filename
   22              0.000016     endif
   22              0.000058     let l:prev_filename = l:entry.filename
   27              0.000022   endfor
    5              0.000014   call reverse(l:qflist)
                            
    5              0.000011   if a:0 > 0
                                call setqflist(l:qflist)
                                execute 'copen' len(l:qflist) + 2
                                wincmd p
    5              0.000005   endif
                            
    5              0.000010   return l:qflist

FUNCTION  vimtex#fold#preamble#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/preamble.vim:7
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   return extend(deepcopy(s:folder), a:config)

FUNCTION  vimtex#jobs#cached()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/jobs.vim:67
Called 2 times
Total time:   0.000710
 Self time:   0.000072

count  total (s)   self (s)
                              " Cached version of vimtex#jobs#capture(...)
    2   0.000565   0.000045   let l:cache = vimtex#cache#open('capture')
                            
    2   0.000143   0.000025   return l:cache.has(a:cmd) ? l:cache.get(a:cmd) : l:cache.set(a:cmd, vimtex#jobs#capture(a:cmd))

FUNCTION  vimtex#syntax#packages#init()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/syntax/packages.vim:7
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000017   if !exists('b:vimtex') || !exists('b:vimtex_syntax') | return | endif
                            
                              " Initialize project cache (used e.g. for the minted package)
                              if !has_key(b:vimtex, 'syntax')
                                let b:vimtex.syntax = {}
                              endif
                            
                              call s:register_packages()
                            
                              let l:loaded = 0
                              for [l:pkg, l:cfg] in items(b:vimtex_syntax)
                                if !l:cfg.__load || l:cfg.__loaded | continue | endif
                            
                                call vimtex#syntax#p#{l:pkg}#load(l:cfg)
                                let l:cfg.__loaded = 1
                                let l:loaded += 1
                              endfor
                            
                              if l:loaded > 0
                                call vimtex#syntax#core#init_custom()
                              endif

FUNCTION  <SNR>26_Remove_Matches()
    Defined: /usr/local/share/nvim/runtime/plugin/matchparen.vim:197
Called 114 times
Total time:   0.002785
 Self time:   0.002785

count  total (s)   self (s)
  114              0.001173   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
  114              0.000215   endif

FUNCTION  vimtex#imaps#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/imaps.vim:7
Called 1 time
Total time:   0.004709
 Self time:   0.000475

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_imaps_enabled | return | endif
                            
                              " Store mappings in buffer
    1              0.000002   if !exists('b:vimtex_imaps')
    1              0.000002     let b:vimtex_imaps = []
    1              0.000001   endif
                            
                              "
                              " Create imaps
                              "
    1              0.000002   let l:maps = g:vimtex_imaps_list
    1              0.000002   for l:disable in g:vimtex_imaps_disabled
                                let l:maps = filter(l:maps, {_, x -> x.lhs !=# l:disable})
    1              0.000001   endfor
   75              0.000072   for l:map in l:maps + get(s:, 'custom_maps', [])
   74   0.004555   0.000321     call s:create_map(l:map)
   75              0.000041   endfor
                            
                              "
                              " Add mappings and commands
                              "
    1              0.000003   command! -buffer  VimtexImapsList            call vimtex#imaps#list()
    1              0.000005   nnoremap <buffer> <plug>(vimtex-imaps-list) :call vimtex#imaps#list()<cr>

FUNCTION  vimtex#parser#tex#parse_preamble()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/parser/tex.vim:45
Called 3 times
Total time:   0.001569
 Self time:   0.000255

count  total (s)   self (s)
    3              0.000047   let l:opts = extend({ 'root': exists('b:vimtex.root') ? b:vimtex.root : '',}, a:opts)
                            
    3   0.000359   0.000052   let l:cache = vimtex#cache#open('parser_preamble', { 'persistent': v:false, 'default': {'time': -2},})
    3   0.000071   0.000027   let l:current = l:cache.get(a:file)
                            
    3              0.000044   let l:time = min([localtime() - 60, getftime(a:file)])
    3              0.000008   if l:time > l:current.time
    2              0.000007     let l:current.time = l:time
    2   0.001000   0.000037     let l:current.lines = s:parse_preamble(a:file, l:opts, [])
    3              0.000003   endif
                            
    3              0.000016   return deepcopy(l:current.lines)

FUNCTION  vimtex#state#class#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state/class.vim:7
Called 1 time
Total time:   0.007310
 Self time:   0.000377

count  total (s)   self (s)
    1              0.000009   let l:opts = extend({ 'main': '', 'main_parser': '', 'preserve_root': v:false, 'unsupported_modules': [],}, a:opts)
                            
    1              0.000005   let l:new = deepcopy(s:vimtex)
                            
    1              0.000004   let l:new.root = fnamemodify(l:opts.main, ':h')
    1              0.000003   let l:new.base = fnamemodify(l:opts.main, ':t')
    1              0.000003   let l:new.name = fnamemodify(l:opts.main, ':t:r')
    1              0.000002   let l:new.main_parser = l:opts.main_parser
                            
    1              0.000002   if l:opts.preserve_root && exists('b:vimtex')
                                let l:new.root = b:vimtex.root
                                let l:new.base = vimtex#paths#relative(l:opts.main, l:new.root)
    1              0.000001   endif
                            
    1              0.000003   let l:ext = fnamemodify(l:opts.main, ':e')
    1              0.000009   let l:new.tex = l:ext =~? '\v^%(%(la)?tex|dtx|tikz|ins)$' ? l:opts.main : ''
                            
                              " Get preamble for some state parsing
    1   0.000106   0.000010   let l:preamble = !empty(l:new.tex) ? vimtex#parser#preamble(l:new.tex, {'root' : l:new.root}) : []
                            
    1   0.000059   0.000008   let l:new.documentclass = s:parse_documentclass(l:preamble)
    1   0.000333   0.000008   let l:new.packages = s:parse_packages(l:preamble)
    1   0.000105   0.000009   let l:new.graphicspath = s:parse_graphicspath(l:preamble, l:new.root)
                            
                              " Initialize state in submodules
    7              0.000026   for l:mod in filter( ['view', 'compiler', 'qf', 'toc', 'fold', 'context'], 'index(l:opts.unsupported_modules, v:val) < 0')
    6   0.004977   0.000253     call vimtex#{l:mod}#init_state(l:new)
    7              0.000004   endfor
                            
                              " Update package list from fls file (if available)
    1   0.001644   0.000004   call l:new.update_packages()
                            
    1              0.000001   return l:new

FUNCTION  <SNR>53_init_highlights()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/options.vim:596
Called 1 time
Total time:   0.000763
 Self time:   0.000763

count  total (s)   self (s)
   37              0.000485   for [l:name, l:target] in [ ['VimtexImapsArrow', 'Comment'], ['VimtexImapsLhs', 'ModeMsg'], ['VimtexImapsRhs', 'ModeMsg'], ['VimtexImapsWrapper', 'Type'], ['VimtexInfo', 'Question'], ['VimtexInfoTitle', 'PreProc'], ['VimtexInfoKey', 'PreProc'], ['VimtexInfoValue', 'Statement'], ['VimtexInfoOther', ''], ['VimtexMsg', 'ModeMsg'], ['VimtexSuccess', 'Statement'], ['VimtexTodo', 'Todo'], ['VimtexWarning', 'WarningMsg'], ['VimtexError', 'Error'], ['VimtexFatal', 'ErrorMsg'], ['VimtexTocHelp', 'helpVim'], ['VimtexTocHelpKey', 'ModeMsg'], ['VimtexTocHelpLayerOn', 'Statement'], ['VimtexTocHelpLayerOff', 'Comment'], ['VimtexTocTodo', 'VimtexTodo'], ['VimtexTocWarning', 'VimtexWarning'], ['VimtexTocError', 'VimtexError'], ['VimtexTocFatal', 'VimtexFatal'], ['VimtexTocNum', 'Number'], ['VimtexTocSec0', 'Title'], ['VimtexTocSec1', ''], ['VimtexTocSec2', 'helpVim'], ['VimtexTocSec3', 'NonText'], ['VimtexTocSec4', 'Comment'], ['VimtexTocHotkey', 'Comment'], ['VimtexTocLabelsSecs', 'Statement'], ['VimtexTocLabelsEq', 'PreProc'], ['VimtexTocLabelsFig', 'Identifier'], ['VimtexTocLabelsTab', 'String'], ['VimtexTocIncl', 'Number'], ['VimtexTocInclPath', ''],]
   36              0.000107     if !hlexists(l:name) && !empty(l:target)
   33              0.000119       silent execute 'highlight default link' l:name l:target
   36              0.000016     endif
   37              0.000017   endfor

FUNCTION  <SNR>19_try()
    Defined: ~/.local/share/nvim/lazy/indent-blankline.nvim/plugin/indent_blankline.vim:7
Called 66 times
Total time:   0.040430
 Self time:   0.040430

count  total (s)   self (s)
   66              0.000226     try
   66              0.039504         execute a:cmd
                                catch /E12/
                                    return
   66              0.000144     endtry

FUNCTION  vimtex#util#shellescape()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/util.vim:143
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                              "
                              " Path used in "cmd" only needs to be enclosed by double quotes.
                              " shellescape() on Windows with "shellslash" set will produce a path
                              " enclosed by single quotes, which "cmd" does not recognize and reports an
                              " error.
                              "
    3              0.000010   if has('win32')
                                let l:shellslash = &shellslash
                                set noshellslash
                                let l:cmd = escape(shellescape(a:cmd), '\')
                                let &shellslash = l:shellslash
                                return l:cmd
    3              0.000002   else
    3              0.000015     return escape(shellescape(a:cmd), '\')
                              endif

FUNCTION  vimtex#util#extend_recursive()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/util.vim:106
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000003   let l:option = a:0 > 0 ? a:1 : 'force'
    1              0.000004   if index(['force', 'keep', 'error'], l:option) < 0
                                throw 'E475: Invalid argument: ' . l:option
    1              0.000000   endif
                            
    1              0.000003   for [l:key, l:value] in items(a:dict2)
                                if !has_key(a:dict1, l:key)
                                  let a:dict1[l:key] = l:value
                                elseif type(l:value) == v:t_dict
                                  call vimtex#util#extend_recursive(a:dict1[l:key], l:value, l:option)
                                elseif l:option ==# 'error'
                                  throw 'E737: Key already exists: ' . l:key
                                elseif l:option ==# 'force'
                                  let a:dict1[l:key] = l:value
                                endif
                                unlet l:value
    1              0.000001   endfor
                            
    1              0.000001   return a:dict1

FUNCTION  vimtex#misc#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/misc.vim:7
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000004   command! -buffer                VimtexReload call vimtex#misc#reload()
    1              0.000013   command! -buffer -bang -range=% VimtexCountWords call vimtex#misc#wordcount_display({   'range' : [<line1>, <line2>],   'detailed' : <q-bang> == '!',   'count_letters' : 0, })
    1              0.000011   command! -buffer -bang -range=% VimtexCountLetters call vimtex#misc#wordcount_display({   'range' : [<line1>, <line2>],   'detailed' : <q-bang> == '!',   'count_letters' : 1, })
                            
    1              0.000006   nnoremap <buffer> <plug>(vimtex-reload) :VimtexReload<cr>

FUNCTION  vimtex#parser#fls()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/parser.vim:24
Called 4 times
Total time:   0.000247
 Self time:   0.000062

count  total (s)   self (s)
    4   0.000246   0.000060   return vimtex#parser#fls#parse(a:file)

FUNCTION  207()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/log.vim:106
Called 5 times
Total time:   0.000994
 Self time:   0.000208

count  total (s)   self (s)
    5              0.000033   for l:re in get(g:, 'vimtex_log_ignore', [])
                                if join(a:msg_list) =~# l:re | return | endif
    5              0.000007   endfor
                            
    5   0.000869   0.000082   call vimtex#ui#echo([ [self.type_to_highlight[a:type], 'VimTeX:'], ' ' . a:msg_list[0]])
                            
                              " if len(a:msg_list) > 1
                              "   call vimtex#ui#echo(
                              "         \ join(map(a:msg_list[1:], "'        ' . v:val"), "\n"))
                              " endif
    5              0.000014   for l:msg in a:msg_list[1:]
                                call vimtex#ui#echo(l:msg, {'indent': 8})
    5              0.000004   endfor

FUNCTION  vimtex#jobs#start()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/jobs.vim:11
Called 1 time
Total time:   0.001988
 Self time:   0.000044

count  total (s)   self (s)
                              " Start a background process.
                              "
                              " The optional argument is a dictionary of options. Each option is parsed in
                              " the code below.
                              "
                              " Return: Job object.
    1              0.000002   let l:opts = a:0 > 0 ? a:1 : {}
                            
    1   0.000026   0.000007   let l:job = vimtex#jobs#{s:backend}#new(a:cmd)
    1              0.000002   let l:job.cmd_raw = a:cmd
    1              0.000006   let l:job.cwd = get(l:opts, 'cwd', exists('b:vimtex.root') ? b:vimtex.root : '')
    1              0.000005   let l:job.wait_timeout = str2nr(get(l:opts, 'wait_timeout', 5000))
    1              0.000003   let l:job.capture_output = get(l:opts, 'capture_output', v:false)
    1              0.000003   let l:job.detached = get(l:opts, 'detached', v:false)
                            
    1   0.001936   0.000011   return l:job.start()

FUNCTION  vimtex#fold#items#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/items.vim:7
Called 1 time
Total time:   0.000030
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000029   0.000008   return extend(deepcopy(s:folder), a:config).init()

FUNCTION  210()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/matchparen.vim:35
Called 1 time
Total time:   0.000708
 Self time:   0.000043

count  total (s)   self (s)
                              " vint: -ProhibitAutocmdWithNoGroup
                            
    1              0.000005   execute 'augroup vimtex_matchparen' . bufnr('%')
    1              0.000005     autocmd!
    1              0.000004     autocmd CursorMoved  <buffer> call s:matchparen.highlight()
    1              0.000003     autocmd CursorMovedI <buffer> call s:matchparen.highlight()
    1              0.000002     autocmd BufLeave     <buffer> call s:matchparen.clear()
    1              0.000003     autocmd WinLeave     <buffer> call s:matchparen.clear()
    1              0.000003     autocmd WinEnter     <buffer> call s:matchparen.highlight()
    1              0.000001     try
    1              0.000003       autocmd TextChangedP <buffer> call s:matchparen.highlight()
                                catch /E216/
                                  silent! let self.timer = timer_start(50, 'vimtex#matchparen#popup_check', {'repeat' : -1})
    1              0.000001     endtry
    1              0.000001   augroup END
                            
    1   0.000669   0.000004   call self.highlight()
                            
                              " vint: +ProhibitAutocmdWithNoGroup

FUNCTION  212()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/matchparen.vim:66
Called 45 times
Total time:   0.002871
 Self time:   0.002871

count  total (s)   self (s)
   45              0.001540   silent! call matchdelete(w:vimtex_match_id1)
   45              0.000906   silent! call matchdelete(w:vimtex_match_id2)
   45              0.000210   unlet! w:vimtex_match_id1
   45              0.000121   unlet! w:vimtex_match_id2

FUNCTION  213()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/matchparen.vim:72
Called 43 times
Total time:   0.061259
 Self time:   0.004015

count  total (s)   self (s)
   43   0.003177   0.000395   call self.clear()
                            
   43   0.006308   0.000847   if vimtex#syntax#in_comment() | return | endif
                            
                              " This is a hack to ensure that $ in visual block mode adhers to the rule
                              " specified in :help v_$
   43              0.000331   if mode() ==# "\<c-v>"
                                let l:pos = vimtex#pos#get_cursor()
                                if len(l:pos) == 5 && l:pos[-1] == 2147483647
                                  call feedkeys('$', 'in')
                                endif
   43              0.000058   endif
                            
   43   0.044525   0.000835   let l:current = vimtex#delim#get_current('all', 'both')
   43              0.000316   if empty(l:current) | return | endif
                            
    1   0.005328   0.000017   let l:corresponding = vimtex#delim#get_matching(l:current)
    1              0.000003   if empty(l:corresponding) | return | endif
    1              0.000003   if empty(l:corresponding.match) | return | endif
                            
    1              0.000006   let [l:open, l:close] = l:current.is_open ? [l:current, l:corresponding] : [l:corresponding, l:current]
                            
    1              0.000009   let w:vimtex_match_id1 = matchaddpos('MatchParen', [[l:open.lnum, l:open.cnum, strlen(l:open.match)]])
    1              0.000007   let w:vimtex_match_id2 = matchaddpos('MatchParen', [[l:close.lnum, l:close.cnum, strlen(l:close.match)]])

FUNCTION  219()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/jobs/neovim.vim:46
Called 1 time
Total time:   0.001925
 Self time:   0.001880

count  total (s)   self (s)
    1              0.000002   let l:options = {}
                            
    1              0.000001   if self.capture_output
                                let self._output = []
                                let l:options.on_stdout = function('s:__callback')
                                let l:options.on_stderr = function('s:__callback')
                                let l:options.stdout_buffered = v:true
                                let l:options.stderr_buffered = v:true
                                let l:options.output = self._output
    1              0.000000   endif
    1              0.000001   if self.detached
    1              0.000002     let l:options.detach = v:true
    1              0.000001   endif
    1              0.000002   if !empty(self.cwd)
    1              0.000002     let l:options.cwd = self.cwd
    1              0.000001   endif
                            
    1   0.000025   0.000006   call vimtex#jobs#neovim#shell_default()
    1              0.001809   let self.job = jobstart(self.cmd, l:options)
    1   0.000062   0.000036   call vimtex#jobs#neovim#shell_restore()
                            
    1              0.000004   return self

FUNCTION  vimtex#pos#get_cursor()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/pos.vim:12
Called 53 times
Total time:   0.000371
 Self time:   0.000371

count  total (s)   self (s)
   53              0.000326   return getcurpos()

FUNCTION  <SNR>102_parse_args()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/pos.vim:67
Called 62 times
Total time:   0.003339
 Self time:   0.003292

count  total (s)   self (s)
                              "
                              " The arguments should be in one of the following forms (when unpacked):
                              "
                              "   [lnum, cnum]
                              "   [bufnum, lnum, cnum, ...]
                              "   {'lnum' : lnum, 'cnum' : cnum}
                              "
                            
   62              0.000350   if len(a:args) > 1
    1              0.000016     return s:parse_args([a:args])
   61              0.000285   elseif len(a:args) == 1
   61              0.000437     if type(a:args[0]) == v:t_dict
    6              0.000048       return [get(a:args[0], 'lnum'), get(a:args[0], 'cnum')]
   55              0.000080     else
   55              0.000267       if len(a:args[0]) == 2
    1              0.000004         return a:args[0]
   54              0.000066       else
   54              0.000280         return a:args[0][1:]
                                  endif
                                endif
                              else
                                return a:args
                              endif

FUNCTION  vimtex#qf#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf.vim:7
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_quickfix_enabled | return | endif
                            
    1              0.000003   command! -buffer VimtexErrors  call vimtex#qf#toggle()
                            
    1              0.000006   nnoremap <buffer> <plug>(vimtex-errors)  :call vimtex#qf#toggle()<cr>

FUNCTION  228()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/bibtex.vim:35
Called 3 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    3              0.000007   let self.file = a:blg
    2              1.024265   if empty(self.file) || !filereadable(self.file) | throw 'BibTeX Aborted' | endif
                            
                              let self.types = map( filter(items(s:), 'v:val[0] =~# ''^type_'''), 'v:val[1]')
                              let self.db_files = []
                            
                              call vimtex#qf#u#caddfile(self, fnameescape(self.file))
                            
                              call self.fix_paths()

FUNCTION  <SNR>62_parse_documentclass()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state/class.vim:182
Called 1 time
Total time:   0.000051
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000038   0.000025   let l:preamble_lines = filter(copy(a:preamble), {_, x -> x !~# '^\s*%'})
    1              0.000012   return matchstr(join(l:preamble_lines, ''), '\\documentclass[^{]*{\zs[^}]\+\ze}')

FUNCTION  <SNR>58_get_main_from_texroot()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state.vim:290
Called 1 time
Total time:   0.000333
 Self time:   0.000119

count  total (s)   self (s)
    6              0.000010   for l:line in getline(1, 5)
    5   0.000283   0.000069     let l:file_pattern = matchstr(l:line, g:vimtex#re#tex_input_root)
    9              0.000014     if empty(l:file_pattern) | continue | endif
                            
                                if !vimtex#paths#is_abs(l:file_pattern)
                                  let l:file_pattern = simplify(expand('%:p:h') . '/' . l:file_pattern)
                                endif
                            
                                let l:candidates = glob(l:file_pattern, 0, 1)
                                if len(l:candidates) > 1
                                  return s:get_main_choose(l:candidates)
                                elseif len(l:candidates) == 1
                                  return l:candidates[0]
                                endif
    1              0.000001   endfor
                            
    1              0.000001   return ''

FUNCTION  <SNR>87_text_between()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cmd.vim:734
Called 4 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
    4              0.000024   let [l1, c1] = [a:p1.lnum, a:p1.cnum - (a:0 > 0)]
    4              0.000021   let [l2, c2] = [a:p2.lnum, a:p2.cnum - (a:0 <= 0)]
                            
    4              0.000016   let lines = getline(l1, l2)
    4              0.000010   if !empty(lines)
    4              0.000019     let lines[0] = strpart(lines[0], c1)
    4              0.000027     let lines[-1] = strpart(lines[-1], 0, l1 == l2 ? c2 - c1 : c2)
    4              0.000003   endif
    4              0.000016   return join(lines, "\n")

FUNCTION  vimtex#compiler#latexmk#init()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/latexmk.vim:7
Called 1 time
Total time:   0.000437
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000437   0.000005   return s:compiler.new(a:options)

FUNCTION  vimtex#fold#cmd_single#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/cmd_single.vim:7
Called 1 time
Total time:   0.000026
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000025   0.000008   return extend(deepcopy(s:folder), a:config).init()

FUNCTION  vimtex#compiler#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler.vim:7
Called 1 time
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_compiler_enabled | return | endif
                            
                              " Define commands
    1              0.000003   command! -buffer        VimtexCompile                        call vimtex#compiler#compile()
    1              0.000003   command! -buffer -bang  VimtexCompileSS                      call vimtex#compiler#compile_ss()
    1              0.000007   command! -buffer -range VimtexCompileSelected <line1>,<line2>call vimtex#compiler#compile_selected('command')
    1              0.000003   command! -buffer        VimtexCompileOutput                  call vimtex#compiler#output()
    1              0.000002   command! -buffer        VimtexStop                           call vimtex#compiler#stop()
    1              0.000003   command! -buffer        VimtexStopAll                        call vimtex#compiler#stop_all()
    1              0.000004   command! -buffer -bang  VimtexClean                          call vimtex#compiler#clean(<q-bang> == "!")
    1              0.000004   command! -buffer -bang  VimtexStatus                         call vimtex#compiler#status(<q-bang> == "!")
                            
                              " Define mappings
    1              0.000004   nnoremap <buffer> <plug>(vimtex-compile)          :call vimtex#compiler#compile()<cr>
    1              0.000004   nnoremap <buffer> <plug>(vimtex-compile-ss)       :call vimtex#compiler#compile_ss()<cr>
    1              0.000005   nnoremap <buffer> <plug>(vimtex-compile-selected) :set opfunc=vimtex#compiler#compile_selected<cr>g@
    1              0.000005   xnoremap <buffer> <plug>(vimtex-compile-selected) :<c-u>call vimtex#compiler#compile_selected('visual')<cr>
    1              0.000004   nnoremap <buffer> <plug>(vimtex-compile-output)   :call vimtex#compiler#output()<cr>
    1              0.000004   nnoremap <buffer> <plug>(vimtex-stop)             :call vimtex#compiler#stop()<cr>
    1              0.000004   nnoremap <buffer> <plug>(vimtex-stop-all)         :call vimtex#compiler#stop_all()<cr>
    1              0.000004   nnoremap <buffer> <plug>(vimtex-clean)            :call vimtex#compiler#clean(0)<cr>
    1              0.000004   nnoremap <buffer> <plug>(vimtex-clean-full)       :call vimtex#compiler#clean(1)<cr>
    1              0.000004   nnoremap <buffer> <plug>(vimtex-status)           :call vimtex#compiler#status(0)<cr>
    1              0.000004   nnoremap <buffer> <plug>(vimtex-status-all)       :call vimtex#compiler#status(1)<cr>

FUNCTION  vimtex#qf#u#caddfile()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/qf/u.vim:7
Called 3 times
Total time:   0.009215
 Self time:   0.008179

count  total (s)   self (s)
                              " This is a utility function for loading errors from a file into the quickfix
                              " window with ":caddfile" without calling possibly defined QuickFixCmdPost
                              " autotocmds e.g. from plugins like vim-qf.
                            
    3              0.000010   let l:errorformat_saved = &l:errorformat
    3   0.001040   0.000016   call a:qf.set_errorformat()
    3              0.008087   noautocmd execute 'caddfile' a:file
    3   0.000067   0.000055   let &l:errorformat = l:errorformat_saved

FUNCTION  vimtex#fold#sections#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/sections.vim:7
Called 1 time
Total time:   0.000051
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000051   0.000011   return extend(deepcopy(s:folder), a:config).init()

FUNCTION  vimtex#util#uniq_unsorted()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/util.vim:467
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000005   if len(a:list) <= 1 | return deepcopy(a:list) | endif
                            
    1              0.000002   let l:visited = {}
    1              0.000001   let l:result = []
    3              0.000004   for l:x in a:list
    2              0.000005     let l:key = string(l:x)
    2              0.000005     if !has_key(l:visited, l:key)
    2              0.000005       let l:visited[l:key] = 1
    2              0.000005       call add(l:result, l:x)
    2              0.000001     endif
    3              0.000002   endfor
                            
    1              0.000001   return l:result

FUNCTION  <SNR>87_get_cmd_name()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cmd.vim:681
Called 1 time
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000029   let [l:lnum, l:cnum] = searchpos( '\v\\%(\a+\*?|[,:;!])', a:next ? 'nW' : 'cbnW')
    1              0.000022   let l:match = matchstr(getline(l:lnum), '^\v\\%([,:;!]|\a*\*?)', l:cnum-1)
    1              0.000006   return [l:lnum, l:cnum, l:match]

FUNCTION  <SNR>27_LocalBrowse()
    Defined: /usr/local/share/nvim/runtime/plugin/netrwPlugin.vim:102
Called 5 times
Total time:   0.000360
 Self time:   0.000360

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    5              0.000028   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
    5              0.000007   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    5              0.000038   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    5              0.000043   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
    5              0.000005   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    5              0.000005   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  vimtex#info#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/info.vim:7
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000005   command! -buffer -bang VimtexInfo call vimtex#info#open(<q-bang> == '!')
                            
    1              0.000005   nnoremap <buffer> <plug>(vimtex-info)      :VimtexInfo<cr>
    1              0.000004   nnoremap <buffer> <plug>(vimtex-info-full) :VimtexInfo!<cr>

FUNCTION  <SNR>63_nvim_prune_servernames()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view.vim:176
Called 1 time
Total time:   0.000263
 Self time:   0.000217

count  total (s)   self (s)
                              " Load servernames from file
    1              0.000022   let l:servers = filereadable(s:nvim_servernames) ? readfile(s:nvim_servernames) : []
                            
                              " Check which servers are available
    1              0.000002   let l:available_servernames = []
    3   0.000058   0.000012   for l:server in vimtex#util#uniq_unsorted(l:servers + [v:servername])
    2              0.000001     try
    2              0.000075       let l:socket = sockconnect('pipe', l:server)
    1              0.000004       call add(l:available_servernames, l:server)
    1              0.000005       call chanclose(l:socket)
    1              0.000007     catch
    2              0.000002     endtry
    3              0.000002   endfor
                            
                              " Write the pruned list to file
    1              0.000069   call writefile(l:available_servernames, s:nvim_servernames)

FUNCTION  <SNR>67_wrap_option_appendcmd()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/latexmk.vim:288
Called 3 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
                              " Note: On Linux, we use double quoted perl strings; these interpolate
                              "       variables. One should therefore NOT pass values that contain `$`.
    3              0.000010   let l:win_cmd_sep = has('nvim') ? '^&' : '&'
    3              0.000013   let l:common = printf('$%s = ($%s ? $%s', a:name, a:name, a:name)
    3              0.000026   return has('win32') ? printf(' -e "%s . '' %s '' : '''') . ''%s''"',          l:common, l:win_cmd_sep, a:value) : printf(' -e ''%s . " ; " : "") . "%s"''',          l:common, a:value)

FUNCTION  vimtex#util#get_os()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/util.vim:88
Called 2 times
Total time:   0.000854
 Self time:   0.000080

count  total (s)   self (s)
    2   0.000021   0.000010   if vimtex#util#is_win()
                                return 'win'
    2              0.000003   elseif has('unix')
    2   0.000820   0.000058     if has('mac') || has('ios') || vimtex#jobs#cached('uname')[0] =~# 'Darwin'
                                  return 'mac'
    2              0.000001     else
    2              0.000002       return 'linux'
                                endif
                              endif

FUNCTION  <SNR>87_get_cmd()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cmd.vim:622
Called 1 time
Total time:   0.003911
 Self time:   0.000171

count  total (s)   self (s)
    1   0.000083   0.000023   let [lnum, cnum, match] = s:get_cmd_name(a:direction ==# 'next')
    1              0.000008   if lnum == 0 | return {} | endif
                            
    1              0.000038   let res = { 'name' : match, 'text' : '', 'pos_start' : { 'lnum' : lnum, 'cnum' : cnum }, 'pos_end' : { 'lnum' : lnum, 'cnum' : cnum + strlen(match) - 1 }, 'args' : [], 'opts' : [],}
                            
                              " Environments always start with environment name and allows option
                              " afterwords
    1              0.000004   if res.name ==# '\begin'
    1   0.002308   0.000017     let arg = s:get_cmd_part('{', res.pos_end)
    1              0.000003     if empty(arg) | return res | endif
                            
    1              0.000003     call add(res.args, arg)
    1              0.000002     let res.pos_end.lnum = arg.close.lnum
    1              0.000002     let res.pos_end.cnum = arg.close.cnum
    1              0.000001   endif
                            
                              " Get overlay specification
    1   0.000027   0.000008   let res.overlay = s:get_cmd_overlay(res.pos_end.lnum, res.pos_end.cnum)
    1              0.000002   if !empty(res.overlay)
                                let res.pos_end.lnum = res.overlay.close.lnum
                                let res.pos_end.cnum = res.overlay.close.cnum
    1              0.000000   endif
                            
                              " Get options and arguments
    1              0.000002   while v:true
    1   0.000656   0.000009     let opt = s:get_cmd_part('[', res.pos_end)
    1              0.000002     if !empty(opt)
                                  call add(res.opts, opt)
                                  let res.pos_end.lnum = opt.close.lnum
                                  let res.pos_end.cnum = opt.close.cnum
                                  continue
    1              0.000000     endif
                            
    1   0.000710   0.000010     let arg = s:get_cmd_part('{', res.pos_end)
    1              0.000002     if !empty(arg)
                                  call add(res.args, arg)
                                  let res.pos_end.lnum = arg.close.lnum
                                  let res.pos_end.cnum = arg.close.cnum
                                  continue
    1              0.000000     endif
                            
    1              0.000001     break
    1              0.000001   endwhile
                            
                              " Include entire cmd text
    1   0.000032   0.000008   let res.text = s:text_between(res.pos_start, res.pos_end, 1)
                            
    1              0.000001   return res

FUNCTION  vimtex#fold#envs#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/fold/envs.vim:7
Called 1 time
Total time:   0.000033
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000033   0.000011   return extend(deepcopy(s:folder), a:config).init()

FUNCTION  vimtex#matchparen#enable()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/matchparen.vim:15
Called 1 time
Total time:   0.000713
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000712   0.000004   call s:matchparen.enable()

FUNCTION  <SNR>90_init_delim_regexes_generator()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:1167
Called 5 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    5              0.000012   let l:list = g:vimtex#delim#lists[a:list_name]
    5              0.000047   let l:open = join(map(copy(l:list.re), 'v:val[0]'), '\|')
    5              0.000043   let l:close = join(map(copy(l:list.re), 'v:val[1]'), '\|')
                            
    5              0.000039   return { 'open' : '\\\@<!\%(' . l:open . '\)', 'close' : '\\\@<!\%(' . l:close . '\)', 'both' : '\\\@<!\%(' . l:open . '\|' . l:close . '\)'}

FUNCTION  vimtex#compiler#callback()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler.vim:41
Called 6 times
Total time:   0.100552
 Self time:   0.000677

count  total (s)   self (s)
                              " Status:
                              " 1: Compilation cycle has started
                              " 2: Compilation complete - Success
                              " 3: Compilation complete - Failed
    6              0.000036   if !exists('b:vimtex.compiler') | return | endif
    6              0.000106   silent! call s:output.pause()
                            
    6              0.000016   if b:vimtex.compiler.silence_next_callback
                                if g:vimtex_compiler_silent
                                  let b:vimtex.compiler.silence_next_callback = 0
                                else
                                  call vimtex#log#set_silent()
                                endif
    6              0.000004   endif
                            
    6              0.000020   let b:vimtex.compiler.status = a:status
                            
    6              0.000011   if a:status == 1
    3              0.000019     if exists('#User#VimtexEventCompiling')
                                  doautocmd <nomodeline> User VimtexEventCompiling
    3              0.000002     endif
    3              0.000022     silent! call s:output.resume()
    3              0.000004     return
    3              0.000002   endif
                            
    3              0.000004   if a:status == 2
    3              0.000006     if !g:vimtex_compiler_silent
    3   0.006883   0.000025       call vimtex#log#info('Compilation completed')
    3              0.000002     endif
                            
    3              0.000007     if exists('b:vimtex')
    3   0.004903   0.000021       call b:vimtex.update_packages()
    3   0.000742   0.000089       call vimtex#syntax#packages#init()
    3              0.000002     endif
                            
    3              0.000014     if exists('#User#VimtexEventCompileSuccess')
    3   0.002789   0.000014       doautocmd <nomodeline> User VimtexEventCompileSuccess
    3              0.000002     endif
                              elseif a:status == 3
                                if !g:vimtex_compiler_silent
                                  call vimtex#log#warning('Compilation failed!')
                                endif
                            
                                if exists('#User#VimtexEventCompileFailed')
                                  doautocmd <nomodeline> User VimtexEventCompileFailed
                                endif
    3              0.000002   endif
                            
    3              0.000009   if b:vimtex.compiler.silence_next_callback
                                call vimtex#log#set_silent_restore()
                                let b:vimtex.compiler.silence_next_callback = 0
    3              0.000002   endif
                            
    3   0.084738   0.000031   call vimtex#qf#open(0)
    3              0.000031   silent! call s:output.resume()

FUNCTION  <SNR>68_check_if_running()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/compiler/_template.vim:253
Called 20 times
Total time:   0.001622
 Self time:   0.000857

count  total (s)   self (s)
   20   0.001557   0.000792   if s:check_timers[a:timer].is_running() | return | endif
                            
                              call timer_stop(a:timer)
                              let l:compiler = remove(s:check_timers, a:timer)
                              unlet l:compiler.check_timer
                            
                              if l:compiler.vimtex_id == get(b:, 'vimtex_id', -1)
                                call vimtex#compiler#output()
                              endif
                              call vimtex#log#error('Compiler did not start successfully!')

FUNCTION  <SNR>52_init_buffer_tex()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex.vim:66
Called 1 time
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
    1              0.000006   setlocal comments=sO:%\ -,mO:%\ \ ,eO:%%,:%
    1              0.000002   setlocal commentstring=\%\ %s
                            
   20              0.000035   for l:suf in [ '.sty', '.cls', '.log', '.aux', '.bbl', '.out', '.blg', '.brf', '.cb', '.dvi', '.fdb_latexmk', '.fls', '.idx', '.ilg', '.ind', '.inx', '.pdf', '.synctex.gz', '.toc', ]
   19              0.000083     execute 'set suffixes+=' . l:suf
   20              0.000009   endfor
    1              0.000003   setlocal suffixesadd=.tex,.sty,.cls
    1              0.000022   setlocal iskeyword+=:
    1              0.000002   setlocal includeexpr=vimtex#include#expr()
                            
    1              0.000005   let &l:include = g:vimtex#re#tex_include
    1              0.000011   let &l:define  = '\v\\%(' . '([egx]|mathchar|count|dimen|muskip|skip|toks)?def' . '|font' . '|(future)?let' . '|new(count|dimen|skip|muskip|box|toks|read|write|fam|insert)' . '|(re)?new(boolean|command|counter|environment' .   '|font|if|length|savebox|theorem(style)?)' . '|DeclareMathOperator' . '|bibitem%(\[[^]]*\])?' . ')'
                            
                              " Specify list of modules to disable
    1              0.000001   return []

FUNCTION  vimtex#parser#preamble()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/parser.vim:12
Called 3 times
Total time:   0.001808
 Self time:   0.000084

count  total (s)   self (s)
                              " This will return the list of lines of the current project from the
                              " beginning of the preamble until and including the `\begin{document}`
    3   0.001801   0.000077   return vimtex#parser#tex#parse_preamble(a:file, a:0 > 0 ? a:1 : {})

FUNCTION  vimtex#jobs#neovim#shell_default()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/jobs/neovim.vim:27
Called 2 times
Total time:   0.000044
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000011   let s:saveshell = [&shell, &shellcmdflag, &shellslash]
    2   0.000017   0.000013   let &shell = 'cmd.exe'
    2   0.000008   0.000007   let &shellcmdflag = '/s /c'
    2              0.000005   set shellslash&

FUNCTION  vimtex#util#materialize_property()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/util.vim:129
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009   if type(get(a:dict, a:name)) != v:t_func | return | endif
                            
                              try
                                let a:dict[a:name] = a:dict[a:name]()
                              catch
                                call vimtex#log#error( 'Could not materialize property: ' . a:name, v:exception)
                                let a:dict[a:name] = ''
                              endtry

FUNCTION  <SNR>52_init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex.vim:37
Called 1 time
Total time:   0.013484
 Self time:   0.001586

count  total (s)   self (s)
    1              0.000001   try
    1   0.000195   0.000007     let l:disabled_modules = s:init_buffer_{&filetype}()
                              catch /E117/
                                let l:disabled_modules = []
    1              0.000001   endtry
                            
                              " Define autocommands
    1              0.000002   augroup vimtex_buffers
    1              0.000029     autocmd! * <buffer>
    1              0.000003     autocmd BufFilePre  <buffer> call s:filename_changed_pre()
    1              0.000003     autocmd BufFilePost <buffer> call s:filename_changed_post()
    1              0.000003     autocmd BufUnload   <buffer> call s:buffer_deleted('unload')
    1              0.000002     autocmd BufWipeout  <buffer> call s:buffer_deleted('wipe')
    1              0.000001   augroup END
                            
                              " Initialize buffer settings for sub modules
    1              0.000005   call extend(l:disabled_modules, get(b:vimtex, 'disabled_modules', []))
   39              0.000115   for l:mod in filter(copy(s:modules), 'index(l:disabled_modules, v:val) < 0')
   38              0.000020     try
   38   0.012879   0.001169       call vimtex#{l:mod}#init_buffer()
   17              0.000113     catch /E117.*#init_/
                                catch /E127.*vimtex#profile#/
   38              0.000023     endtry
   39              0.000021   endfor

FUNCTION  vimtex#complete#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/complete.vim:7
Called 1 time
Total time:   0.000107
 Self time:   0.000089

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_complete_enabled | return | endif
                            
    1              0.000003   if !has_key(b:vimtex, 'complete')
    1              0.000002     let b:vimtex.complete = {}
    1              0.000001   endif
                            
   13              0.000012   for l:completer in s:completers
   12              0.000022     if has_key(l:completer, 'init')
    3   0.000028   0.000010       call l:completer.init()
   12              0.000006     endif
   13              0.000007   endfor
                            
    1              0.000005   setlocal omnifunc=vimtex#complete#omnifunc

FUNCTION  vimtex#delim#get_current()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/delim.vim:383
Called 43 times
Total time:   0.043689
 Self time:   0.001936

count  total (s)   self (s)
   43   0.043647   0.001894   return s:get_delim(extend({ 'direction' : 'current', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  vimtex#toc#new()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/toc.vim:26
Called 1 time
Total time:   0.000066
 Self time:   0.000035

count  total (s)   self (s)
    1   0.000065   0.000034   return extend( deepcopy(s:toc), vimtex#util#extend_recursive(   deepcopy(g:vimtex_toc_config),   a:0 > 0 ? a:1 : {}))

FUNCTION  vimtex#view#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/view.vim:7
Called 1 time
Total time:   0.000289
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_view_enabled | return | endif
                            
    1              0.000005   command! -buffer -nargs=? -complete=file VimtexView call vimtex#view#view(<q-args>)
                            
    1              0.000005   nnoremap <buffer> <plug>(vimtex-view) :VimtexView<cr>
                            
    1              0.000003   if has('nvim')
    1   0.000269   0.000007     call s:nvim_prune_servernames()
    1              0.000001   endif

FUNCTION  <SNR>62_parse_packages()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/state/class.vim:189
Called 1 time
Total time:   0.000325
 Self time:   0.000092

count  total (s)   self (s)
    1              0.000045   let l:usepackages = filter(copy(a:preamble), 'v:val =~# ''\v%(usep|RequireP)ackage''')
    1              0.000005   let l:pat = g:vimtex#re#not_comment . g:vimtex#re#not_bslash . '\v\\%(usep|RequireP)ackage\s*%(\[[^[\]]*\])?\s*\{\s*\zs%([^{}]+)\ze\s*\}'
    1   0.000247   0.000014   call map(l:usepackages, {_, x -> split(matchstr(x, l:pat), '\s*,\s*')})
                            
    1              0.000002   let l:parsed = {}
    3              0.000004   for l:packages in l:usepackages
    4              0.000005     for l:package in l:packages
    2              0.000005       let l:parsed[l:package] = {}
    4              0.000003     endfor
    3              0.000002   endfor
                            
    1              0.000001   return l:parsed

FUNCTION  vimtex#cache#open()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cache.vim:44
Called 5 times
Total time:   0.000624
 Self time:   0.000174

count  total (s)   self (s)
    5              0.000095   let l:opts = extend({ 'local': v:false, 'default': 0, 'persistent': get(g:, 'vimtex_cache_persistent', v:true), 'validate': s:_version,}, a:0 > 0 ? a:1 : {})
                            
    5              0.000023   let l:project_local = remove(l:opts, 'local')
    5   0.000498   0.000048   return s:cache_open(a:name, l:project_local, l:opts)

FUNCTION  <SNR>61_parse_preamble()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/parser/tex.vim:255
Called 2 times
Total time:   0.000963
 Self time:   0.000963

count  total (s)   self (s)
    2              0.000031   if !filereadable(a:file) || index(a:parsed_files, a:file) >= 0
                                return []
    2              0.000002   endif
    2              0.000011   call add(a:parsed_files, a:file)
                            
    2              0.000006   let l:lines = []
   16              0.000145   for l:line in readfile(a:file)
   16              0.000272     if l:line =~# g:vimtex#re#tex_input
                                  let l:file = vimtex#parser#tex#input_parser(l:line, a:file, a:opts.root)
                                  call extend(l:lines, s:parse_preamble(l:file, a:opts, a:parsed_files))
   16              0.000016     else
   16              0.000063       call add(l:lines, l:line)
   16              0.000015     endif
                            
   16              0.000104     if l:line =~# '\\begin\s*{document}'
    2              0.000002       break
   14              0.000014     endif
   16              0.000037   endfor
                            
    2              0.000005   return l:lines

FUNCTION  vimtex#cmd#get_at()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cmd.vim:573
Called 1 time
Total time:   0.004300
 Self time:   0.000049

count  total (s)   self (s)
    1   0.000022   0.000013   let l:pos_saved = vimtex#pos#get_cursor()
    1   0.000107   0.000014   call call('vimtex#pos#set_cursor', a:000)
    1   0.004138   0.000013   let l:cmd = vimtex#cmd#get_current()
    1   0.000031   0.000005   call vimtex#pos#set_cursor(l:pos_saved)
    1              0.000001   return l:cmd

FUNCTION  vimtex#context#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/context.vim:7
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000004   command! -buffer VimtexContextMenu call vimtex#context#menu()
                            
    1              0.000005   nnoremap <buffer> <plug>(vimtex-context-menu) :VimtexContextMenu<cr>

FUNCTION  vimtex#log#error()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/log.vim:25
Called 1 time
Total time:   0.003008
 Self time:   0.000028

count  total (s)   self (s)
    1   0.003006   0.000026   call s:logger.add(a:000, 'error')

FUNCTION  vimtex#cmd#get_current()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cmd.vim:548
Called 1 time
Total time:   0.004125
 Self time:   0.000075

count  total (s)   self (s)
    1   0.000020   0.000012   let l:save_pos = vimtex#pos#get_cursor()
    1   0.000093   0.000015   let l:pos_val_cursor = vimtex#pos#val(l:save_pos)
                            
    1              0.000003   let l:depth = 3
    1              0.000004   while l:depth > 0
    1              0.000005     let l:depth -= 1
    1   0.003927   0.000015     let l:cmd = s:get_cmd('prev')
    1              0.000003     if empty(l:cmd) | break | endif
                            
    1   0.000032   0.000006     let l:pos_val = vimtex#pos#val(l:cmd.pos_end)
    1              0.000002     if l:pos_val >= l:pos_val_cursor
    1   0.000031   0.000005       call vimtex#pos#set_cursor(l:save_pos)
    1              0.000001       return l:cmd
                                else
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:cmd.pos_start))
                                endif
                              endwhile
                            
                              call vimtex#pos#set_cursor(l:save_pos)
                            
                              return {}

FUNCTION  vimtex#matchparen#init_buffer()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/matchparen.vim:7
Called 1 time
Total time:   0.000721
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000003   if !g:vimtex_matchparen_enabled | return | endif
                            
    1   0.000717   0.000005   call vimtex#matchparen#enable()

FUNCTION  vimtex#init()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex.vim:7
Called 1 time
Total time:   0.038015
 Self time:   0.000093

count  total (s)   self (s)
    1              0.000003   if exists('#User#VimtexEventInitPre')
                                doautocmd <nomodeline> User VimtexEventInitPre
    1              0.000001   endif
                            
    1   0.009529   0.000041   call vimtex#options#init()
                            
    1   0.009162   0.000004   call s:init_state()
    1   0.013491   0.000007   call s:init_buffer()
    1   0.005804   0.000010   call s:init_default_mappings()
                            
    1              0.000003   if exists('#User#VimtexEventInitPost')
                                doautocmd <nomodeline> User VimtexEventInitPost
    1              0.000001   endif
                            
    1              0.000002   augroup vimtex_main
    1              0.000007     autocmd!
    1              0.000007     autocmd VimLeave * call s:quit()
    1              0.000001   augroup END

FUNCTION  <SNR>87_get_cmd_overlay()
    Defined: ~/.local/share/nvim/lazy/vimtex/autoload/vimtex/cmd.vim:720
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000006   let l:match = matchstr(getline(a:lnum), '^\s*<[^>]*>', a:cnum)
                            
    1              0.000011   return empty(l:match) ? {} : {    'open' : {'lnum' : a:lnum, 'cnum' : a:cnum + 1},    'close' : {'lnum' : a:lnum, 'cnum' : a:cnum + strlen(l:match)},    'text' : l:match   }

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  208   0.122532   0.018051  <SNR>68_callback_nvim_output()
  208   0.103074   0.002523  <SNR>68_check_callback()
    6   0.100552   0.000677  vimtex#compiler#callback()
    3   0.084707   0.009904  vimtex#qf#open()
   43   0.061259   0.004015  213()
    3   0.060853   0.000542  vimtex#qf#setqflist()
    9   0.053934   0.013844  <SNR>1_LoadFTPlugin()
    3   0.051230   0.000243  81()
   46   0.044388   0.033943  <SNR>90_get_delim()
   43   0.043689   0.001936  vimtex#delim#get_current()
    3   0.041740   0.000830  82()
   66   0.040430             <SNR>19_try()
    1   0.038015   0.000093  vimtex#init()
    9   0.033761   0.012592  <SNR>70_fix_paths_hbox_warning()
  105   0.024434   0.021836  <SNR>26_Highlight_Matching_Pair()
  960   0.021152             vimtex#util#count()
    1   0.013484   0.001586  <SNR>52_init_buffer()
    5   0.012715   0.001051  206()
    5   0.010670   0.008415  vimtex#debug#stacktrace()
    4   0.009779   0.000044  vimtex#log#info()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   66              0.040430  <SNR>19_try()
   46   0.044388   0.033943  <SNR>90_get_delim()
  105   0.024434   0.021836  <SNR>26_Highlight_Matching_Pair()
  960              0.021152  vimtex#util#count()
  208   0.122532   0.018051  <SNR>68_callback_nvim_output()
    9   0.053934   0.013844  <SNR>1_LoadFTPlugin()
    9   0.033761   0.012592  <SNR>70_fix_paths_hbox_warning()
    3   0.084707   0.009904  vimtex#qf#open()
    5   0.010670   0.008415  vimtex#debug#stacktrace()
    3   0.009215   0.008179  vimtex#qf#u#caddfile()
    4   0.006522   0.006054  18()
   11   0.005524   0.005275  <SNR>43_SynSet()
  134              0.004752  <SNR>52_map()
   74              0.004234  <SNR>95_create_map()
   43   0.061259   0.004015  213()
   62   0.003339   0.003292  <SNR>102_parse_args()
   43              0.003043  vimtex#syntax#stack()
   45              0.002871  212()
   45              0.002814  197()
  114              0.002785  <SNR>26_Remove_Matches()

